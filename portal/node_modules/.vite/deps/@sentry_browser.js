import {
  Dsn,
  PromiseBuffer,
  SentryError,
  SessionStatus,
  Severity,
  Status,
  SyncPromise,
  addExceptionMechanism,
  addExceptionTypeValue,
  addInstrumentationHandler,
  consoleSandbox,
  dateTimestampInSeconds,
  dropUndefinedKeys,
  extractExceptionKeysForMessage,
  fill,
  getEventDescription,
  getFunctionName,
  getGlobalObject,
  getLocationHref,
  htmlTreeAsString,
  isDOMError,
  isDOMException,
  isError,
  isErrorEvent,
  isEvent,
  isInstanceOf,
  isMatchingPattern,
  isNativeFetch,
  isNodeEnv,
  isPlainObject,
  isPrimitive,
  isString,
  isThenable,
  logger,
  normalize,
  normalizeToSize,
  parseRetryAfterHeader,
  parseUrl,
  safeJoin,
  supportsFetch,
  supportsReferrerPolicy,
  truncate,
  urlEncode,
  uuid4
} from "./chunk-HEVF6ZVB.js";
import {
  __export
} from "./chunk-M4N47H3X.js";

// node_modules/@sentry/browser/node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign5(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}

// node_modules/@sentry/minimal/node_modules/tslib/tslib.es6.js
var __assign2 = function() {
  __assign2 = Object.assign || function __assign5(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function __read2(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread2() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read2(arguments[i]));
  return ar;
}

// node_modules/@sentry/hub/node_modules/tslib/tslib.es6.js
var __assign3 = function() {
  __assign3 = Object.assign || function __assign5(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
function __read3(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread3() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read3(arguments[i]));
  return ar;
}

// node_modules/@sentry/hub/esm/scope.js
var Scope = (
  /** @class */
  function() {
    function Scope2() {
      this._notifyingListeners = false;
      this._scopeListeners = [];
      this._eventProcessors = [];
      this._breadcrumbs = [];
      this._user = {};
      this._tags = {};
      this._extra = {};
      this._contexts = {};
    }
    Scope2.clone = function(scope) {
      var newScope = new Scope2();
      if (scope) {
        newScope._breadcrumbs = __spread3(scope._breadcrumbs);
        newScope._tags = __assign3({}, scope._tags);
        newScope._extra = __assign3({}, scope._extra);
        newScope._contexts = __assign3({}, scope._contexts);
        newScope._user = scope._user;
        newScope._level = scope._level;
        newScope._span = scope._span;
        newScope._session = scope._session;
        newScope._transactionName = scope._transactionName;
        newScope._fingerprint = scope._fingerprint;
        newScope._eventProcessors = __spread3(scope._eventProcessors);
      }
      return newScope;
    };
    Scope2.prototype.addScopeListener = function(callback) {
      this._scopeListeners.push(callback);
    };
    Scope2.prototype.addEventProcessor = function(callback) {
      this._eventProcessors.push(callback);
      return this;
    };
    Scope2.prototype.setUser = function(user) {
      this._user = user || {};
      if (this._session) {
        this._session.update({ user });
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getUser = function() {
      return this._user;
    };
    Scope2.prototype.setTags = function(tags) {
      this._tags = __assign3(__assign3({}, this._tags), tags);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTag = function(key, value) {
      var _a;
      this._tags = __assign3(__assign3({}, this._tags), (_a = {}, _a[key] = value, _a));
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setExtras = function(extras) {
      this._extra = __assign3(__assign3({}, this._extra), extras);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setExtra = function(key, extra) {
      var _a;
      this._extra = __assign3(__assign3({}, this._extra), (_a = {}, _a[key] = extra, _a));
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setFingerprint = function(fingerprint) {
      this._fingerprint = fingerprint;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setLevel = function(level) {
      this._level = level;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTransactionName = function(name) {
      this._transactionName = name;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTransaction = function(name) {
      return this.setTransactionName(name);
    };
    Scope2.prototype.setContext = function(key, context) {
      var _a;
      if (context === null) {
        delete this._contexts[key];
      } else {
        this._contexts = __assign3(__assign3({}, this._contexts), (_a = {}, _a[key] = context, _a));
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setSpan = function(span) {
      this._span = span;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getSpan = function() {
      return this._span;
    };
    Scope2.prototype.getTransaction = function() {
      var _a, _b, _c, _d;
      var span = this.getSpan();
      if ((_a = span) === null || _a === void 0 ? void 0 : _a.transaction) {
        return (_b = span) === null || _b === void 0 ? void 0 : _b.transaction;
      }
      if ((_d = (_c = span) === null || _c === void 0 ? void 0 : _c.spanRecorder) === null || _d === void 0 ? void 0 : _d.spans[0]) {
        return span.spanRecorder.spans[0];
      }
      return void 0;
    };
    Scope2.prototype.setSession = function(session) {
      if (!session) {
        delete this._session;
      } else {
        this._session = session;
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getSession = function() {
      return this._session;
    };
    Scope2.prototype.update = function(captureContext) {
      if (!captureContext) {
        return this;
      }
      if (typeof captureContext === "function") {
        var updatedScope = captureContext(this);
        return updatedScope instanceof Scope2 ? updatedScope : this;
      }
      if (captureContext instanceof Scope2) {
        this._tags = __assign3(__assign3({}, this._tags), captureContext._tags);
        this._extra = __assign3(__assign3({}, this._extra), captureContext._extra);
        this._contexts = __assign3(__assign3({}, this._contexts), captureContext._contexts);
        if (captureContext._user && Object.keys(captureContext._user).length) {
          this._user = captureContext._user;
        }
        if (captureContext._level) {
          this._level = captureContext._level;
        }
        if (captureContext._fingerprint) {
          this._fingerprint = captureContext._fingerprint;
        }
      } else if (isPlainObject(captureContext)) {
        captureContext = captureContext;
        this._tags = __assign3(__assign3({}, this._tags), captureContext.tags);
        this._extra = __assign3(__assign3({}, this._extra), captureContext.extra);
        this._contexts = __assign3(__assign3({}, this._contexts), captureContext.contexts);
        if (captureContext.user) {
          this._user = captureContext.user;
        }
        if (captureContext.level) {
          this._level = captureContext.level;
        }
        if (captureContext.fingerprint) {
          this._fingerprint = captureContext.fingerprint;
        }
      }
      return this;
    };
    Scope2.prototype.clear = function() {
      this._breadcrumbs = [];
      this._tags = {};
      this._extra = {};
      this._user = {};
      this._contexts = {};
      this._level = void 0;
      this._transactionName = void 0;
      this._fingerprint = void 0;
      this._span = void 0;
      this._session = void 0;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.addBreadcrumb = function(breadcrumb, maxBreadcrumbs) {
      var mergedBreadcrumb = __assign3({ timestamp: dateTimestampInSeconds() }, breadcrumb);
      this._breadcrumbs = maxBreadcrumbs !== void 0 && maxBreadcrumbs >= 0 ? __spread3(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxBreadcrumbs) : __spread3(this._breadcrumbs, [mergedBreadcrumb]);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.clearBreadcrumbs = function() {
      this._breadcrumbs = [];
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.applyToEvent = function(event, hint) {
      var _a;
      if (this._extra && Object.keys(this._extra).length) {
        event.extra = __assign3(__assign3({}, this._extra), event.extra);
      }
      if (this._tags && Object.keys(this._tags).length) {
        event.tags = __assign3(__assign3({}, this._tags), event.tags);
      }
      if (this._user && Object.keys(this._user).length) {
        event.user = __assign3(__assign3({}, this._user), event.user);
      }
      if (this._contexts && Object.keys(this._contexts).length) {
        event.contexts = __assign3(__assign3({}, this._contexts), event.contexts);
      }
      if (this._level) {
        event.level = this._level;
      }
      if (this._transactionName) {
        event.transaction = this._transactionName;
      }
      if (this._span) {
        event.contexts = __assign3({ trace: this._span.getTraceContext() }, event.contexts);
        var transactionName = (_a = this._span.transaction) === null || _a === void 0 ? void 0 : _a.name;
        if (transactionName) {
          event.tags = __assign3({ transaction: transactionName }, event.tags);
        }
      }
      this._applyFingerprint(event);
      event.breadcrumbs = __spread3(event.breadcrumbs || [], this._breadcrumbs);
      event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : void 0;
      return this._notifyEventProcessors(__spread3(getGlobalEventProcessors(), this._eventProcessors), event, hint);
    };
    Scope2.prototype._notifyEventProcessors = function(processors, event, hint, index) {
      var _this = this;
      if (index === void 0) {
        index = 0;
      }
      return new SyncPromise(function(resolve, reject) {
        var processor = processors[index];
        if (event === null || typeof processor !== "function") {
          resolve(event);
        } else {
          var result = processor(__assign3({}, event), hint);
          if (isThenable(result)) {
            result.then(function(final) {
              return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve);
            }).then(null, reject);
          } else {
            _this._notifyEventProcessors(processors, result, hint, index + 1).then(resolve).then(null, reject);
          }
        }
      });
    };
    Scope2.prototype._notifyScopeListeners = function() {
      var _this = this;
      if (!this._notifyingListeners) {
        this._notifyingListeners = true;
        this._scopeListeners.forEach(function(callback) {
          callback(_this);
        });
        this._notifyingListeners = false;
      }
    };
    Scope2.prototype._applyFingerprint = function(event) {
      event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : [];
      if (this._fingerprint) {
        event.fingerprint = event.fingerprint.concat(this._fingerprint);
      }
      if (event.fingerprint && !event.fingerprint.length) {
        delete event.fingerprint;
      }
    };
    return Scope2;
  }()
);
function getGlobalEventProcessors() {
  var global2 = getGlobalObject();
  global2.__SENTRY__ = global2.__SENTRY__ || {};
  global2.__SENTRY__.globalEventProcessors = global2.__SENTRY__.globalEventProcessors || [];
  return global2.__SENTRY__.globalEventProcessors;
}
function addGlobalEventProcessor(callback) {
  getGlobalEventProcessors().push(callback);
}

// node_modules/@sentry/hub/esm/session.js
var Session = (
  /** @class */
  function() {
    function Session2(context) {
      this.errors = 0;
      this.sid = uuid4();
      this.timestamp = Date.now();
      this.started = Date.now();
      this.duration = 0;
      this.status = SessionStatus.Ok;
      this.init = true;
      if (context) {
        this.update(context);
      }
    }
    Session2.prototype.update = function(context) {
      if (context === void 0) {
        context = {};
      }
      if (context.user) {
        if (context.user.ip_address) {
          this.ipAddress = context.user.ip_address;
        }
        if (!context.did) {
          this.did = context.user.id || context.user.email || context.user.username;
        }
      }
      this.timestamp = context.timestamp || Date.now();
      if (context.sid) {
        this.sid = context.sid.length === 32 ? context.sid : uuid4();
      }
      if (context.init !== void 0) {
        this.init = context.init;
      }
      if (context.did) {
        this.did = "" + context.did;
      }
      if (typeof context.started === "number") {
        this.started = context.started;
      }
      if (typeof context.duration === "number") {
        this.duration = context.duration;
      } else {
        this.duration = this.timestamp - this.started;
      }
      if (context.release) {
        this.release = context.release;
      }
      if (context.environment) {
        this.environment = context.environment;
      }
      if (context.ipAddress) {
        this.ipAddress = context.ipAddress;
      }
      if (context.userAgent) {
        this.userAgent = context.userAgent;
      }
      if (typeof context.errors === "number") {
        this.errors = context.errors;
      }
      if (context.status) {
        this.status = context.status;
      }
    };
    Session2.prototype.close = function(status) {
      if (status) {
        this.update({ status });
      } else if (this.status === SessionStatus.Ok) {
        this.update({ status: SessionStatus.Exited });
      } else {
        this.update();
      }
    };
    Session2.prototype.toJSON = function() {
      return dropUndefinedKeys({
        sid: "" + this.sid,
        init: this.init,
        started: new Date(this.started).toISOString(),
        timestamp: new Date(this.timestamp).toISOString(),
        status: this.status,
        errors: this.errors,
        did: typeof this.did === "number" || typeof this.did === "string" ? "" + this.did : void 0,
        duration: this.duration,
        attrs: dropUndefinedKeys({
          release: this.release,
          environment: this.environment,
          ip_address: this.ipAddress,
          user_agent: this.userAgent
        })
      });
    };
    return Session2;
  }()
);

// node_modules/@sentry/hub/esm/hub.js
var API_VERSION = 3;
var DEFAULT_BREADCRUMBS = 100;
var MAX_BREADCRUMBS = 100;
var Hub = (
  /** @class */
  function() {
    function Hub2(client, scope, _version) {
      if (scope === void 0) {
        scope = new Scope();
      }
      if (_version === void 0) {
        _version = API_VERSION;
      }
      this._version = _version;
      this._stack = [{}];
      this.getStackTop().scope = scope;
      this.bindClient(client);
    }
    Hub2.prototype.isOlderThan = function(version) {
      return this._version < version;
    };
    Hub2.prototype.bindClient = function(client) {
      var top = this.getStackTop();
      top.client = client;
      if (client && client.setupIntegrations) {
        client.setupIntegrations();
      }
    };
    Hub2.prototype.pushScope = function() {
      var scope = Scope.clone(this.getScope());
      this.getStack().push({
        client: this.getClient(),
        scope
      });
      return scope;
    };
    Hub2.prototype.popScope = function() {
      if (this.getStack().length <= 1)
        return false;
      return !!this.getStack().pop();
    };
    Hub2.prototype.withScope = function(callback) {
      var scope = this.pushScope();
      try {
        callback(scope);
      } finally {
        this.popScope();
      }
    };
    Hub2.prototype.getClient = function() {
      return this.getStackTop().client;
    };
    Hub2.prototype.getScope = function() {
      return this.getStackTop().scope;
    };
    Hub2.prototype.getStack = function() {
      return this._stack;
    };
    Hub2.prototype.getStackTop = function() {
      return this._stack[this._stack.length - 1];
    };
    Hub2.prototype.captureException = function(exception, hint) {
      var eventId = this._lastEventId = uuid4();
      var finalHint = hint;
      if (!hint) {
        var syntheticException = void 0;
        try {
          throw new Error("Sentry syntheticException");
        } catch (exception2) {
          syntheticException = exception2;
        }
        finalHint = {
          originalException: exception,
          syntheticException
        };
      }
      this._invokeClient("captureException", exception, __assign3(__assign3({}, finalHint), { event_id: eventId }));
      return eventId;
    };
    Hub2.prototype.captureMessage = function(message, level, hint) {
      var eventId = this._lastEventId = uuid4();
      var finalHint = hint;
      if (!hint) {
        var syntheticException = void 0;
        try {
          throw new Error(message);
        } catch (exception) {
          syntheticException = exception;
        }
        finalHint = {
          originalException: message,
          syntheticException
        };
      }
      this._invokeClient("captureMessage", message, level, __assign3(__assign3({}, finalHint), { event_id: eventId }));
      return eventId;
    };
    Hub2.prototype.captureEvent = function(event, hint) {
      var eventId = this._lastEventId = uuid4();
      this._invokeClient("captureEvent", event, __assign3(__assign3({}, hint), { event_id: eventId }));
      return eventId;
    };
    Hub2.prototype.lastEventId = function() {
      return this._lastEventId;
    };
    Hub2.prototype.addBreadcrumb = function(breadcrumb, hint) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (!scope || !client)
        return;
      var _b = client.getOptions && client.getOptions() || {}, _c = _b.beforeBreadcrumb, beforeBreadcrumb = _c === void 0 ? null : _c, _d = _b.maxBreadcrumbs, maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS : _d;
      if (maxBreadcrumbs <= 0)
        return;
      var timestamp = dateTimestampInSeconds();
      var mergedBreadcrumb = __assign3({ timestamp }, breadcrumb);
      var finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(function() {
        return beforeBreadcrumb(mergedBreadcrumb, hint);
      }) : mergedBreadcrumb;
      if (finalBreadcrumb === null)
        return;
      scope.addBreadcrumb(finalBreadcrumb, Math.min(maxBreadcrumbs, MAX_BREADCRUMBS));
    };
    Hub2.prototype.setUser = function(user) {
      var scope = this.getScope();
      if (scope)
        scope.setUser(user);
    };
    Hub2.prototype.setTags = function(tags) {
      var scope = this.getScope();
      if (scope)
        scope.setTags(tags);
    };
    Hub2.prototype.setExtras = function(extras) {
      var scope = this.getScope();
      if (scope)
        scope.setExtras(extras);
    };
    Hub2.prototype.setTag = function(key, value) {
      var scope = this.getScope();
      if (scope)
        scope.setTag(key, value);
    };
    Hub2.prototype.setExtra = function(key, extra) {
      var scope = this.getScope();
      if (scope)
        scope.setExtra(key, extra);
    };
    Hub2.prototype.setContext = function(name, context) {
      var scope = this.getScope();
      if (scope)
        scope.setContext(name, context);
    };
    Hub2.prototype.configureScope = function(callback) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (scope && client) {
        callback(scope);
      }
    };
    Hub2.prototype.run = function(callback) {
      var oldHub = makeMain(this);
      try {
        callback(this);
      } finally {
        makeMain(oldHub);
      }
    };
    Hub2.prototype.getIntegration = function(integration) {
      var client = this.getClient();
      if (!client)
        return null;
      try {
        return client.getIntegration(integration);
      } catch (_oO) {
        logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
        return null;
      }
    };
    Hub2.prototype.startSpan = function(context) {
      return this._callExtensionMethod("startSpan", context);
    };
    Hub2.prototype.startTransaction = function(context, customSamplingContext) {
      return this._callExtensionMethod("startTransaction", context, customSamplingContext);
    };
    Hub2.prototype.traceHeaders = function() {
      return this._callExtensionMethod("traceHeaders");
    };
    Hub2.prototype.captureSession = function(endSession) {
      if (endSession === void 0) {
        endSession = false;
      }
      if (endSession) {
        return this.endSession();
      }
      this._sendSessionUpdate();
    };
    Hub2.prototype.endSession = function() {
      var _a, _b, _c, _d, _e;
      (_c = (_b = (_a = this.getStackTop()) === null || _a === void 0 ? void 0 : _a.scope) === null || _b === void 0 ? void 0 : _b.getSession()) === null || _c === void 0 ? void 0 : _c.close();
      this._sendSessionUpdate();
      (_e = (_d = this.getStackTop()) === null || _d === void 0 ? void 0 : _d.scope) === null || _e === void 0 ? void 0 : _e.setSession();
    };
    Hub2.prototype.startSession = function(context) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      var _b = client && client.getOptions() || {}, release = _b.release, environment = _b.environment;
      var session = new Session(__assign3(__assign3({
        release,
        environment
      }, scope && { user: scope.getUser() }), context));
      if (scope) {
        var currentSession = scope.getSession && scope.getSession();
        if (currentSession && currentSession.status === SessionStatus.Ok) {
          currentSession.update({ status: SessionStatus.Exited });
        }
        this.endSession();
        scope.setSession(session);
      }
      return session;
    };
    Hub2.prototype._sendSessionUpdate = function() {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (!scope)
        return;
      var session = scope.getSession && scope.getSession();
      if (session) {
        if (client && client.captureSession) {
          client.captureSession(session);
        }
      }
    };
    Hub2.prototype._invokeClient = function(method) {
      var _a;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
      if (client && client[method]) {
        (_a = client)[method].apply(_a, __spread3(args, [scope]));
      }
    };
    Hub2.prototype._callExtensionMethod = function(method) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var carrier = getMainCarrier();
      var sentry = carrier.__SENTRY__;
      if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
        return sentry.extensions[method].apply(this, args);
      }
      logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
    };
    return Hub2;
  }()
);
function getMainCarrier() {
  var carrier = getGlobalObject();
  carrier.__SENTRY__ = carrier.__SENTRY__ || {
    extensions: {},
    hub: void 0
  };
  return carrier;
}
function makeMain(hub) {
  var registry = getMainCarrier();
  var oldHub = getHubFromCarrier(registry);
  setHubOnCarrier(registry, hub);
  return oldHub;
}
function getCurrentHub() {
  var registry = getMainCarrier();
  if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
    setHubOnCarrier(registry, new Hub());
  }
  if (isNodeEnv()) {
    return getHubFromActiveDomain(registry);
  }
  return getHubFromCarrier(registry);
}
function getHubFromActiveDomain(registry) {
  var _a, _b, _c;
  try {
    var activeDomain = (_c = (_b = (_a = getMainCarrier().__SENTRY__) === null || _a === void 0 ? void 0 : _a.extensions) === null || _b === void 0 ? void 0 : _b.domain) === null || _c === void 0 ? void 0 : _c.active;
    if (!activeDomain) {
      return getHubFromCarrier(registry);
    }
    if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {
      var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
      setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));
    }
    return getHubFromCarrier(activeDomain);
  } catch (_Oo) {
    return getHubFromCarrier(registry);
  }
}
function hasHubOnCarrier(carrier) {
  return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
}
function getHubFromCarrier(carrier) {
  if (carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub)
    return carrier.__SENTRY__.hub;
  carrier.__SENTRY__ = carrier.__SENTRY__ || {};
  carrier.__SENTRY__.hub = new Hub();
  return carrier.__SENTRY__.hub;
}
function setHubOnCarrier(carrier, hub) {
  if (!carrier)
    return false;
  carrier.__SENTRY__ = carrier.__SENTRY__ || {};
  carrier.__SENTRY__.hub = hub;
  return true;
}

// node_modules/@sentry/minimal/esm/index.js
function callOnHub(method) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var hub = getCurrentHub();
  if (hub && hub[method]) {
    return hub[method].apply(hub, __spread2(args));
  }
  throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
}
function captureException(exception, captureContext) {
  var syntheticException;
  try {
    throw new Error("Sentry syntheticException");
  } catch (exception2) {
    syntheticException = exception2;
  }
  return callOnHub("captureException", exception, {
    captureContext,
    originalException: exception,
    syntheticException
  });
}
function captureMessage(message, captureContext) {
  var syntheticException;
  try {
    throw new Error(message);
  } catch (exception) {
    syntheticException = exception;
  }
  var level = typeof captureContext === "string" ? captureContext : void 0;
  var context = typeof captureContext !== "string" ? { captureContext } : void 0;
  return callOnHub("captureMessage", message, level, __assign2({ originalException: message, syntheticException }, context));
}
function captureEvent(event) {
  return callOnHub("captureEvent", event);
}
function configureScope(callback) {
  callOnHub("configureScope", callback);
}
function addBreadcrumb(breadcrumb) {
  callOnHub("addBreadcrumb", breadcrumb);
}
function setContext(name, context) {
  callOnHub("setContext", name, context);
}
function setExtras(extras) {
  callOnHub("setExtras", extras);
}
function setTags(tags) {
  callOnHub("setTags", tags);
}
function setExtra(key, extra) {
  callOnHub("setExtra", key, extra);
}
function setTag(key, value) {
  callOnHub("setTag", key, value);
}
function setUser(user) {
  callOnHub("setUser", user);
}
function withScope(callback) {
  callOnHub("withScope", callback);
}
function startTransaction(context, customSamplingContext) {
  return callOnHub("startTransaction", __assign2({}, context), customSamplingContext);
}

// node_modules/@sentry/core/esm/api.js
var SENTRY_API_VERSION = "7";
var API = (
  /** @class */
  function() {
    function API2(dsn, metadata) {
      if (metadata === void 0) {
        metadata = {};
      }
      this.dsn = dsn;
      this._dsnObject = new Dsn(dsn);
      this.metadata = metadata;
    }
    API2.prototype.getDsn = function() {
      return this._dsnObject;
    };
    API2.prototype.getBaseApiEndpoint = function() {
      var dsn = this._dsnObject;
      var protocol = dsn.protocol ? dsn.protocol + ":" : "";
      var port = dsn.port ? ":" + dsn.port : "";
      return protocol + "//" + dsn.host + port + (dsn.path ? "/" + dsn.path : "") + "/api/";
    };
    API2.prototype.getStoreEndpoint = function() {
      return this._getIngestEndpoint("store");
    };
    API2.prototype.getStoreEndpointWithUrlEncodedAuth = function() {
      return this.getStoreEndpoint() + "?" + this._encodedAuth();
    };
    API2.prototype.getEnvelopeEndpointWithUrlEncodedAuth = function() {
      return this._getEnvelopeEndpoint() + "?" + this._encodedAuth();
    };
    API2.prototype.getStoreEndpointPath = function() {
      var dsn = this._dsnObject;
      return (dsn.path ? "/" + dsn.path : "") + "/api/" + dsn.projectId + "/store/";
    };
    API2.prototype.getRequestHeaders = function(clientName, clientVersion) {
      var dsn = this._dsnObject;
      var header = ["Sentry sentry_version=" + SENTRY_API_VERSION];
      header.push("sentry_client=" + clientName + "/" + clientVersion);
      header.push("sentry_key=" + dsn.publicKey);
      if (dsn.pass) {
        header.push("sentry_secret=" + dsn.pass);
      }
      return {
        "Content-Type": "application/json",
        "X-Sentry-Auth": header.join(", ")
      };
    };
    API2.prototype.getReportDialogEndpoint = function(dialogOptions) {
      if (dialogOptions === void 0) {
        dialogOptions = {};
      }
      var dsn = this._dsnObject;
      var endpoint = this.getBaseApiEndpoint() + "embed/error-page/";
      var encodedOptions = [];
      encodedOptions.push("dsn=" + dsn.toString());
      for (var key in dialogOptions) {
        if (key === "dsn") {
          continue;
        }
        if (key === "user") {
          if (!dialogOptions.user) {
            continue;
          }
          if (dialogOptions.user.name) {
            encodedOptions.push("name=" + encodeURIComponent(dialogOptions.user.name));
          }
          if (dialogOptions.user.email) {
            encodedOptions.push("email=" + encodeURIComponent(dialogOptions.user.email));
          }
        } else {
          encodedOptions.push(encodeURIComponent(key) + "=" + encodeURIComponent(dialogOptions[key]));
        }
      }
      if (encodedOptions.length) {
        return endpoint + "?" + encodedOptions.join("&");
      }
      return endpoint;
    };
    API2.prototype._getEnvelopeEndpoint = function() {
      return this._getIngestEndpoint("envelope");
    };
    API2.prototype._getIngestEndpoint = function(target) {
      var base = this.getBaseApiEndpoint();
      var dsn = this._dsnObject;
      return "" + base + dsn.projectId + "/" + target + "/";
    };
    API2.prototype._encodedAuth = function() {
      var dsn = this._dsnObject;
      var auth = {
        // We send only the minimum set of required information. See
        // https://github.com/getsentry/sentry-javascript/issues/2572.
        sentry_key: dsn.publicKey,
        sentry_version: SENTRY_API_VERSION
      };
      return urlEncode(auth);
    };
    return API2;
  }()
);

// node_modules/@sentry/core/node_modules/tslib/tslib.es6.js
var __assign4 = function() {
  __assign4 = Object.assign || function __assign5(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __values2(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read4(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread4() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read4(arguments[i]));
  return ar;
}

// node_modules/@sentry/core/esm/integration.js
var installedIntegrations = [];
function getIntegrationsToSetup(options) {
  var defaultIntegrations2 = options.defaultIntegrations && __spread4(options.defaultIntegrations) || [];
  var userIntegrations = options.integrations;
  var integrations = [];
  if (Array.isArray(userIntegrations)) {
    var userIntegrationsNames_1 = userIntegrations.map(function(i) {
      return i.name;
    });
    var pickedIntegrationsNames_1 = [];
    defaultIntegrations2.forEach(function(defaultIntegration) {
      if (userIntegrationsNames_1.indexOf(defaultIntegration.name) === -1 && pickedIntegrationsNames_1.indexOf(defaultIntegration.name) === -1) {
        integrations.push(defaultIntegration);
        pickedIntegrationsNames_1.push(defaultIntegration.name);
      }
    });
    userIntegrations.forEach(function(userIntegration) {
      if (pickedIntegrationsNames_1.indexOf(userIntegration.name) === -1) {
        integrations.push(userIntegration);
        pickedIntegrationsNames_1.push(userIntegration.name);
      }
    });
  } else if (typeof userIntegrations === "function") {
    integrations = userIntegrations(defaultIntegrations2);
    integrations = Array.isArray(integrations) ? integrations : [integrations];
  } else {
    integrations = __spread4(defaultIntegrations2);
  }
  var integrationsNames = integrations.map(function(i) {
    return i.name;
  });
  var alwaysLastToRun = "Debug";
  if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {
    integrations.push.apply(integrations, __spread4(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));
  }
  return integrations;
}
function setupIntegration(integration) {
  if (installedIntegrations.indexOf(integration.name) !== -1) {
    return;
  }
  integration.setupOnce(addGlobalEventProcessor, getCurrentHub);
  installedIntegrations.push(integration.name);
  logger.log("Integration installed: " + integration.name);
}
function setupIntegrations(options) {
  var integrations = {};
  getIntegrationsToSetup(options).forEach(function(integration) {
    integrations[integration.name] = integration;
    setupIntegration(integration);
  });
  return integrations;
}

// node_modules/@sentry/core/esm/baseclient.js
var BaseClient = (
  /** @class */
  function() {
    function BaseClient2(backendClass, options) {
      this._integrations = {};
      this._processing = 0;
      this._backend = new backendClass(options);
      this._options = options;
      if (options.dsn) {
        this._dsn = new Dsn(options.dsn);
      }
    }
    BaseClient2.prototype.captureException = function(exception, hint, scope) {
      var _this = this;
      var eventId = hint && hint.event_id;
      this._process(this._getBackend().eventFromException(exception, hint).then(function(event) {
        return _this._captureEvent(event, hint, scope);
      }).then(function(result) {
        eventId = result;
      }));
      return eventId;
    };
    BaseClient2.prototype.captureMessage = function(message, level, hint, scope) {
      var _this = this;
      var eventId = hint && hint.event_id;
      var promisedEvent = isPrimitive(message) ? this._getBackend().eventFromMessage(String(message), level, hint) : this._getBackend().eventFromException(message, hint);
      this._process(promisedEvent.then(function(event) {
        return _this._captureEvent(event, hint, scope);
      }).then(function(result) {
        eventId = result;
      }));
      return eventId;
    };
    BaseClient2.prototype.captureEvent = function(event, hint, scope) {
      var eventId = hint && hint.event_id;
      this._process(this._captureEvent(event, hint, scope).then(function(result) {
        eventId = result;
      }));
      return eventId;
    };
    BaseClient2.prototype.captureSession = function(session) {
      if (!session.release) {
        logger.warn("Discarded session because of missing release");
      } else {
        this._sendSession(session);
        session.update({ init: false });
      }
    };
    BaseClient2.prototype.getDsn = function() {
      return this._dsn;
    };
    BaseClient2.prototype.getOptions = function() {
      return this._options;
    };
    BaseClient2.prototype.flush = function(timeout) {
      var _this = this;
      return this._isClientProcessing(timeout).then(function(ready) {
        return _this._getBackend().getTransport().close(timeout).then(function(transportFlushed) {
          return ready && transportFlushed;
        });
      });
    };
    BaseClient2.prototype.close = function(timeout) {
      var _this = this;
      return this.flush(timeout).then(function(result) {
        _this.getOptions().enabled = false;
        return result;
      });
    };
    BaseClient2.prototype.setupIntegrations = function() {
      if (this._isEnabled()) {
        this._integrations = setupIntegrations(this._options);
      }
    };
    BaseClient2.prototype.getIntegration = function(integration) {
      try {
        return this._integrations[integration.id] || null;
      } catch (_oO) {
        logger.warn("Cannot retrieve integration " + integration.id + " from the current Client");
        return null;
      }
    };
    BaseClient2.prototype._updateSessionFromEvent = function(session, event) {
      var e_1, _a;
      var crashed = false;
      var errored = false;
      var userAgent;
      var exceptions = event.exception && event.exception.values;
      if (exceptions) {
        errored = true;
        try {
          for (var exceptions_1 = __values2(exceptions), exceptions_1_1 = exceptions_1.next(); !exceptions_1_1.done; exceptions_1_1 = exceptions_1.next()) {
            var ex = exceptions_1_1.value;
            var mechanism = ex.mechanism;
            if (mechanism && mechanism.handled === false) {
              crashed = true;
              break;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (exceptions_1_1 && !exceptions_1_1.done && (_a = exceptions_1.return))
              _a.call(exceptions_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
      var user = event.user;
      if (!session.userAgent) {
        var headers = event.request ? event.request.headers : {};
        for (var key in headers) {
          if (key.toLowerCase() === "user-agent") {
            userAgent = headers[key];
            break;
          }
        }
      }
      session.update(__assign4(__assign4({}, crashed && { status: SessionStatus.Crashed }), {
        user,
        userAgent,
        errors: session.errors + Number(errored || crashed)
      }));
      this.captureSession(session);
    };
    BaseClient2.prototype._sendSession = function(session) {
      this._getBackend().sendSession(session);
    };
    BaseClient2.prototype._isClientProcessing = function(timeout) {
      var _this = this;
      return new SyncPromise(function(resolve) {
        var ticked = 0;
        var tick = 1;
        var interval = setInterval(function() {
          if (_this._processing == 0) {
            clearInterval(interval);
            resolve(true);
          } else {
            ticked += tick;
            if (timeout && ticked >= timeout) {
              clearInterval(interval);
              resolve(false);
            }
          }
        }, tick);
      });
    };
    BaseClient2.prototype._getBackend = function() {
      return this._backend;
    };
    BaseClient2.prototype._isEnabled = function() {
      return this.getOptions().enabled !== false && this._dsn !== void 0;
    };
    BaseClient2.prototype._prepareEvent = function(event, scope, hint) {
      var _this = this;
      var _a = this.getOptions().normalizeDepth, normalizeDepth = _a === void 0 ? 3 : _a;
      var prepared = __assign4(__assign4({}, event), { event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()), timestamp: event.timestamp || dateTimestampInSeconds() });
      this._applyClientOptions(prepared);
      this._applyIntegrationsMetadata(prepared);
      var finalScope = scope;
      if (hint && hint.captureContext) {
        finalScope = Scope.clone(finalScope).update(hint.captureContext);
      }
      var result = SyncPromise.resolve(prepared);
      if (finalScope) {
        result = finalScope.applyToEvent(prepared, hint);
      }
      return result.then(function(evt) {
        if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
          return _this._normalizeEvent(evt, normalizeDepth);
        }
        return evt;
      });
    };
    BaseClient2.prototype._normalizeEvent = function(event, depth) {
      if (!event) {
        return null;
      }
      var normalized = __assign4(__assign4(__assign4(__assign4(__assign4({}, event), event.breadcrumbs && {
        breadcrumbs: event.breadcrumbs.map(function(b) {
          return __assign4(__assign4({}, b), b.data && {
            data: normalize(b.data, depth)
          });
        })
      }), event.user && {
        user: normalize(event.user, depth)
      }), event.contexts && {
        contexts: normalize(event.contexts, depth)
      }), event.extra && {
        extra: normalize(event.extra, depth)
      });
      if (event.contexts && event.contexts.trace) {
        normalized.contexts.trace = event.contexts.trace;
      }
      return normalized;
    };
    BaseClient2.prototype._applyClientOptions = function(event) {
      var options = this.getOptions();
      var environment = options.environment, release = options.release, dist = options.dist, _a = options.maxValueLength, maxValueLength = _a === void 0 ? 250 : _a;
      if (!("environment" in event)) {
        event.environment = "environment" in options ? environment : "production";
      }
      if (event.release === void 0 && release !== void 0) {
        event.release = release;
      }
      if (event.dist === void 0 && dist !== void 0) {
        event.dist = dist;
      }
      if (event.message) {
        event.message = truncate(event.message, maxValueLength);
      }
      var exception = event.exception && event.exception.values && event.exception.values[0];
      if (exception && exception.value) {
        exception.value = truncate(exception.value, maxValueLength);
      }
      var request = event.request;
      if (request && request.url) {
        request.url = truncate(request.url, maxValueLength);
      }
    };
    BaseClient2.prototype._applyIntegrationsMetadata = function(event) {
      var sdkInfo = event.sdk;
      var integrationsArray = Object.keys(this._integrations);
      if (sdkInfo && integrationsArray.length > 0) {
        sdkInfo.integrations = integrationsArray;
      }
    };
    BaseClient2.prototype._sendEvent = function(event) {
      this._getBackend().sendEvent(event);
    };
    BaseClient2.prototype._captureEvent = function(event, hint, scope) {
      return this._processEvent(event, hint, scope).then(function(finalEvent) {
        return finalEvent.event_id;
      }, function(reason) {
        logger.error(reason);
        return void 0;
      });
    };
    BaseClient2.prototype._processEvent = function(event, hint, scope) {
      var _this = this;
      var _a = this.getOptions(), beforeSend = _a.beforeSend, sampleRate = _a.sampleRate;
      if (!this._isEnabled()) {
        return SyncPromise.reject(new SentryError("SDK not enabled, will not send event."));
      }
      var isTransaction = event.type === "transaction";
      if (!isTransaction && typeof sampleRate === "number" && Math.random() > sampleRate) {
        return SyncPromise.reject(new SentryError("Discarding event because it's not included in the random sample (sampling rate = " + sampleRate + ")"));
      }
      return this._prepareEvent(event, scope, hint).then(function(prepared) {
        if (prepared === null) {
          throw new SentryError("An event processor returned null, will not send event.");
        }
        var isInternalException = hint && hint.data && hint.data.__sentry__ === true;
        if (isInternalException || isTransaction || !beforeSend) {
          return prepared;
        }
        var beforeSendResult = beforeSend(prepared, hint);
        if (typeof beforeSendResult === "undefined") {
          throw new SentryError("`beforeSend` method has to return `null` or a valid event.");
        } else if (isThenable(beforeSendResult)) {
          return beforeSendResult.then(function(event2) {
            return event2;
          }, function(e) {
            throw new SentryError("beforeSend rejected with " + e);
          });
        }
        return beforeSendResult;
      }).then(function(processedEvent) {
        if (processedEvent === null) {
          throw new SentryError("`beforeSend` returned `null`, will not send event.");
        }
        var session = scope && scope.getSession && scope.getSession();
        if (!isTransaction && session) {
          _this._updateSessionFromEvent(session, processedEvent);
        }
        _this._sendEvent(processedEvent);
        return processedEvent;
      }).then(null, function(reason) {
        if (reason instanceof SentryError) {
          throw reason;
        }
        _this.captureException(reason, {
          data: {
            __sentry__: true
          },
          originalException: reason
        });
        throw new SentryError("Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: " + reason);
      });
    };
    BaseClient2.prototype._process = function(promise) {
      var _this = this;
      this._processing += 1;
      promise.then(function(value) {
        _this._processing -= 1;
        return value;
      }, function(reason) {
        _this._processing -= 1;
        return reason;
      });
    };
    return BaseClient2;
  }()
);

// node_modules/@sentry/core/esm/transports/noop.js
var NoopTransport = (
  /** @class */
  function() {
    function NoopTransport2() {
    }
    NoopTransport2.prototype.sendEvent = function(_) {
      return SyncPromise.resolve({
        reason: "NoopTransport: Event has been skipped because no Dsn is configured.",
        status: Status.Skipped
      });
    };
    NoopTransport2.prototype.close = function(_) {
      return SyncPromise.resolve(true);
    };
    return NoopTransport2;
  }()
);

// node_modules/@sentry/core/esm/basebackend.js
var BaseBackend = (
  /** @class */
  function() {
    function BaseBackend2(options) {
      this._options = options;
      if (!this._options.dsn) {
        logger.warn("No DSN provided, backend will not do anything.");
      }
      this._transport = this._setupTransport();
    }
    BaseBackend2.prototype.eventFromException = function(_exception, _hint) {
      throw new SentryError("Backend has to implement `eventFromException` method");
    };
    BaseBackend2.prototype.eventFromMessage = function(_message, _level, _hint) {
      throw new SentryError("Backend has to implement `eventFromMessage` method");
    };
    BaseBackend2.prototype.sendEvent = function(event) {
      this._transport.sendEvent(event).then(null, function(reason) {
        logger.error("Error while sending event: " + reason);
      });
    };
    BaseBackend2.prototype.sendSession = function(session) {
      if (!this._transport.sendSession) {
        logger.warn("Dropping session because custom transport doesn't implement sendSession");
        return;
      }
      this._transport.sendSession(session).then(null, function(reason) {
        logger.error("Error while sending session: " + reason);
      });
    };
    BaseBackend2.prototype.getTransport = function() {
      return this._transport;
    };
    BaseBackend2.prototype._setupTransport = function() {
      return new NoopTransport();
    };
    return BaseBackend2;
  }()
);

// node_modules/@sentry/core/esm/request.js
function getSdkMetadataForEnvelopeHeader(api) {
  if (!api.metadata || !api.metadata.sdk) {
    return;
  }
  var _a = api.metadata.sdk, name = _a.name, version = _a.version;
  return { name, version };
}
function enhanceEventWithSdkInfo(event, sdkInfo) {
  if (!sdkInfo) {
    return event;
  }
  event.sdk = event.sdk || {
    name: sdkInfo.name,
    version: sdkInfo.version
  };
  event.sdk.name = event.sdk.name || sdkInfo.name;
  event.sdk.version = event.sdk.version || sdkInfo.version;
  event.sdk.integrations = __spread4(event.sdk.integrations || [], sdkInfo.integrations || []);
  event.sdk.packages = __spread4(event.sdk.packages || [], sdkInfo.packages || []);
  return event;
}
function sessionToSentryRequest(session, api) {
  var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
  var envelopeHeaders = JSON.stringify(__assign4({ sent_at: (/* @__PURE__ */ new Date()).toISOString() }, sdkInfo && { sdk: sdkInfo }));
  var itemHeaders = JSON.stringify({
    type: "session"
  });
  return {
    body: envelopeHeaders + "\n" + itemHeaders + "\n" + JSON.stringify(session),
    type: "session",
    url: api.getEnvelopeEndpointWithUrlEncodedAuth()
  };
}
function eventToSentryRequest(event, api) {
  var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
  var eventType = event.type || "event";
  var useEnvelope = eventType === "transaction";
  var _a = event.debug_meta || {}, transactionSampling = _a.transactionSampling, metadata = __rest(_a, ["transactionSampling"]);
  var _b = transactionSampling || {}, samplingMethod = _b.method, sampleRate = _b.rate;
  if (Object.keys(metadata).length === 0) {
    delete event.debug_meta;
  } else {
    event.debug_meta = metadata;
  }
  var req = {
    body: JSON.stringify(sdkInfo ? enhanceEventWithSdkInfo(event, api.metadata.sdk) : event),
    type: eventType,
    url: useEnvelope ? api.getEnvelopeEndpointWithUrlEncodedAuth() : api.getStoreEndpointWithUrlEncodedAuth()
  };
  if (useEnvelope) {
    var envelopeHeaders = JSON.stringify(__assign4({ event_id: event.event_id, sent_at: (/* @__PURE__ */ new Date()).toISOString() }, sdkInfo && { sdk: sdkInfo }));
    var itemHeaders = JSON.stringify({
      type: event.type,
      // TODO: Right now, sampleRate may or may not be defined (it won't be in the cases of inheritance and
      // explicitly-set sampling decisions). Are we good with that?
      sample_rates: [{ id: samplingMethod, rate: sampleRate }]
    });
    var envelope = envelopeHeaders + "\n" + itemHeaders + "\n" + req.body;
    req.body = envelope;
  }
  return req;
}

// node_modules/@sentry/core/esm/sdk.js
function initAndBind(clientClass, options) {
  if (options.debug === true) {
    logger.enable();
  }
  var hub = getCurrentHub();
  var client = new clientClass(options);
  hub.bindClient(client);
}

// node_modules/@sentry/core/esm/version.js
var SDK_VERSION = "6.2.5";

// node_modules/@sentry/core/esm/integrations/index.js
var integrations_exports = {};
__export(integrations_exports, {
  FunctionToString: () => FunctionToString,
  InboundFilters: () => InboundFilters
});

// node_modules/@sentry/core/esm/integrations/functiontostring.js
var originalFunctionToString;
var FunctionToString = (
  /** @class */
  function() {
    function FunctionToString2() {
      this.name = FunctionToString2.id;
    }
    FunctionToString2.prototype.setupOnce = function() {
      originalFunctionToString = Function.prototype.toString;
      Function.prototype.toString = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var context = this.__sentry_original__ || this;
        return originalFunctionToString.apply(context, args);
      };
    };
    FunctionToString2.id = "FunctionToString";
    return FunctionToString2;
  }()
);

// node_modules/@sentry/core/esm/integrations/inboundfilters.js
var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
var InboundFilters = (
  /** @class */
  function() {
    function InboundFilters2(_options) {
      if (_options === void 0) {
        _options = {};
      }
      this._options = _options;
      this.name = InboundFilters2.id;
    }
    InboundFilters2.prototype.setupOnce = function() {
      addGlobalEventProcessor(function(event) {
        var hub = getCurrentHub();
        if (!hub) {
          return event;
        }
        var self = hub.getIntegration(InboundFilters2);
        if (self) {
          var client = hub.getClient();
          var clientOptions = client ? client.getOptions() : {};
          var options = self._mergeOptions(clientOptions);
          if (self._shouldDropEvent(event, options)) {
            return null;
          }
        }
        return event;
      });
    };
    InboundFilters2.prototype._shouldDropEvent = function(event, options) {
      if (this._isSentryError(event, options)) {
        logger.warn("Event dropped due to being internal Sentry Error.\nEvent: " + getEventDescription(event));
        return true;
      }
      if (this._isIgnoredError(event, options)) {
        logger.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + getEventDescription(event));
        return true;
      }
      if (this._isDeniedUrl(event, options)) {
        logger.warn("Event dropped due to being matched by `denyUrls` option.\nEvent: " + getEventDescription(event) + ".\nUrl: " + this._getEventFilterUrl(event));
        return true;
      }
      if (!this._isAllowedUrl(event, options)) {
        logger.warn("Event dropped due to not being matched by `allowUrls` option.\nEvent: " + getEventDescription(event) + ".\nUrl: " + this._getEventFilterUrl(event));
        return true;
      }
      return false;
    };
    InboundFilters2.prototype._isSentryError = function(event, options) {
      if (!options.ignoreInternal) {
        return false;
      }
      try {
        return event && event.exception && event.exception.values && event.exception.values[0] && event.exception.values[0].type === "SentryError" || false;
      } catch (_oO) {
        return false;
      }
    };
    InboundFilters2.prototype._isIgnoredError = function(event, options) {
      if (!options.ignoreErrors || !options.ignoreErrors.length) {
        return false;
      }
      return this._getPossibleEventMessages(event).some(function(message) {
        return options.ignoreErrors.some(function(pattern) {
          return isMatchingPattern(message, pattern);
        });
      });
    };
    InboundFilters2.prototype._isDeniedUrl = function(event, options) {
      if (!options.denyUrls || !options.denyUrls.length) {
        return false;
      }
      var url = this._getEventFilterUrl(event);
      return !url ? false : options.denyUrls.some(function(pattern) {
        return isMatchingPattern(url, pattern);
      });
    };
    InboundFilters2.prototype._isAllowedUrl = function(event, options) {
      if (!options.allowUrls || !options.allowUrls.length) {
        return true;
      }
      var url = this._getEventFilterUrl(event);
      return !url ? true : options.allowUrls.some(function(pattern) {
        return isMatchingPattern(url, pattern);
      });
    };
    InboundFilters2.prototype._mergeOptions = function(clientOptions) {
      if (clientOptions === void 0) {
        clientOptions = {};
      }
      return {
        allowUrls: __spread4(this._options.whitelistUrls || [], this._options.allowUrls || [], clientOptions.whitelistUrls || [], clientOptions.allowUrls || []),
        denyUrls: __spread4(this._options.blacklistUrls || [], this._options.denyUrls || [], clientOptions.blacklistUrls || [], clientOptions.denyUrls || []),
        ignoreErrors: __spread4(this._options.ignoreErrors || [], clientOptions.ignoreErrors || [], DEFAULT_IGNORE_ERRORS),
        ignoreInternal: typeof this._options.ignoreInternal !== "undefined" ? this._options.ignoreInternal : true
      };
    };
    InboundFilters2.prototype._getPossibleEventMessages = function(event) {
      if (event.message) {
        return [event.message];
      }
      if (event.exception) {
        try {
          var _a = event.exception.values && event.exception.values[0] || {}, _b = _a.type, type = _b === void 0 ? "" : _b, _c = _a.value, value = _c === void 0 ? "" : _c;
          return ["" + value, type + ": " + value];
        } catch (oO) {
          logger.error("Cannot extract message for event " + getEventDescription(event));
          return [];
        }
      }
      return [];
    };
    InboundFilters2.prototype._getEventFilterUrl = function(event) {
      try {
        if (event.stacktrace) {
          var frames_1 = event.stacktrace.frames;
          return frames_1 && frames_1[frames_1.length - 1].filename || null;
        }
        if (event.exception) {
          var frames_2 = event.exception.values && event.exception.values[0].stacktrace && event.exception.values[0].stacktrace.frames;
          return frames_2 && frames_2[frames_2.length - 1].filename || null;
        }
        return null;
      } catch (oO) {
        logger.error("Cannot extract url for event " + getEventDescription(event));
        return null;
      }
    };
    InboundFilters2.id = "InboundFilters";
    return InboundFilters2;
  }()
);

// node_modules/@sentry/browser/esm/tracekit.js
var UNKNOWN_FUNCTION = "?";
var chrome = /^\s*at (?:(.*?) ?\()?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|capacitor).*?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
var winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
var geckoEval = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
var chromeEval = /\((\S*)(?::(\d+))(?::(\d+))\)/;
var reactMinifiedRegexp = /Minified React error #\d+;/i;
function computeStackTrace(ex) {
  var stack = null;
  var popSize = 0;
  if (ex) {
    if (typeof ex.framesToPop === "number") {
      popSize = ex.framesToPop;
    } else if (reactMinifiedRegexp.test(ex.message)) {
      popSize = 1;
    }
  }
  try {
    stack = computeStackTraceFromStacktraceProp(ex);
    if (stack) {
      return popFrames(stack, popSize);
    }
  } catch (e) {
  }
  try {
    stack = computeStackTraceFromStackProp(ex);
    if (stack) {
      return popFrames(stack, popSize);
    }
  } catch (e) {
  }
  return {
    message: extractMessage(ex),
    name: ex && ex.name,
    stack: [],
    failed: true
  };
}
function computeStackTraceFromStackProp(ex) {
  if (!ex || !ex.stack) {
    return null;
  }
  var stack = [];
  var lines = ex.stack.split("\n");
  var isEval;
  var submatch;
  var parts;
  var element;
  for (var i = 0; i < lines.length; ++i) {
    if (parts = chrome.exec(lines[i])) {
      var isNative = parts[2] && parts[2].indexOf("native") === 0;
      isEval = parts[2] && parts[2].indexOf("eval") === 0;
      if (isEval && (submatch = chromeEval.exec(parts[2]))) {
        parts[2] = submatch[1];
        parts[3] = submatch[2];
        parts[4] = submatch[3];
      }
      element = {
        // working with the regexp above is super painful. it is quite a hack, but just stripping the `address at `
        // prefix here seems like the quickest solution for now.
        url: parts[2] && parts[2].indexOf("address at ") === 0 ? parts[2].substr("address at ".length) : parts[2],
        func: parts[1] || UNKNOWN_FUNCTION,
        args: isNative ? [parts[2]] : [],
        line: parts[3] ? +parts[3] : null,
        column: parts[4] ? +parts[4] : null
      };
    } else if (parts = winjs.exec(lines[i])) {
      element = {
        url: parts[2],
        func: parts[1] || UNKNOWN_FUNCTION,
        args: [],
        line: +parts[3],
        column: parts[4] ? +parts[4] : null
      };
    } else if (parts = gecko.exec(lines[i])) {
      isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
      if (isEval && (submatch = geckoEval.exec(parts[3]))) {
        parts[1] = parts[1] || "eval";
        parts[3] = submatch[1];
        parts[4] = submatch[2];
        parts[5] = "";
      } else if (i === 0 && !parts[5] && ex.columnNumber !== void 0) {
        stack[0].column = ex.columnNumber + 1;
      }
      element = {
        url: parts[3],
        func: parts[1] || UNKNOWN_FUNCTION,
        args: parts[2] ? parts[2].split(",") : [],
        line: parts[4] ? +parts[4] : null,
        column: parts[5] ? +parts[5] : null
      };
    } else {
      continue;
    }
    if (!element.func && element.line) {
      element.func = UNKNOWN_FUNCTION;
    }
    stack.push(element);
  }
  if (!stack.length) {
    return null;
  }
  return {
    message: extractMessage(ex),
    name: ex.name,
    stack
  };
}
function computeStackTraceFromStacktraceProp(ex) {
  if (!ex || !ex.stacktrace) {
    return null;
  }
  var stacktrace = ex.stacktrace;
  var opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i;
  var opera11Regex = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\((.*)\))? in (.*):\s*$/i;
  var lines = stacktrace.split("\n");
  var stack = [];
  var parts;
  for (var line = 0; line < lines.length; line += 2) {
    var element = null;
    if (parts = opera10Regex.exec(lines[line])) {
      element = {
        url: parts[2],
        func: parts[3],
        args: [],
        line: +parts[1],
        column: null
      };
    } else if (parts = opera11Regex.exec(lines[line])) {
      element = {
        url: parts[6],
        func: parts[3] || parts[4],
        args: parts[5] ? parts[5].split(",") : [],
        line: +parts[1],
        column: +parts[2]
      };
    }
    if (element) {
      if (!element.func && element.line) {
        element.func = UNKNOWN_FUNCTION;
      }
      stack.push(element);
    }
  }
  if (!stack.length) {
    return null;
  }
  return {
    message: extractMessage(ex),
    name: ex.name,
    stack
  };
}
function popFrames(stacktrace, popSize) {
  try {
    return __assign(__assign({}, stacktrace), { stack: stacktrace.stack.slice(popSize) });
  } catch (e) {
    return stacktrace;
  }
}
function extractMessage(ex) {
  var message = ex && ex.message;
  if (!message) {
    return "No error message";
  }
  if (message.error && typeof message.error.message === "string") {
    return message.error.message;
  }
  return message;
}

// node_modules/@sentry/browser/esm/parsers.js
var STACKTRACE_LIMIT = 50;
function exceptionFromStacktrace(stacktrace) {
  var frames = prepareFramesForEvent(stacktrace.stack);
  var exception = {
    type: stacktrace.name,
    value: stacktrace.message
  };
  if (frames && frames.length) {
    exception.stacktrace = { frames };
  }
  if (exception.type === void 0 && exception.value === "") {
    exception.value = "Unrecoverable error caught";
  }
  return exception;
}
function eventFromPlainObject(exception, syntheticException, rejection) {
  var event = {
    exception: {
      values: [
        {
          type: isEvent(exception) ? exception.constructor.name : rejection ? "UnhandledRejection" : "Error",
          value: "Non-Error " + (rejection ? "promise rejection" : "exception") + " captured with keys: " + extractExceptionKeysForMessage(exception)
        }
      ]
    },
    extra: {
      __serialized__: normalizeToSize(exception)
    }
  };
  if (syntheticException) {
    var stacktrace = computeStackTrace(syntheticException);
    var frames_1 = prepareFramesForEvent(stacktrace.stack);
    event.stacktrace = {
      frames: frames_1
    };
  }
  return event;
}
function eventFromStacktrace(stacktrace) {
  var exception = exceptionFromStacktrace(stacktrace);
  return {
    exception: {
      values: [exception]
    }
  };
}
function prepareFramesForEvent(stack) {
  if (!stack || !stack.length) {
    return [];
  }
  var localStack = stack;
  var firstFrameFunction = localStack[0].func || "";
  var lastFrameFunction = localStack[localStack.length - 1].func || "";
  if (firstFrameFunction.indexOf("captureMessage") !== -1 || firstFrameFunction.indexOf("captureException") !== -1) {
    localStack = localStack.slice(1);
  }
  if (lastFrameFunction.indexOf("sentryWrapped") !== -1) {
    localStack = localStack.slice(0, -1);
  }
  return localStack.slice(0, STACKTRACE_LIMIT).map(function(frame) {
    return {
      colno: frame.column === null ? void 0 : frame.column,
      filename: frame.url || localStack[0].url,
      function: frame.func || "?",
      in_app: true,
      lineno: frame.line === null ? void 0 : frame.line
    };
  }).reverse();
}

// node_modules/@sentry/browser/esm/eventbuilder.js
function eventFromException(options, exception, hint) {
  var syntheticException = hint && hint.syntheticException || void 0;
  var event = eventFromUnknownInput(exception, syntheticException, {
    attachStacktrace: options.attachStacktrace
  });
  addExceptionMechanism(event, {
    handled: true,
    type: "generic"
  });
  event.level = Severity.Error;
  if (hint && hint.event_id) {
    event.event_id = hint.event_id;
  }
  return SyncPromise.resolve(event);
}
function eventFromMessage(options, message, level, hint) {
  if (level === void 0) {
    level = Severity.Info;
  }
  var syntheticException = hint && hint.syntheticException || void 0;
  var event = eventFromString(message, syntheticException, {
    attachStacktrace: options.attachStacktrace
  });
  event.level = level;
  if (hint && hint.event_id) {
    event.event_id = hint.event_id;
  }
  return SyncPromise.resolve(event);
}
function eventFromUnknownInput(exception, syntheticException, options) {
  if (options === void 0) {
    options = {};
  }
  var event;
  if (isErrorEvent(exception) && exception.error) {
    var errorEvent = exception;
    exception = errorEvent.error;
    event = eventFromStacktrace(computeStackTrace(exception));
    return event;
  }
  if (isDOMError(exception) || isDOMException(exception)) {
    var domException = exception;
    var name_1 = domException.name || (isDOMError(domException) ? "DOMError" : "DOMException");
    var message = domException.message ? name_1 + ": " + domException.message : name_1;
    event = eventFromString(message, syntheticException, options);
    addExceptionTypeValue(event, message);
    if ("code" in domException) {
      event.tags = __assign(__assign({}, event.tags), { "DOMException.code": "" + domException.code });
    }
    return event;
  }
  if (isError(exception)) {
    event = eventFromStacktrace(computeStackTrace(exception));
    return event;
  }
  if (isPlainObject(exception) || isEvent(exception)) {
    var objectException = exception;
    event = eventFromPlainObject(objectException, syntheticException, options.rejection);
    addExceptionMechanism(event, {
      synthetic: true
    });
    return event;
  }
  event = eventFromString(exception, syntheticException, options);
  addExceptionTypeValue(event, "" + exception, void 0);
  addExceptionMechanism(event, {
    synthetic: true
  });
  return event;
}
function eventFromString(input, syntheticException, options) {
  if (options === void 0) {
    options = {};
  }
  var event = {
    message: input
  };
  if (options.attachStacktrace && syntheticException) {
    var stacktrace = computeStackTrace(syntheticException);
    var frames_1 = prepareFramesForEvent(stacktrace.stack);
    event.stacktrace = {
      frames: frames_1
    };
  }
  return event;
}

// node_modules/@sentry/browser/esm/transports/index.js
var transports_exports = {};
__export(transports_exports, {
  BaseTransport: () => BaseTransport,
  FetchTransport: () => FetchTransport,
  XHRTransport: () => XHRTransport
});

// node_modules/@sentry/browser/esm/transports/base.js
var CATEGORY_MAPPING = {
  event: "error",
  transaction: "transaction",
  session: "session"
};
var BaseTransport = (
  /** @class */
  function() {
    function BaseTransport2(options) {
      this.options = options;
      this._buffer = new PromiseBuffer(30);
      this._rateLimits = {};
      this._api = new API(options.dsn, options._metadata);
      this.url = this._api.getStoreEndpointWithUrlEncodedAuth();
    }
    BaseTransport2.prototype.sendEvent = function(_) {
      throw new SentryError("Transport Class has to implement `sendEvent` method");
    };
    BaseTransport2.prototype.close = function(timeout) {
      return this._buffer.drain(timeout);
    };
    BaseTransport2.prototype._handleResponse = function(_a) {
      var requestType = _a.requestType, response = _a.response, headers = _a.headers, resolve = _a.resolve, reject = _a.reject;
      var status = Status.fromHttpCode(response.status);
      var limited = this._handleRateLimit(headers);
      if (limited)
        logger.warn("Too many requests, backing off until: " + this._disabledUntil(requestType));
      if (status === Status.Success) {
        resolve({ status });
        return;
      }
      reject(response);
    };
    BaseTransport2.prototype._disabledUntil = function(requestType) {
      var category = CATEGORY_MAPPING[requestType];
      return this._rateLimits[category] || this._rateLimits.all;
    };
    BaseTransport2.prototype._isRateLimited = function(requestType) {
      return this._disabledUntil(requestType) > new Date(Date.now());
    };
    BaseTransport2.prototype._handleRateLimit = function(headers) {
      var e_1, _a, e_2, _b;
      var now = Date.now();
      var rlHeader = headers["x-sentry-rate-limits"];
      var raHeader = headers["retry-after"];
      if (rlHeader) {
        try {
          for (var _c = __values(rlHeader.trim().split(",")), _d = _c.next(); !_d.done; _d = _c.next()) {
            var limit = _d.value;
            var parameters = limit.split(":", 2);
            var headerDelay = parseInt(parameters[0], 10);
            var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
            try {
              for (var _e = (e_2 = void 0, __values(parameters[1].split(";"))), _f = _e.next(); !_f.done; _f = _e.next()) {
                var category = _f.value;
                this._rateLimits[category || "all"] = new Date(now + delay);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_f && !_f.done && (_b = _e.return))
                  _b.call(_e);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_d && !_d.done && (_a = _c.return))
              _a.call(_c);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return true;
      } else if (raHeader) {
        this._rateLimits.all = new Date(now + parseRetryAfterHeader(now, raHeader));
        return true;
      }
      return false;
    };
    return BaseTransport2;
  }()
);

// node_modules/@sentry/browser/esm/transports/fetch.js
function getNativeFetchImplementation() {
  var _a, _b;
  var global2 = getGlobalObject();
  if (isNativeFetch(global2.fetch)) {
    return global2.fetch.bind(global2);
  }
  var document2 = global2.document;
  var fetchImpl = global2.fetch;
  if (typeof ((_a = document2) === null || _a === void 0 ? void 0 : _a.createElement) === "function") {
    try {
      var sandbox = document2.createElement("iframe");
      sandbox.hidden = true;
      document2.head.appendChild(sandbox);
      if ((_b = sandbox.contentWindow) === null || _b === void 0 ? void 0 : _b.fetch) {
        fetchImpl = sandbox.contentWindow.fetch;
      }
      document2.head.removeChild(sandbox);
    } catch (e) {
      logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e);
    }
  }
  return fetchImpl.bind(global2);
}
var FetchTransport = (
  /** @class */
  function(_super) {
    __extends(FetchTransport2, _super);
    function FetchTransport2(options, fetchImpl) {
      if (fetchImpl === void 0) {
        fetchImpl = getNativeFetchImplementation();
      }
      var _this = _super.call(this, options) || this;
      _this._fetch = fetchImpl;
      return _this;
    }
    FetchTransport2.prototype.sendEvent = function(event) {
      return this._sendRequest(eventToSentryRequest(event, this._api), event);
    };
    FetchTransport2.prototype.sendSession = function(session) {
      return this._sendRequest(sessionToSentryRequest(session, this._api), session);
    };
    FetchTransport2.prototype._sendRequest = function(sentryRequest, originalPayload) {
      var _this = this;
      if (this._isRateLimited(sentryRequest.type)) {
        return Promise.reject({
          event: originalPayload,
          type: sentryRequest.type,
          reason: "Transport locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
          status: 429
        });
      }
      var options = {
        body: sentryRequest.body,
        method: "POST",
        // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default
        // https://caniuse.com/#feat=referrer-policy
        // It doesn't. And it throw exception instead of ignoring this parameter...
        // REF: https://github.com/getsentry/raven-js/issues/1233
        referrerPolicy: supportsReferrerPolicy() ? "origin" : ""
      };
      if (this.options.fetchParameters !== void 0) {
        Object.assign(options, this.options.fetchParameters);
      }
      if (this.options.headers !== void 0) {
        options.headers = this.options.headers;
      }
      return this._buffer.add(new SyncPromise(function(resolve, reject) {
        _this._fetch(sentryRequest.url, options).then(function(response) {
          var headers = {
            "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
            "retry-after": response.headers.get("Retry-After")
          };
          _this._handleResponse({
            requestType: sentryRequest.type,
            response,
            headers,
            resolve,
            reject
          });
        }).catch(reject);
      }));
    };
    return FetchTransport2;
  }(BaseTransport)
);

// node_modules/@sentry/browser/esm/transports/xhr.js
var XHRTransport = (
  /** @class */
  function(_super) {
    __extends(XHRTransport2, _super);
    function XHRTransport2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    XHRTransport2.prototype.sendEvent = function(event) {
      return this._sendRequest(eventToSentryRequest(event, this._api), event);
    };
    XHRTransport2.prototype.sendSession = function(session) {
      return this._sendRequest(sessionToSentryRequest(session, this._api), session);
    };
    XHRTransport2.prototype._sendRequest = function(sentryRequest, originalPayload) {
      var _this = this;
      if (this._isRateLimited(sentryRequest.type)) {
        return Promise.reject({
          event: originalPayload,
          type: sentryRequest.type,
          reason: "Transport locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
          status: 429
        });
      }
      return this._buffer.add(new SyncPromise(function(resolve, reject) {
        var request = new XMLHttpRequest();
        request.onreadystatechange = function() {
          if (request.readyState === 4) {
            var headers = {
              "x-sentry-rate-limits": request.getResponseHeader("X-Sentry-Rate-Limits"),
              "retry-after": request.getResponseHeader("Retry-After")
            };
            _this._handleResponse({ requestType: sentryRequest.type, response: request, headers, resolve, reject });
          }
        };
        request.open("POST", sentryRequest.url);
        for (var header in _this.options.headers) {
          if (_this.options.headers.hasOwnProperty(header)) {
            request.setRequestHeader(header, _this.options.headers[header]);
          }
        }
        request.send(sentryRequest.body);
      }));
    };
    return XHRTransport2;
  }(BaseTransport)
);

// node_modules/@sentry/browser/esm/backend.js
var BrowserBackend = (
  /** @class */
  function(_super) {
    __extends(BrowserBackend2, _super);
    function BrowserBackend2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BrowserBackend2.prototype.eventFromException = function(exception, hint) {
      return eventFromException(this._options, exception, hint);
    };
    BrowserBackend2.prototype.eventFromMessage = function(message, level, hint) {
      if (level === void 0) {
        level = Severity.Info;
      }
      return eventFromMessage(this._options, message, level, hint);
    };
    BrowserBackend2.prototype._setupTransport = function() {
      if (!this._options.dsn) {
        return _super.prototype._setupTransport.call(this);
      }
      var transportOptions = __assign(__assign({}, this._options.transportOptions), { dsn: this._options.dsn, _metadata: this._options._metadata });
      if (this._options.transport) {
        return new this._options.transport(transportOptions);
      }
      if (supportsFetch()) {
        return new FetchTransport(transportOptions);
      }
      return new XHRTransport(transportOptions);
    };
    return BrowserBackend2;
  }(BaseBackend)
);

// node_modules/@sentry/browser/esm/helpers.js
var ignoreOnError = 0;
function shouldIgnoreOnError() {
  return ignoreOnError > 0;
}
function ignoreNextOnError() {
  ignoreOnError += 1;
  setTimeout(function() {
    ignoreOnError -= 1;
  });
}
function wrap(fn, options, before) {
  if (options === void 0) {
    options = {};
  }
  if (typeof fn !== "function") {
    return fn;
  }
  try {
    if (fn.__sentry__) {
      return fn;
    }
    if (fn.__sentry_wrapped__) {
      return fn.__sentry_wrapped__;
    }
  } catch (e) {
    return fn;
  }
  var sentryWrapped = function() {
    var args = Array.prototype.slice.call(arguments);
    try {
      if (before && typeof before === "function") {
        before.apply(this, arguments);
      }
      var wrappedArguments = args.map(function(arg) {
        return wrap(arg, options);
      });
      if (fn.handleEvent) {
        return fn.handleEvent.apply(this, wrappedArguments);
      }
      return fn.apply(this, wrappedArguments);
    } catch (ex) {
      ignoreNextOnError();
      withScope(function(scope) {
        scope.addEventProcessor(function(event) {
          var processedEvent = __assign({}, event);
          if (options.mechanism) {
            addExceptionTypeValue(processedEvent, void 0, void 0);
            addExceptionMechanism(processedEvent, options.mechanism);
          }
          processedEvent.extra = __assign(__assign({}, processedEvent.extra), { arguments: args });
          return processedEvent;
        });
        captureException(ex);
      });
      throw ex;
    }
  };
  try {
    for (var property in fn) {
      if (Object.prototype.hasOwnProperty.call(fn, property)) {
        sentryWrapped[property] = fn[property];
      }
    }
  } catch (_oO) {
  }
  fn.prototype = fn.prototype || {};
  sentryWrapped.prototype = fn.prototype;
  Object.defineProperty(fn, "__sentry_wrapped__", {
    enumerable: false,
    value: sentryWrapped
  });
  Object.defineProperties(sentryWrapped, {
    __sentry__: {
      enumerable: false,
      value: true
    },
    __sentry_original__: {
      enumerable: false,
      value: fn
    }
  });
  try {
    var descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
    if (descriptor.configurable) {
      Object.defineProperty(sentryWrapped, "name", {
        get: function() {
          return fn.name;
        }
      });
    }
  } catch (_oO) {
  }
  return sentryWrapped;
}
function injectReportDialog(options) {
  if (options === void 0) {
    options = {};
  }
  if (!options.eventId) {
    logger.error("Missing eventId option in showReportDialog call");
    return;
  }
  if (!options.dsn) {
    logger.error("Missing dsn option in showReportDialog call");
    return;
  }
  var script = document.createElement("script");
  script.async = true;
  script.src = new API(options.dsn).getReportDialogEndpoint(options);
  if (options.onLoad) {
    script.onload = options.onLoad;
  }
  (document.head || document.body).appendChild(script);
}

// node_modules/@sentry/browser/esm/integrations/index.js
var integrations_exports2 = {};
__export(integrations_exports2, {
  Breadcrumbs: () => Breadcrumbs,
  GlobalHandlers: () => GlobalHandlers,
  LinkedErrors: () => LinkedErrors,
  TryCatch: () => TryCatch,
  UserAgent: () => UserAgent
});

// node_modules/@sentry/browser/esm/integrations/globalhandlers.js
var GlobalHandlers = (
  /** @class */
  function() {
    function GlobalHandlers2(options) {
      this.name = GlobalHandlers2.id;
      this._onErrorHandlerInstalled = false;
      this._onUnhandledRejectionHandlerInstalled = false;
      this._options = __assign({ onerror: true, onunhandledrejection: true }, options);
    }
    GlobalHandlers2.prototype.setupOnce = function() {
      Error.stackTraceLimit = 50;
      if (this._options.onerror) {
        logger.log("Global Handler attached: onerror");
        this._installGlobalOnErrorHandler();
      }
      if (this._options.onunhandledrejection) {
        logger.log("Global Handler attached: onunhandledrejection");
        this._installGlobalOnUnhandledRejectionHandler();
      }
    };
    GlobalHandlers2.prototype._installGlobalOnErrorHandler = function() {
      var _this = this;
      if (this._onErrorHandlerInstalled) {
        return;
      }
      addInstrumentationHandler({
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        callback: function(data) {
          var error = data.error;
          var currentHub = getCurrentHub();
          var hasIntegration = currentHub.getIntegration(GlobalHandlers2);
          var isFailedOwnDelivery = error && error.__sentry_own_request__ === true;
          if (!hasIntegration || shouldIgnoreOnError() || isFailedOwnDelivery) {
            return;
          }
          var client = currentHub.getClient();
          var event = isPrimitive(error) ? _this._eventFromIncompleteOnError(data.msg, data.url, data.line, data.column) : _this._enhanceEventWithInitialFrame(eventFromUnknownInput(error, void 0, {
            attachStacktrace: client && client.getOptions().attachStacktrace,
            rejection: false
          }), data.url, data.line, data.column);
          addExceptionMechanism(event, {
            handled: false,
            type: "onerror"
          });
          currentHub.captureEvent(event, {
            originalException: error
          });
        },
        type: "error"
      });
      this._onErrorHandlerInstalled = true;
    };
    GlobalHandlers2.prototype._installGlobalOnUnhandledRejectionHandler = function() {
      var _this = this;
      if (this._onUnhandledRejectionHandlerInstalled) {
        return;
      }
      addInstrumentationHandler({
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        callback: function(e) {
          var error = e;
          try {
            if ("reason" in e) {
              error = e.reason;
            } else if ("detail" in e && "reason" in e.detail) {
              error = e.detail.reason;
            }
          } catch (_oO) {
          }
          var currentHub = getCurrentHub();
          var hasIntegration = currentHub.getIntegration(GlobalHandlers2);
          var isFailedOwnDelivery = error && error.__sentry_own_request__ === true;
          if (!hasIntegration || shouldIgnoreOnError() || isFailedOwnDelivery) {
            return true;
          }
          var client = currentHub.getClient();
          var event = isPrimitive(error) ? _this._eventFromRejectionWithPrimitive(error) : eventFromUnknownInput(error, void 0, {
            attachStacktrace: client && client.getOptions().attachStacktrace,
            rejection: true
          });
          event.level = Severity.Error;
          addExceptionMechanism(event, {
            handled: false,
            type: "onunhandledrejection"
          });
          currentHub.captureEvent(event, {
            originalException: error
          });
          return;
        },
        type: "unhandledrejection"
      });
      this._onUnhandledRejectionHandlerInstalled = true;
    };
    GlobalHandlers2.prototype._eventFromIncompleteOnError = function(msg, url, line, column) {
      var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
      var message = isErrorEvent(msg) ? msg.message : msg;
      var name;
      if (isString(message)) {
        var groups = message.match(ERROR_TYPES_RE);
        if (groups) {
          name = groups[1];
          message = groups[2];
        }
      }
      var event = {
        exception: {
          values: [
            {
              type: name || "Error",
              value: message
            }
          ]
        }
      };
      return this._enhanceEventWithInitialFrame(event, url, line, column);
    };
    GlobalHandlers2.prototype._eventFromRejectionWithPrimitive = function(reason) {
      return {
        exception: {
          values: [
            {
              type: "UnhandledRejection",
              // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
              value: "Non-Error promise rejection captured with value: " + String(reason)
            }
          ]
        }
      };
    };
    GlobalHandlers2.prototype._enhanceEventWithInitialFrame = function(event, url, line, column) {
      event.exception = event.exception || {};
      event.exception.values = event.exception.values || [];
      event.exception.values[0] = event.exception.values[0] || {};
      event.exception.values[0].stacktrace = event.exception.values[0].stacktrace || {};
      event.exception.values[0].stacktrace.frames = event.exception.values[0].stacktrace.frames || [];
      var colno = isNaN(parseInt(column, 10)) ? void 0 : column;
      var lineno = isNaN(parseInt(line, 10)) ? void 0 : line;
      var filename = isString(url) && url.length > 0 ? url : getLocationHref();
      if (event.exception.values[0].stacktrace.frames.length === 0) {
        event.exception.values[0].stacktrace.frames.push({
          colno,
          filename,
          function: "?",
          in_app: true,
          lineno
        });
      }
      return event;
    };
    GlobalHandlers2.id = "GlobalHandlers";
    return GlobalHandlers2;
  }()
);

// node_modules/@sentry/browser/esm/integrations/trycatch.js
var DEFAULT_EVENT_TARGET = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload"
];
var TryCatch = (
  /** @class */
  function() {
    function TryCatch2(options) {
      this.name = TryCatch2.id;
      this._options = __assign({ XMLHttpRequest: true, eventTarget: true, requestAnimationFrame: true, setInterval: true, setTimeout: true }, options);
    }
    TryCatch2.prototype.setupOnce = function() {
      var global2 = getGlobalObject();
      if (this._options.setTimeout) {
        fill(global2, "setTimeout", this._wrapTimeFunction.bind(this));
      }
      if (this._options.setInterval) {
        fill(global2, "setInterval", this._wrapTimeFunction.bind(this));
      }
      if (this._options.requestAnimationFrame) {
        fill(global2, "requestAnimationFrame", this._wrapRAF.bind(this));
      }
      if (this._options.XMLHttpRequest && "XMLHttpRequest" in global2) {
        fill(XMLHttpRequest.prototype, "send", this._wrapXHR.bind(this));
      }
      if (this._options.eventTarget) {
        var eventTarget = Array.isArray(this._options.eventTarget) ? this._options.eventTarget : DEFAULT_EVENT_TARGET;
        eventTarget.forEach(this._wrapEventTarget.bind(this));
      }
    };
    TryCatch2.prototype._wrapTimeFunction = function(original) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var originalCallback = args[0];
        args[0] = wrap(originalCallback, {
          mechanism: {
            data: { function: getFunctionName(original) },
            handled: true,
            type: "instrument"
          }
        });
        return original.apply(this, args);
      };
    };
    TryCatch2.prototype._wrapRAF = function(original) {
      return function(callback) {
        return original.call(this, wrap(callback, {
          mechanism: {
            data: {
              function: "requestAnimationFrame",
              handler: getFunctionName(original)
            },
            handled: true,
            type: "instrument"
          }
        }));
      };
    };
    TryCatch2.prototype._wrapEventTarget = function(target) {
      var global2 = getGlobalObject();
      var proto = global2[target] && global2[target].prototype;
      if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
        return;
      }
      fill(proto, "addEventListener", function(original) {
        return function(eventName, fn, options) {
          try {
            if (typeof fn.handleEvent === "function") {
              fn.handleEvent = wrap(fn.handleEvent.bind(fn), {
                mechanism: {
                  data: {
                    function: "handleEvent",
                    handler: getFunctionName(fn),
                    target
                  },
                  handled: true,
                  type: "instrument"
                }
              });
            }
          } catch (err) {
          }
          return original.call(
            this,
            eventName,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            wrap(fn, {
              mechanism: {
                data: {
                  function: "addEventListener",
                  handler: getFunctionName(fn),
                  target
                },
                handled: true,
                type: "instrument"
              }
            }),
            options
          );
        };
      });
      fill(proto, "removeEventListener", function(originalRemoveEventListener) {
        return function(eventName, fn, options) {
          var _a;
          var wrappedEventHandler = fn;
          try {
            var originalEventHandler = (_a = wrappedEventHandler) === null || _a === void 0 ? void 0 : _a.__sentry_wrapped__;
            if (originalEventHandler) {
              originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
            }
          } catch (e) {
          }
          return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
        };
      });
    };
    TryCatch2.prototype._wrapXHR = function(originalSend) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var xhr = this;
        var xmlHttpRequestProps = ["onload", "onerror", "onprogress", "onreadystatechange"];
        xmlHttpRequestProps.forEach(function(prop) {
          if (prop in xhr && typeof xhr[prop] === "function") {
            fill(xhr, prop, function(original) {
              var wrapOptions = {
                mechanism: {
                  data: {
                    function: prop,
                    handler: getFunctionName(original)
                  },
                  handled: true,
                  type: "instrument"
                }
              };
              if (original.__sentry_original__) {
                wrapOptions.mechanism.data.handler = getFunctionName(original.__sentry_original__);
              }
              return wrap(original, wrapOptions);
            });
          }
        });
        return originalSend.apply(this, args);
      };
    };
    TryCatch2.id = "TryCatch";
    return TryCatch2;
  }()
);

// node_modules/@sentry/browser/esm/integrations/breadcrumbs.js
var Breadcrumbs = (
  /** @class */
  function() {
    function Breadcrumbs2(options) {
      this.name = Breadcrumbs2.id;
      this._options = __assign({ console: true, dom: true, fetch: true, history: true, sentry: true, xhr: true }, options);
    }
    Breadcrumbs2.prototype.addSentryBreadcrumb = function(event) {
      if (!this._options.sentry) {
        return;
      }
      getCurrentHub().addBreadcrumb({
        category: "sentry." + (event.type === "transaction" ? "transaction" : "event"),
        event_id: event.event_id,
        level: event.level,
        message: getEventDescription(event)
      }, {
        event
      });
    };
    Breadcrumbs2.prototype.setupOnce = function() {
      var _this = this;
      if (this._options.console) {
        addInstrumentationHandler({
          callback: function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            _this._consoleBreadcrumb.apply(_this, __spread(args));
          },
          type: "console"
        });
      }
      if (this._options.dom) {
        addInstrumentationHandler({
          callback: function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            _this._domBreadcrumb.apply(_this, __spread(args));
          },
          type: "dom"
        });
      }
      if (this._options.xhr) {
        addInstrumentationHandler({
          callback: function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            _this._xhrBreadcrumb.apply(_this, __spread(args));
          },
          type: "xhr"
        });
      }
      if (this._options.fetch) {
        addInstrumentationHandler({
          callback: function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            _this._fetchBreadcrumb.apply(_this, __spread(args));
          },
          type: "fetch"
        });
      }
      if (this._options.history) {
        addInstrumentationHandler({
          callback: function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            _this._historyBreadcrumb.apply(_this, __spread(args));
          },
          type: "history"
        });
      }
    };
    Breadcrumbs2.prototype._consoleBreadcrumb = function(handlerData) {
      var breadcrumb = {
        category: "console",
        data: {
          arguments: handlerData.args,
          logger: "console"
        },
        level: Severity.fromString(handlerData.level),
        message: safeJoin(handlerData.args, " ")
      };
      if (handlerData.level === "assert") {
        if (handlerData.args[0] === false) {
          breadcrumb.message = "Assertion failed: " + (safeJoin(handlerData.args.slice(1), " ") || "console.assert");
          breadcrumb.data.arguments = handlerData.args.slice(1);
        } else {
          return;
        }
      }
      getCurrentHub().addBreadcrumb(breadcrumb, {
        input: handlerData.args,
        level: handlerData.level
      });
    };
    Breadcrumbs2.prototype._domBreadcrumb = function(handlerData) {
      var target;
      try {
        target = handlerData.event.target ? htmlTreeAsString(handlerData.event.target) : htmlTreeAsString(handlerData.event);
      } catch (e) {
        target = "<unknown>";
      }
      if (target.length === 0) {
        return;
      }
      getCurrentHub().addBreadcrumb({
        category: "ui." + handlerData.name,
        message: target
      }, {
        event: handlerData.event,
        name: handlerData.name,
        global: handlerData.global
      });
    };
    Breadcrumbs2.prototype._xhrBreadcrumb = function(handlerData) {
      if (handlerData.endTimestamp) {
        if (handlerData.xhr.__sentry_own_request__) {
          return;
        }
        var _a = handlerData.xhr.__sentry_xhr__ || {}, method = _a.method, url = _a.url, status_code = _a.status_code, body = _a.body;
        getCurrentHub().addBreadcrumb({
          category: "xhr",
          data: {
            method,
            url,
            status_code
          },
          type: "http"
        }, {
          xhr: handlerData.xhr,
          input: body
        });
        return;
      }
    };
    Breadcrumbs2.prototype._fetchBreadcrumb = function(handlerData) {
      if (!handlerData.endTimestamp) {
        return;
      }
      if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === "POST") {
        return;
      }
      if (handlerData.error) {
        getCurrentHub().addBreadcrumb({
          category: "fetch",
          data: handlerData.fetchData,
          level: Severity.Error,
          type: "http"
        }, {
          data: handlerData.error,
          input: handlerData.args
        });
      } else {
        getCurrentHub().addBreadcrumb({
          category: "fetch",
          data: __assign(__assign({}, handlerData.fetchData), { status_code: handlerData.response.status }),
          type: "http"
        }, {
          input: handlerData.args,
          response: handlerData.response
        });
      }
    };
    Breadcrumbs2.prototype._historyBreadcrumb = function(handlerData) {
      var global2 = getGlobalObject();
      var from = handlerData.from;
      var to = handlerData.to;
      var parsedLoc = parseUrl(global2.location.href);
      var parsedFrom = parseUrl(from);
      var parsedTo = parseUrl(to);
      if (!parsedFrom.path) {
        parsedFrom = parsedLoc;
      }
      if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
        to = parsedTo.relative;
      }
      if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
        from = parsedFrom.relative;
      }
      getCurrentHub().addBreadcrumb({
        category: "navigation",
        data: {
          from,
          to
        }
      });
    };
    Breadcrumbs2.id = "Breadcrumbs";
    return Breadcrumbs2;
  }()
);

// node_modules/@sentry/browser/esm/integrations/linkederrors.js
var DEFAULT_KEY = "cause";
var DEFAULT_LIMIT = 5;
var LinkedErrors = (
  /** @class */
  function() {
    function LinkedErrors2(options) {
      if (options === void 0) {
        options = {};
      }
      this.name = LinkedErrors2.id;
      this._key = options.key || DEFAULT_KEY;
      this._limit = options.limit || DEFAULT_LIMIT;
    }
    LinkedErrors2.prototype.setupOnce = function() {
      addGlobalEventProcessor(function(event, hint) {
        var self = getCurrentHub().getIntegration(LinkedErrors2);
        if (self) {
          return self._handler(event, hint);
        }
        return event;
      });
    };
    LinkedErrors2.prototype._handler = function(event, hint) {
      if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
        return event;
      }
      var linkedErrors = this._walkErrorTree(hint.originalException, this._key);
      event.exception.values = __spread(linkedErrors, event.exception.values);
      return event;
    };
    LinkedErrors2.prototype._walkErrorTree = function(error, key, stack) {
      if (stack === void 0) {
        stack = [];
      }
      if (!isInstanceOf(error[key], Error) || stack.length + 1 >= this._limit) {
        return stack;
      }
      var stacktrace = computeStackTrace(error[key]);
      var exception = exceptionFromStacktrace(stacktrace);
      return this._walkErrorTree(error[key], key, __spread([exception], stack));
    };
    LinkedErrors2.id = "LinkedErrors";
    return LinkedErrors2;
  }()
);

// node_modules/@sentry/browser/esm/integrations/useragent.js
var global = getGlobalObject();
var UserAgent = (
  /** @class */
  function() {
    function UserAgent2() {
      this.name = UserAgent2.id;
    }
    UserAgent2.prototype.setupOnce = function() {
      addGlobalEventProcessor(function(event) {
        var _a, _b, _c;
        if (getCurrentHub().getIntegration(UserAgent2)) {
          if (!global.navigator && !global.location && !global.document) {
            return event;
          }
          var url = ((_a = event.request) === null || _a === void 0 ? void 0 : _a.url) || ((_b = global.location) === null || _b === void 0 ? void 0 : _b.href);
          var referrer = (global.document || {}).referrer;
          var userAgent = (global.navigator || {}).userAgent;
          var headers = __assign(__assign(__assign({}, (_c = event.request) === null || _c === void 0 ? void 0 : _c.headers), referrer && { Referer: referrer }), userAgent && { "User-Agent": userAgent });
          var request = __assign(__assign({}, url && { url }), { headers });
          return __assign(__assign({}, event), { request });
        }
        return event;
      });
    };
    UserAgent2.id = "UserAgent";
    return UserAgent2;
  }()
);

// node_modules/@sentry/browser/esm/client.js
var BrowserClient = (
  /** @class */
  function(_super) {
    __extends(BrowserClient2, _super);
    function BrowserClient2(options) {
      if (options === void 0) {
        options = {};
      }
      var _this = this;
      options._metadata = options._metadata || {};
      options._metadata.sdk = options._metadata.sdk || {
        name: "sentry.javascript.browser",
        packages: [
          {
            name: "npm:@sentry/browser",
            version: SDK_VERSION
          }
        ],
        version: SDK_VERSION
      };
      _this = _super.call(this, BrowserBackend, options) || this;
      return _this;
    }
    BrowserClient2.prototype.showReportDialog = function(options) {
      if (options === void 0) {
        options = {};
      }
      var document2 = getGlobalObject().document;
      if (!document2) {
        return;
      }
      if (!this._isEnabled()) {
        logger.error("Trying to call showReportDialog with Sentry Client disabled");
        return;
      }
      injectReportDialog(__assign(__assign({}, options), { dsn: options.dsn || this.getDsn() }));
    };
    BrowserClient2.prototype._prepareEvent = function(event, scope, hint) {
      event.platform = event.platform || "javascript";
      return _super.prototype._prepareEvent.call(this, event, scope, hint);
    };
    BrowserClient2.prototype._sendEvent = function(event) {
      var integration = this.getIntegration(Breadcrumbs);
      if (integration) {
        integration.addSentryBreadcrumb(event);
      }
      _super.prototype._sendEvent.call(this, event);
    };
    return BrowserClient2;
  }(BaseClient)
);

// node_modules/@sentry/browser/esm/sdk.js
var defaultIntegrations = [
  new integrations_exports.InboundFilters(),
  new integrations_exports.FunctionToString(),
  new TryCatch(),
  new Breadcrumbs(),
  new GlobalHandlers(),
  new LinkedErrors(),
  new UserAgent()
];
function init(options) {
  if (options === void 0) {
    options = {};
  }
  if (options.defaultIntegrations === void 0) {
    options.defaultIntegrations = defaultIntegrations;
  }
  if (options.release === void 0) {
    var window_1 = getGlobalObject();
    if (window_1.SENTRY_RELEASE && window_1.SENTRY_RELEASE.id) {
      options.release = window_1.SENTRY_RELEASE.id;
    }
  }
  if (options.autoSessionTracking === void 0) {
    options.autoSessionTracking = true;
  }
  initAndBind(BrowserClient, options);
  if (options.autoSessionTracking) {
    startSessionTracking();
  }
}
function showReportDialog(options) {
  if (options === void 0) {
    options = {};
  }
  if (!options.eventId) {
    options.eventId = getCurrentHub().lastEventId();
  }
  var client = getCurrentHub().getClient();
  if (client) {
    client.showReportDialog(options);
  }
}
function lastEventId() {
  return getCurrentHub().lastEventId();
}
function forceLoad() {
}
function onLoad(callback) {
  callback();
}
function flush(timeout) {
  var client = getCurrentHub().getClient();
  if (client) {
    return client.flush(timeout);
  }
  return SyncPromise.reject(false);
}
function close(timeout) {
  var client = getCurrentHub().getClient();
  if (client) {
    return client.close(timeout);
  }
  return SyncPromise.reject(false);
}
function wrap2(fn) {
  return wrap(fn)();
}
function startSessionTracking() {
  var window = getGlobalObject();
  var document2 = window.document;
  if (typeof document2 === "undefined") {
    logger.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
    return;
  }
  var hub = getCurrentHub();
  if ("startSession" in hub) {
    hub.startSession();
    hub.captureSession();
    addInstrumentationHandler({
      callback: function() {
        hub.startSession();
        hub.captureSession();
      },
      type: "history"
    });
  }
}

// node_modules/@sentry/browser/esm/version.js
var SDK_NAME = "sentry.javascript.browser";

// node_modules/@sentry/browser/esm/index.js
var windowIntegrations = {};
var _window = getGlobalObject();
if (_window.Sentry && _window.Sentry.Integrations) {
  windowIntegrations = _window.Sentry.Integrations;
}
var INTEGRATIONS = __assign(__assign(__assign({}, windowIntegrations), integrations_exports), integrations_exports2);
export {
  BrowserClient,
  Hub,
  INTEGRATIONS as Integrations,
  SDK_NAME,
  SDK_VERSION,
  Scope,
  Severity,
  Status,
  transports_exports as Transports,
  addBreadcrumb,
  addGlobalEventProcessor,
  captureEvent,
  captureException,
  captureMessage,
  close,
  configureScope,
  defaultIntegrations,
  eventFromException,
  eventFromMessage,
  flush,
  forceLoad,
  getCurrentHub,
  getHubFromCarrier,
  init,
  injectReportDialog,
  lastEventId,
  makeMain,
  onLoad,
  setContext,
  setExtra,
  setExtras,
  setTag,
  setTags,
  setUser,
  showReportDialog,
  startTransaction,
  withScope,
  wrap2 as wrap
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@sentry_browser.js.map
