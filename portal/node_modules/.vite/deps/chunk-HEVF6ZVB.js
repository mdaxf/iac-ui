// node_modules/@sentry/utils/esm/node.js
function isNodeEnv() {
  return Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
}
function dynamicRequire(mod, request) {
  return mod.require(request);
}

// node_modules/@sentry/utils/esm/is.js
function isError(wat) {
  switch (Object.prototype.toString.call(wat)) {
    case "[object Error]":
      return true;
    case "[object Exception]":
      return true;
    case "[object DOMException]":
      return true;
    default:
      return isInstanceOf(wat, Error);
  }
}
function isErrorEvent(wat) {
  return Object.prototype.toString.call(wat) === "[object ErrorEvent]";
}
function isDOMError(wat) {
  return Object.prototype.toString.call(wat) === "[object DOMError]";
}
function isDOMException(wat) {
  return Object.prototype.toString.call(wat) === "[object DOMException]";
}
function isString(wat) {
  return Object.prototype.toString.call(wat) === "[object String]";
}
function isPrimitive(wat) {
  return wat === null || typeof wat !== "object" && typeof wat !== "function";
}
function isPlainObject(wat) {
  return Object.prototype.toString.call(wat) === "[object Object]";
}
function isEvent(wat) {
  return typeof Event !== "undefined" && isInstanceOf(wat, Event);
}
function isElement(wat) {
  return typeof Element !== "undefined" && isInstanceOf(wat, Element);
}
function isRegExp(wat) {
  return Object.prototype.toString.call(wat) === "[object RegExp]";
}
function isThenable(wat) {
  return Boolean(wat && wat.then && typeof wat.then === "function");
}
function isSyntheticEvent(wat) {
  return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
}
function isInstanceOf(wat, base) {
  try {
    return wat instanceof base;
  } catch (_e) {
    return false;
  }
}

// node_modules/@sentry/utils/esm/string.js
function truncate(str, max) {
  if (max === void 0) {
    max = 0;
  }
  if (typeof str !== "string" || max === 0) {
    return str;
  }
  return str.length <= max ? str : str.substr(0, max) + "...";
}
function safeJoin(input, delimiter) {
  if (!Array.isArray(input)) {
    return "";
  }
  var output = [];
  for (var i = 0; i < input.length; i++) {
    var value = input[i];
    try {
      output.push(String(value));
    } catch (e) {
      output.push("[value cannot be serialized]");
    }
  }
  return output.join(delimiter);
}
function isMatchingPattern(value, pattern) {
  if (!isString(value)) {
    return false;
  }
  if (isRegExp(pattern)) {
    return pattern.test(value);
  }
  if (typeof pattern === "string") {
    return value.indexOf(pattern) !== -1;
  }
  return false;
}

// node_modules/@sentry/utils/esm/misc.js
var fallbackGlobalObject = {};
function getGlobalObject() {
  return isNodeEnv() ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : fallbackGlobalObject;
}
function uuid4() {
  var global4 = getGlobalObject();
  var crypto = global4.crypto || global4.msCrypto;
  if (!(crypto === void 0) && crypto.getRandomValues) {
    var arr = new Uint16Array(8);
    crypto.getRandomValues(arr);
    arr[3] = arr[3] & 4095 | 16384;
    arr[4] = arr[4] & 16383 | 32768;
    var pad = function(num) {
      var v = num.toString(16);
      while (v.length < 4) {
        v = "0" + v;
      }
      return v;
    };
    return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
  }
  return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0;
    var v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function parseUrl(url) {
  if (!url) {
    return {};
  }
  var match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!match) {
    return {};
  }
  var query = match[6] || "";
  var fragment = match[8] || "";
  return {
    host: match[4],
    path: match[5],
    protocol: match[2],
    relative: match[5] + query + fragment
  };
}
function getEventDescription(event) {
  if (event.message) {
    return event.message;
  }
  if (event.exception && event.exception.values && event.exception.values[0]) {
    var exception = event.exception.values[0];
    if (exception.type && exception.value) {
      return exception.type + ": " + exception.value;
    }
    return exception.type || exception.value || event.event_id || "<unknown>";
  }
  return event.event_id || "<unknown>";
}
function consoleSandbox(callback) {
  var global4 = getGlobalObject();
  var levels = ["debug", "info", "warn", "error", "log", "assert"];
  if (!("console" in global4)) {
    return callback();
  }
  var originalConsole = global4.console;
  var wrappedLevels = {};
  levels.forEach(function(level) {
    if (level in global4.console && originalConsole[level].__sentry_original__) {
      wrappedLevels[level] = originalConsole[level];
      originalConsole[level] = originalConsole[level].__sentry_original__;
    }
  });
  var result = callback();
  Object.keys(wrappedLevels).forEach(function(level) {
    originalConsole[level] = wrappedLevels[level];
  });
  return result;
}
function addExceptionTypeValue(event, value, type) {
  event.exception = event.exception || {};
  event.exception.values = event.exception.values || [];
  event.exception.values[0] = event.exception.values[0] || {};
  event.exception.values[0].value = event.exception.values[0].value || value || "";
  event.exception.values[0].type = event.exception.values[0].type || type || "Error";
}
function addExceptionMechanism(event, mechanism) {
  if (mechanism === void 0) {
    mechanism = {};
  }
  try {
    event.exception.values[0].mechanism = event.exception.values[0].mechanism || {};
    Object.keys(mechanism).forEach(function(key) {
      event.exception.values[0].mechanism[key] = mechanism[key];
    });
  } catch (_oO) {
  }
}
function getLocationHref() {
  try {
    return document.location.href;
  } catch (oO) {
    return "";
  }
}
var defaultRetryAfter = 60 * 1e3;
function parseRetryAfterHeader(now, header) {
  if (!header) {
    return defaultRetryAfter;
  }
  var headerDelay = parseInt("" + header, 10);
  if (!isNaN(headerDelay)) {
    return headerDelay * 1e3;
  }
  var headerDate = Date.parse("" + header);
  if (!isNaN(headerDate)) {
    return headerDate - now;
  }
  return defaultRetryAfter;
}

// node_modules/@sentry/utils/esm/browser.js
function htmlTreeAsString(elem) {
  try {
    var currentElem = elem;
    var MAX_TRAVERSE_HEIGHT = 5;
    var MAX_OUTPUT_LEN = 80;
    var out = [];
    var height = 0;
    var len = 0;
    var separator = " > ";
    var sepLength = separator.length;
    var nextStr = void 0;
    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
      nextStr = _htmlElementAsString(currentElem);
      if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN) {
        break;
      }
      out.push(nextStr);
      len += nextStr.length;
      currentElem = currentElem.parentNode;
    }
    return out.reverse().join(separator);
  } catch (_oO) {
    return "<unknown>";
  }
}
function _htmlElementAsString(el) {
  var elem = el;
  var out = [];
  var className;
  var classes;
  var key;
  var attr;
  var i;
  if (!elem || !elem.tagName) {
    return "";
  }
  out.push(elem.tagName.toLowerCase());
  if (elem.id) {
    out.push("#" + elem.id);
  }
  className = elem.className;
  if (className && isString(className)) {
    classes = className.split(/\s+/);
    for (i = 0; i < classes.length; i++) {
      out.push("." + classes[i]);
    }
  }
  var allowedAttrs = ["type", "name", "title", "alt"];
  for (i = 0; i < allowedAttrs.length; i++) {
    key = allowedAttrs[i];
    attr = elem.getAttribute(key);
    if (attr) {
      out.push("[" + key + '="' + attr + '"]');
    }
  }
  return out.join("");
}

// node_modules/@sentry/utils/node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}

// node_modules/@sentry/utils/esm/polyfill.js
var setPrototypeOf = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
function setProtoOf(obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
function mixinProperties(obj, proto) {
  for (var prop in proto) {
    if (!obj.hasOwnProperty(prop)) {
      obj[prop] = proto[prop];
    }
  }
  return obj;
}

// node_modules/@sentry/utils/esm/error.js
var SentryError = (
  /** @class */
  function(_super) {
    __extends(SentryError2, _super);
    function SentryError2(message) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, message) || this;
      _this.message = message;
      _this.name = _newTarget.prototype.constructor.name;
      setPrototypeOf(_this, _newTarget.prototype);
      return _this;
    }
    return SentryError2;
  }(Error)
);

// node_modules/@sentry/utils/esm/dsn.js
var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;
var ERROR_MESSAGE = "Invalid Dsn";
var Dsn = (
  /** @class */
  function() {
    function Dsn2(from) {
      if (typeof from === "string") {
        this._fromString(from);
      } else {
        this._fromComponents(from);
      }
      this._validate();
    }
    Dsn2.prototype.toString = function(withPassword) {
      if (withPassword === void 0) {
        withPassword = false;
      }
      var _a = this, host = _a.host, path = _a.path, pass = _a.pass, port = _a.port, projectId = _a.projectId, protocol = _a.protocol, publicKey = _a.publicKey;
      return protocol + "://" + publicKey + (withPassword && pass ? ":" + pass : "") + ("@" + host + (port ? ":" + port : "") + "/" + (path ? path + "/" : path) + projectId);
    };
    Dsn2.prototype._fromString = function(str) {
      var match = DSN_REGEX.exec(str);
      if (!match) {
        throw new SentryError(ERROR_MESSAGE);
      }
      var _a = __read(match.slice(1), 6), protocol = _a[0], publicKey = _a[1], _b = _a[2], pass = _b === void 0 ? "" : _b, host = _a[3], _c = _a[4], port = _c === void 0 ? "" : _c, lastPath = _a[5];
      var path = "";
      var projectId = lastPath;
      var split = projectId.split("/");
      if (split.length > 1) {
        path = split.slice(0, -1).join("/");
        projectId = split.pop();
      }
      if (projectId) {
        var projectMatch = projectId.match(/^\d+/);
        if (projectMatch) {
          projectId = projectMatch[0];
        }
      }
      this._fromComponents({ host, pass, path, projectId, port, protocol, publicKey });
    };
    Dsn2.prototype._fromComponents = function(components) {
      if ("user" in components && !("publicKey" in components)) {
        components.publicKey = components.user;
      }
      this.user = components.publicKey || "";
      this.protocol = components.protocol;
      this.publicKey = components.publicKey || "";
      this.pass = components.pass || "";
      this.host = components.host;
      this.port = components.port || "";
      this.path = components.path || "";
      this.projectId = components.projectId;
    };
    Dsn2.prototype._validate = function() {
      var _this = this;
      ["protocol", "publicKey", "host", "projectId"].forEach(function(component) {
        if (!_this[component]) {
          throw new SentryError(ERROR_MESSAGE + ": " + component + " missing");
        }
      });
      if (!this.projectId.match(/^\d+$/)) {
        throw new SentryError(ERROR_MESSAGE + ": Invalid projectId " + this.projectId);
      }
      if (this.protocol !== "http" && this.protocol !== "https") {
        throw new SentryError(ERROR_MESSAGE + ": Invalid protocol " + this.protocol);
      }
      if (this.port && isNaN(parseInt(this.port, 10))) {
        throw new SentryError(ERROR_MESSAGE + ": Invalid port " + this.port);
      }
    };
    return Dsn2;
  }()
);

// node_modules/@sentry/utils/esm/logger.js
var global2 = getGlobalObject();
var PREFIX = "Sentry Logger ";
var Logger = (
  /** @class */
  function() {
    function Logger2() {
      this._enabled = false;
    }
    Logger2.prototype.disable = function() {
      this._enabled = false;
    };
    Logger2.prototype.enable = function() {
      this._enabled = true;
    };
    Logger2.prototype.log = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this._enabled) {
        return;
      }
      consoleSandbox(function() {
        global2.console.log(PREFIX + "[Log]: " + args.join(" "));
      });
    };
    Logger2.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this._enabled) {
        return;
      }
      consoleSandbox(function() {
        global2.console.warn(PREFIX + "[Warn]: " + args.join(" "));
      });
    };
    Logger2.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this._enabled) {
        return;
      }
      consoleSandbox(function() {
        global2.console.error(PREFIX + "[Error]: " + args.join(" "));
      });
    };
    return Logger2;
  }()
);
global2.__SENTRY__ = global2.__SENTRY__ || {};
var logger = global2.__SENTRY__.logger || (global2.__SENTRY__.logger = new Logger());

// node_modules/@sentry/utils/esm/memo.js
var Memo = (
  /** @class */
  function() {
    function Memo2() {
      this._hasWeakSet = typeof WeakSet === "function";
      this._inner = this._hasWeakSet ? /* @__PURE__ */ new WeakSet() : [];
    }
    Memo2.prototype.memoize = function(obj) {
      if (this._hasWeakSet) {
        if (this._inner.has(obj)) {
          return true;
        }
        this._inner.add(obj);
        return false;
      }
      for (var i = 0; i < this._inner.length; i++) {
        var value = this._inner[i];
        if (value === obj) {
          return true;
        }
      }
      this._inner.push(obj);
      return false;
    };
    Memo2.prototype.unmemoize = function(obj) {
      if (this._hasWeakSet) {
        this._inner.delete(obj);
      } else {
        for (var i = 0; i < this._inner.length; i++) {
          if (this._inner[i] === obj) {
            this._inner.splice(i, 1);
            break;
          }
        }
      }
    };
    return Memo2;
  }()
);

// node_modules/@sentry/utils/esm/stacktrace.js
var defaultFunctionName = "<anonymous>";
function getFunctionName(fn) {
  try {
    if (!fn || typeof fn !== "function") {
      return defaultFunctionName;
    }
    return fn.name || defaultFunctionName;
  } catch (e) {
    return defaultFunctionName;
  }
}

// node_modules/@sentry/utils/esm/object.js
function fill(source, name, replacementFactory) {
  if (!(name in source)) {
    return;
  }
  var original = source[name];
  var wrapped = replacementFactory(original);
  if (typeof wrapped === "function") {
    try {
      wrapped.prototype = wrapped.prototype || {};
      Object.defineProperties(wrapped, {
        __sentry_original__: {
          enumerable: false,
          value: original
        }
      });
    } catch (_Oo) {
    }
  }
  source[name] = wrapped;
}
function urlEncode(object) {
  return Object.keys(object).map(function(key) {
    return encodeURIComponent(key) + "=" + encodeURIComponent(object[key]);
  }).join("&");
}
function getWalkSource(value) {
  if (isError(value)) {
    var error = value;
    var err = {
      message: error.message,
      name: error.name,
      stack: error.stack
    };
    for (var i in error) {
      if (Object.prototype.hasOwnProperty.call(error, i)) {
        err[i] = error[i];
      }
    }
    return err;
  }
  if (isEvent(value)) {
    var event_1 = value;
    var source = {};
    source.type = event_1.type;
    try {
      source.target = isElement(event_1.target) ? htmlTreeAsString(event_1.target) : Object.prototype.toString.call(event_1.target);
    } catch (_oO) {
      source.target = "<unknown>";
    }
    try {
      source.currentTarget = isElement(event_1.currentTarget) ? htmlTreeAsString(event_1.currentTarget) : Object.prototype.toString.call(event_1.currentTarget);
    } catch (_oO) {
      source.currentTarget = "<unknown>";
    }
    if (typeof CustomEvent !== "undefined" && isInstanceOf(value, CustomEvent)) {
      source.detail = event_1.detail;
    }
    for (var i in event_1) {
      if (Object.prototype.hasOwnProperty.call(event_1, i)) {
        source[i] = event_1;
      }
    }
    return source;
  }
  return value;
}
function utf8Length(value) {
  return ~-encodeURI(value).split(/%..|./).length;
}
function jsonSize(value) {
  return utf8Length(JSON.stringify(value));
}
function normalizeToSize(object, depth, maxSize) {
  if (depth === void 0) {
    depth = 3;
  }
  if (maxSize === void 0) {
    maxSize = 100 * 1024;
  }
  var serialized = normalize(object, depth);
  if (jsonSize(serialized) > maxSize) {
    return normalizeToSize(object, depth - 1, maxSize);
  }
  return serialized;
}
function serializeValue(value) {
  var type = Object.prototype.toString.call(value);
  if (typeof value === "string") {
    return value;
  }
  if (type === "[object Object]") {
    return "[Object]";
  }
  if (type === "[object Array]") {
    return "[Array]";
  }
  var normalized = normalizeValue(value);
  return isPrimitive(normalized) ? normalized : type;
}
function normalizeValue(value, key) {
  if (key === "domain" && value && typeof value === "object" && value._events) {
    return "[Domain]";
  }
  if (key === "domainEmitter") {
    return "[DomainEmitter]";
  }
  if (typeof global !== "undefined" && value === global) {
    return "[Global]";
  }
  if (typeof window !== "undefined" && value === window) {
    return "[Window]";
  }
  if (typeof document !== "undefined" && value === document) {
    return "[Document]";
  }
  if (isSyntheticEvent(value)) {
    return "[SyntheticEvent]";
  }
  if (typeof value === "number" && value !== value) {
    return "[NaN]";
  }
  if (value === void 0) {
    return "[undefined]";
  }
  if (typeof value === "function") {
    return "[Function: " + getFunctionName(value) + "]";
  }
  if (typeof value === "symbol") {
    return "[" + String(value) + "]";
  }
  if (typeof value === "bigint") {
    return "[BigInt: " + String(value) + "]";
  }
  return value;
}
function walk(key, value, depth, memo) {
  if (depth === void 0) {
    depth = Infinity;
  }
  if (memo === void 0) {
    memo = new Memo();
  }
  if (depth === 0) {
    return serializeValue(value);
  }
  if (value !== null && value !== void 0 && typeof value.toJSON === "function") {
    return value.toJSON();
  }
  var normalized = normalizeValue(value, key);
  if (isPrimitive(normalized)) {
    return normalized;
  }
  var source = getWalkSource(value);
  var acc = Array.isArray(value) ? [] : {};
  if (memo.memoize(value)) {
    return "[Circular ~]";
  }
  for (var innerKey in source) {
    if (!Object.prototype.hasOwnProperty.call(source, innerKey)) {
      continue;
    }
    acc[innerKey] = walk(innerKey, source[innerKey], depth - 1, memo);
  }
  memo.unmemoize(value);
  return acc;
}
function normalize(input, depth) {
  try {
    return JSON.parse(JSON.stringify(input, function(key, value) {
      return walk(key, value, depth);
    }));
  } catch (_oO) {
    return "**non-serializable**";
  }
}
function extractExceptionKeysForMessage(exception, maxLength) {
  if (maxLength === void 0) {
    maxLength = 40;
  }
  var keys = Object.keys(getWalkSource(exception));
  keys.sort();
  if (!keys.length) {
    return "[object has no keys]";
  }
  if (keys[0].length >= maxLength) {
    return truncate(keys[0], maxLength);
  }
  for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {
    var serialized = keys.slice(0, includedKeys).join(", ");
    if (serialized.length > maxLength) {
      continue;
    }
    if (includedKeys === keys.length) {
      return serialized;
    }
    return truncate(serialized, maxLength);
  }
  return "";
}
function dropUndefinedKeys(val) {
  var e_1, _a;
  if (isPlainObject(val)) {
    var obj = val;
    var rv = {};
    try {
      for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var key = _c.value;
        if (typeof obj[key] !== "undefined") {
          rv[key] = dropUndefinedKeys(obj[key]);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return rv;
  }
  if (Array.isArray(val)) {
    return val.map(dropUndefinedKeys);
  }
  return val;
}

// node_modules/@sentry/utils/esm/supports.js
function supportsFetch() {
  if (!("fetch" in getGlobalObject())) {
    return false;
  }
  try {
    new Headers();
    new Request("");
    new Response();
    return true;
  } catch (e) {
    return false;
  }
}
function isNativeFetch(func) {
  return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
}
function supportsNativeFetch() {
  if (!supportsFetch()) {
    return false;
  }
  var global4 = getGlobalObject();
  if (isNativeFetch(global4.fetch)) {
    return true;
  }
  var result = false;
  var doc = global4.document;
  if (doc && typeof doc.createElement === "function") {
    try {
      var sandbox = doc.createElement("iframe");
      sandbox.hidden = true;
      doc.head.appendChild(sandbox);
      if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
        result = isNativeFetch(sandbox.contentWindow.fetch);
      }
      doc.head.removeChild(sandbox);
    } catch (err) {
      logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
    }
  }
  return result;
}
function supportsReportingObserver() {
  return "ReportingObserver" in getGlobalObject();
}
function supportsReferrerPolicy() {
  if (!supportsFetch()) {
    return false;
  }
  try {
    new Request("_", {
      referrerPolicy: "origin"
    });
    return true;
  } catch (e) {
    return false;
  }
}
function supportsHistory() {
  var global4 = getGlobalObject();
  var chrome = global4.chrome;
  var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
  var hasHistoryApi = "history" in global4 && !!global4.history.pushState && !!global4.history.replaceState;
  return !isChromePackagedApp && hasHistoryApi;
}

// node_modules/@sentry/utils/esm/instrument.js
var global3 = getGlobalObject();
var handlers = {};
var instrumented = {};
function instrument(type) {
  if (instrumented[type]) {
    return;
  }
  instrumented[type] = true;
  switch (type) {
    case "console":
      instrumentConsole();
      break;
    case "dom":
      instrumentDOM();
      break;
    case "xhr":
      instrumentXHR();
      break;
    case "fetch":
      instrumentFetch();
      break;
    case "history":
      instrumentHistory();
      break;
    case "error":
      instrumentError();
      break;
    case "unhandledrejection":
      instrumentUnhandledRejection();
      break;
    default:
      logger.warn("unknown instrumentation type:", type);
  }
}
function addInstrumentationHandler(handler) {
  if (!handler || typeof handler.type !== "string" || typeof handler.callback !== "function") {
    return;
  }
  handlers[handler.type] = handlers[handler.type] || [];
  handlers[handler.type].push(handler.callback);
  instrument(handler.type);
}
function triggerHandlers(type, data) {
  var e_1, _a;
  if (!type || !handlers[type]) {
    return;
  }
  try {
    for (var _b = __values(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {
      var handler = _c.value;
      try {
        handler(data);
      } catch (e) {
        logger.error("Error while triggering instrumentation handler.\nType: " + type + "\nName: " + getFunctionName(handler) + "\nError: " + e);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
}
function instrumentConsole() {
  if (!("console" in global3)) {
    return;
  }
  ["debug", "info", "warn", "error", "log", "assert"].forEach(function(level) {
    if (!(level in global3.console)) {
      return;
    }
    fill(global3.console, level, function(originalConsoleLevel) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        triggerHandlers("console", { args, level });
        if (originalConsoleLevel) {
          Function.prototype.apply.call(originalConsoleLevel, global3.console, args);
        }
      };
    });
  });
}
function instrumentFetch() {
  if (!supportsNativeFetch()) {
    return;
  }
  fill(global3, "fetch", function(originalFetch) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var handlerData = {
        args,
        fetchData: {
          method: getFetchMethod(args),
          url: getFetchUrl(args)
        },
        startTimestamp: Date.now()
      };
      triggerHandlers("fetch", __assign({}, handlerData));
      return originalFetch.apply(global3, args).then(function(response) {
        triggerHandlers("fetch", __assign(__assign({}, handlerData), { endTimestamp: Date.now(), response }));
        return response;
      }, function(error) {
        triggerHandlers("fetch", __assign(__assign({}, handlerData), { endTimestamp: Date.now(), error }));
        throw error;
      });
    };
  });
}
function getFetchMethod(fetchArgs) {
  if (fetchArgs === void 0) {
    fetchArgs = [];
  }
  if ("Request" in global3 && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {
    return String(fetchArgs[0].method).toUpperCase();
  }
  if (fetchArgs[1] && fetchArgs[1].method) {
    return String(fetchArgs[1].method).toUpperCase();
  }
  return "GET";
}
function getFetchUrl(fetchArgs) {
  if (fetchArgs === void 0) {
    fetchArgs = [];
  }
  if (typeof fetchArgs[0] === "string") {
    return fetchArgs[0];
  }
  if ("Request" in global3 && isInstanceOf(fetchArgs[0], Request)) {
    return fetchArgs[0].url;
  }
  return String(fetchArgs[0]);
}
function instrumentXHR() {
  if (!("XMLHttpRequest" in global3)) {
    return;
  }
  var requestKeys = [];
  var requestValues = [];
  var xhrproto = XMLHttpRequest.prototype;
  fill(xhrproto, "open", function(originalOpen) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var xhr = this;
      var url = args[1];
      xhr.__sentry_xhr__ = {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        method: isString(args[0]) ? args[0].toUpperCase() : args[0],
        url: args[1]
      };
      if (isString(url) && xhr.__sentry_xhr__.method === "POST" && url.match(/sentry_key/)) {
        xhr.__sentry_own_request__ = true;
      }
      var onreadystatechangeHandler = function() {
        if (xhr.readyState === 4) {
          try {
            if (xhr.__sentry_xhr__) {
              xhr.__sentry_xhr__.status_code = xhr.status;
            }
          } catch (e) {
          }
          try {
            var requestPos = requestKeys.indexOf(xhr);
            if (requestPos !== -1) {
              requestKeys.splice(requestPos);
              var args_1 = requestValues.splice(requestPos)[0];
              if (xhr.__sentry_xhr__ && args_1[0] !== void 0) {
                xhr.__sentry_xhr__.body = args_1[0];
              }
            }
          } catch (e) {
          }
          triggerHandlers("xhr", {
            args,
            endTimestamp: Date.now(),
            startTimestamp: Date.now(),
            xhr
          });
        }
      };
      if ("onreadystatechange" in xhr && typeof xhr.onreadystatechange === "function") {
        fill(xhr, "onreadystatechange", function(original) {
          return function() {
            var readyStateArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              readyStateArgs[_i2] = arguments[_i2];
            }
            onreadystatechangeHandler();
            return original.apply(xhr, readyStateArgs);
          };
        });
      } else {
        xhr.addEventListener("readystatechange", onreadystatechangeHandler);
      }
      return originalOpen.apply(xhr, args);
    };
  });
  fill(xhrproto, "send", function(originalSend) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      requestKeys.push(this);
      requestValues.push(args);
      triggerHandlers("xhr", {
        args,
        startTimestamp: Date.now(),
        xhr: this
      });
      return originalSend.apply(this, args);
    };
  });
}
var lastHref;
function instrumentHistory() {
  if (!supportsHistory()) {
    return;
  }
  var oldOnPopState = global3.onpopstate;
  global3.onpopstate = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var to = global3.location.href;
    var from = lastHref;
    lastHref = to;
    triggerHandlers("history", {
      from,
      to
    });
    if (oldOnPopState) {
      return oldOnPopState.apply(this, args);
    }
  };
  function historyReplacementFunction(originalHistoryFunction) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var url = args.length > 2 ? args[2] : void 0;
      if (url) {
        var from = lastHref;
        var to = String(url);
        lastHref = to;
        triggerHandlers("history", {
          from,
          to
        });
      }
      return originalHistoryFunction.apply(this, args);
    };
  }
  fill(global3.history, "pushState", historyReplacementFunction);
  fill(global3.history, "replaceState", historyReplacementFunction);
}
var debounceDuration = 1e3;
var debounceTimerID;
var lastCapturedEvent;
function shouldShortcircuitPreviousDebounce(previous, current) {
  if (!previous) {
    return true;
  }
  if (previous.type !== current.type) {
    return true;
  }
  try {
    if (previous.target !== current.target) {
      return true;
    }
  } catch (e) {
  }
  return false;
}
function shouldSkipDOMEvent(event) {
  if (event.type !== "keypress") {
    return false;
  }
  try {
    var target = event.target;
    if (!target || !target.tagName) {
      return true;
    }
    if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
      return false;
    }
  } catch (e) {
  }
  return true;
}
function makeDOMEventHandler(handler, globalListener) {
  if (globalListener === void 0) {
    globalListener = false;
  }
  return function(event) {
    if (!event || lastCapturedEvent === event) {
      return;
    }
    if (shouldSkipDOMEvent(event)) {
      return;
    }
    var name = event.type === "keypress" ? "input" : event.type;
    if (debounceTimerID === void 0) {
      handler({
        event,
        name,
        global: globalListener
      });
      lastCapturedEvent = event;
    } else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
      handler({
        event,
        name,
        global: globalListener
      });
      lastCapturedEvent = event;
    }
    clearTimeout(debounceTimerID);
    debounceTimerID = global3.setTimeout(function() {
      debounceTimerID = void 0;
    }, debounceDuration);
  };
}
function instrumentDOM() {
  if (!("document" in global3)) {
    return;
  }
  var triggerDOMHandler = triggerHandlers.bind(null, "dom");
  var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
  global3.document.addEventListener("click", globalDOMEventHandler, false);
  global3.document.addEventListener("keypress", globalDOMEventHandler, false);
  ["EventTarget", "Node"].forEach(function(target) {
    var proto = global3[target] && global3[target].prototype;
    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
      return;
    }
    fill(proto, "addEventListener", function(originalAddEventListener) {
      return function(type, listener, options) {
        if (type === "click" || type == "keypress") {
          try {
            var el = this;
            var handlers_1 = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};
            var handlerForType = handlers_1[type] = handlers_1[type] || { refCount: 0 };
            if (!handlerForType.handler) {
              var handler = makeDOMEventHandler(triggerDOMHandler);
              handlerForType.handler = handler;
              originalAddEventListener.call(this, type, handler, options);
            }
            handlerForType.refCount += 1;
          } catch (e) {
          }
        }
        return originalAddEventListener.call(this, type, listener, options);
      };
    });
    fill(proto, "removeEventListener", function(originalRemoveEventListener) {
      return function(type, listener, options) {
        if (type === "click" || type == "keypress") {
          try {
            var el = this;
            var handlers_2 = el.__sentry_instrumentation_handlers__ || {};
            var handlerForType = handlers_2[type];
            if (handlerForType) {
              handlerForType.refCount -= 1;
              if (handlerForType.refCount <= 0) {
                originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                handlerForType.handler = void 0;
                delete handlers_2[type];
              }
              if (Object.keys(handlers_2).length === 0) {
                delete el.__sentry_instrumentation_handlers__;
              }
            }
          } catch (e) {
          }
        }
        return originalRemoveEventListener.call(this, type, listener, options);
      };
    });
  });
}
var _oldOnErrorHandler = null;
function instrumentError() {
  _oldOnErrorHandler = global3.onerror;
  global3.onerror = function(msg, url, line, column, error) {
    triggerHandlers("error", {
      column,
      error,
      line,
      msg,
      url
    });
    if (_oldOnErrorHandler) {
      return _oldOnErrorHandler.apply(this, arguments);
    }
    return false;
  };
}
var _oldOnUnhandledRejectionHandler = null;
function instrumentUnhandledRejection() {
  _oldOnUnhandledRejectionHandler = global3.onunhandledrejection;
  global3.onunhandledrejection = function(e) {
    triggerHandlers("unhandledrejection", e);
    if (_oldOnUnhandledRejectionHandler) {
      return _oldOnUnhandledRejectionHandler.apply(this, arguments);
    }
    return true;
  };
}

// node_modules/@sentry/utils/esm/path.js
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === ".") {
      parts.splice(i, 1);
    } else if (last === "..") {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift("..");
    }
  }
  return parts;
}
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^/]+?|)(\.[^./]*|))(?:[/]*)$/;
function splitPath(filename) {
  var parts = splitPathRe.exec(filename);
  return parts ? parts.slice(1) : [];
}
function resolve() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resolvedPath = "";
  var resolvedAbsolute = false;
  for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? args[i] : "/";
    if (!path) {
      continue;
    }
    resolvedPath = path + "/" + resolvedPath;
    resolvedAbsolute = path.charAt(0) === "/";
  }
  resolvedPath = normalizeArray(resolvedPath.split("/").filter(function(p) {
    return !!p;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function trim(arr) {
  var start = 0;
  for (; start < arr.length; start++) {
    if (arr[start] !== "") {
      break;
    }
  }
  var end = arr.length - 1;
  for (; end >= 0; end--) {
    if (arr[end] !== "") {
      break;
    }
  }
  if (start > end) {
    return [];
  }
  return arr.slice(start, end - start + 1);
}
function relative(from, to) {
  from = resolve(from).substr(1);
  to = resolve(to).substr(1);
  var fromParts = trim(from.split("/"));
  var toParts = trim(to.split("/"));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }
  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
}
function basename(path, ext) {
  var f = splitPath(path)[2];
  if (ext && f.substr(ext.length * -1) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
}

// node_modules/@sentry/utils/esm/syncpromise.js
var States;
(function(States2) {
  States2["PENDING"] = "PENDING";
  States2["RESOLVED"] = "RESOLVED";
  States2["REJECTED"] = "REJECTED";
})(States || (States = {}));
var SyncPromise = (
  /** @class */
  function() {
    function SyncPromise2(executor) {
      var _this = this;
      this._state = States.PENDING;
      this._handlers = [];
      this._resolve = function(value) {
        _this._setResult(States.RESOLVED, value);
      };
      this._reject = function(reason) {
        _this._setResult(States.REJECTED, reason);
      };
      this._setResult = function(state, value) {
        if (_this._state !== States.PENDING) {
          return;
        }
        if (isThenable(value)) {
          value.then(_this._resolve, _this._reject);
          return;
        }
        _this._state = state;
        _this._value = value;
        _this._executeHandlers();
      };
      this._attachHandler = function(handler) {
        _this._handlers = _this._handlers.concat(handler);
        _this._executeHandlers();
      };
      this._executeHandlers = function() {
        if (_this._state === States.PENDING) {
          return;
        }
        var cachedHandlers = _this._handlers.slice();
        _this._handlers = [];
        cachedHandlers.forEach(function(handler) {
          if (handler.done) {
            return;
          }
          if (_this._state === States.RESOLVED) {
            if (handler.onfulfilled) {
              handler.onfulfilled(_this._value);
            }
          }
          if (_this._state === States.REJECTED) {
            if (handler.onrejected) {
              handler.onrejected(_this._value);
            }
          }
          handler.done = true;
        });
      };
      try {
        executor(this._resolve, this._reject);
      } catch (e) {
        this._reject(e);
      }
    }
    SyncPromise2.resolve = function(value) {
      return new SyncPromise2(function(resolve2) {
        resolve2(value);
      });
    };
    SyncPromise2.reject = function(reason) {
      return new SyncPromise2(function(_, reject) {
        reject(reason);
      });
    };
    SyncPromise2.all = function(collection) {
      return new SyncPromise2(function(resolve2, reject) {
        if (!Array.isArray(collection)) {
          reject(new TypeError("Promise.all requires an array as input."));
          return;
        }
        if (collection.length === 0) {
          resolve2([]);
          return;
        }
        var counter = collection.length;
        var resolvedCollection = [];
        collection.forEach(function(item, index) {
          SyncPromise2.resolve(item).then(function(value) {
            resolvedCollection[index] = value;
            counter -= 1;
            if (counter !== 0) {
              return;
            }
            resolve2(resolvedCollection);
          }).then(null, reject);
        });
      });
    };
    SyncPromise2.prototype.then = function(onfulfilled, onrejected) {
      var _this = this;
      return new SyncPromise2(function(resolve2, reject) {
        _this._attachHandler({
          done: false,
          onfulfilled: function(result) {
            if (!onfulfilled) {
              resolve2(result);
              return;
            }
            try {
              resolve2(onfulfilled(result));
              return;
            } catch (e) {
              reject(e);
              return;
            }
          },
          onrejected: function(reason) {
            if (!onrejected) {
              reject(reason);
              return;
            }
            try {
              resolve2(onrejected(reason));
              return;
            } catch (e) {
              reject(e);
              return;
            }
          }
        });
      });
    };
    SyncPromise2.prototype.catch = function(onrejected) {
      return this.then(function(val) {
        return val;
      }, onrejected);
    };
    SyncPromise2.prototype.finally = function(onfinally) {
      var _this = this;
      return new SyncPromise2(function(resolve2, reject) {
        var val;
        var isRejected;
        return _this.then(function(value) {
          isRejected = false;
          val = value;
          if (onfinally) {
            onfinally();
          }
        }, function(reason) {
          isRejected = true;
          val = reason;
          if (onfinally) {
            onfinally();
          }
        }).then(function() {
          if (isRejected) {
            reject(val);
            return;
          }
          resolve2(val);
        });
      });
    };
    SyncPromise2.prototype.toString = function() {
      return "[object SyncPromise]";
    };
    return SyncPromise2;
  }()
);

// node_modules/@sentry/utils/esm/promisebuffer.js
var PromiseBuffer = (
  /** @class */
  function() {
    function PromiseBuffer2(_limit) {
      this._limit = _limit;
      this._buffer = [];
    }
    PromiseBuffer2.prototype.isReady = function() {
      return this._limit === void 0 || this.length() < this._limit;
    };
    PromiseBuffer2.prototype.add = function(task) {
      var _this = this;
      if (!this.isReady()) {
        return SyncPromise.reject(new SentryError("Not adding Promise due to buffer limit reached."));
      }
      if (this._buffer.indexOf(task) === -1) {
        this._buffer.push(task);
      }
      task.then(function() {
        return _this.remove(task);
      }).then(null, function() {
        return _this.remove(task).then(null, function() {
        });
      });
      return task;
    };
    PromiseBuffer2.prototype.remove = function(task) {
      var removedTask = this._buffer.splice(this._buffer.indexOf(task), 1)[0];
      return removedTask;
    };
    PromiseBuffer2.prototype.length = function() {
      return this._buffer.length;
    };
    PromiseBuffer2.prototype.drain = function(timeout) {
      var _this = this;
      return new SyncPromise(function(resolve2) {
        var capturedSetTimeout = setTimeout(function() {
          if (timeout && timeout > 0) {
            resolve2(false);
          }
        }, timeout);
        SyncPromise.all(_this._buffer).then(function() {
          clearTimeout(capturedSetTimeout);
          resolve2(true);
        }).then(null, function() {
          resolve2(true);
        });
      });
    };
    return PromiseBuffer2;
  }()
);

// node_modules/@sentry/utils/esm/time.js
var dateTimestampSource = {
  nowSeconds: function() {
    return Date.now() / 1e3;
  }
};
function getBrowserPerformance() {
  var performance = getGlobalObject().performance;
  if (!performance || !performance.now) {
    return void 0;
  }
  var timeOrigin = Date.now() - performance.now();
  return {
    now: function() {
      return performance.now();
    },
    timeOrigin
  };
}
function getNodePerformance() {
  try {
    var perfHooks = dynamicRequire(module, "perf_hooks");
    return perfHooks.performance;
  } catch (_) {
    return void 0;
  }
}
var platformPerformance = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
var timestampSource = platformPerformance === void 0 ? dateTimestampSource : {
  nowSeconds: function() {
    return (platformPerformance.timeOrigin + platformPerformance.now()) / 1e3;
  }
};
var dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
var timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
var timestampWithMs = timestampInSeconds;
var _browserPerformanceTimeOriginMode;
var browserPerformanceTimeOrigin = function() {
  var performance = getGlobalObject().performance;
  if (!performance) {
    _browserPerformanceTimeOriginMode = "none";
    return void 0;
  }
  var threshold = 3600 * 1e3;
  var timeOriginIsReliable = performance.timeOrigin && Math.abs(performance.timeOrigin + performance.now() - Date.now()) < threshold;
  if (timeOriginIsReliable) {
    _browserPerformanceTimeOriginMode = "timeOrigin";
    return performance.timeOrigin;
  }
  var navigationStart = performance.timing && performance.timing.navigationStart;
  var hasNavigationStart = typeof navigationStart === "number";
  var navigationStartIsReliable = hasNavigationStart && Math.abs(navigationStart + performance.now() - Date.now()) < threshold;
  if (navigationStartIsReliable) {
    _browserPerformanceTimeOriginMode = "navigationStart";
    return navigationStart;
  }
  _browserPerformanceTimeOriginMode = "dateNow";
  return Date.now();
}();

// node_modules/@sentry/types/esm/severity.js
var Severity;
(function(Severity2) {
  Severity2["Fatal"] = "fatal";
  Severity2["Error"] = "error";
  Severity2["Warning"] = "warning";
  Severity2["Log"] = "log";
  Severity2["Info"] = "info";
  Severity2["Debug"] = "debug";
  Severity2["Critical"] = "critical";
})(Severity || (Severity = {}));
(function(Severity2) {
  function fromString(level) {
    switch (level) {
      case "debug":
        return Severity2.Debug;
      case "info":
        return Severity2.Info;
      case "warn":
      case "warning":
        return Severity2.Warning;
      case "error":
        return Severity2.Error;
      case "fatal":
        return Severity2.Fatal;
      case "critical":
        return Severity2.Critical;
      case "log":
      default:
        return Severity2.Log;
    }
  }
  Severity2.fromString = fromString;
})(Severity || (Severity = {}));

// node_modules/@sentry/types/esm/status.js
var Status;
(function(Status2) {
  Status2["Unknown"] = "unknown";
  Status2["Skipped"] = "skipped";
  Status2["Success"] = "success";
  Status2["RateLimit"] = "rate_limit";
  Status2["Invalid"] = "invalid";
  Status2["Failed"] = "failed";
})(Status || (Status = {}));
(function(Status2) {
  function fromHttpCode(code) {
    if (code >= 200 && code < 300) {
      return Status2.Success;
    }
    if (code === 429) {
      return Status2.RateLimit;
    }
    if (code >= 400 && code < 500) {
      return Status2.Invalid;
    }
    if (code >= 500) {
      return Status2.Failed;
    }
    return Status2.Unknown;
  }
  Status2.fromHttpCode = fromHttpCode;
})(Status || (Status = {}));

// node_modules/@sentry/types/esm/loglevel.js
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["None"] = 0] = "None";
  LogLevel2[LogLevel2["Error"] = 1] = "Error";
  LogLevel2[LogLevel2["Debug"] = 2] = "Debug";
  LogLevel2[LogLevel2["Verbose"] = 3] = "Verbose";
})(LogLevel || (LogLevel = {}));

// node_modules/@sentry/types/esm/session.js
var SessionStatus;
(function(SessionStatus2) {
  SessionStatus2["Ok"] = "ok";
  SessionStatus2["Exited"] = "exited";
  SessionStatus2["Crashed"] = "crashed";
  SessionStatus2["Abnormal"] = "abnormal";
})(SessionStatus || (SessionStatus = {}));

// node_modules/@sentry/types/esm/transaction.js
var TransactionSamplingMethod;
(function(TransactionSamplingMethod2) {
  TransactionSamplingMethod2["Explicit"] = "explicitly_set";
  TransactionSamplingMethod2["Sampler"] = "client_sampler";
  TransactionSamplingMethod2["Rate"] = "client_rate";
  TransactionSamplingMethod2["Inheritance"] = "inheritance";
})(TransactionSamplingMethod || (TransactionSamplingMethod = {}));

export {
  isError,
  isErrorEvent,
  isDOMError,
  isDOMException,
  isString,
  isPrimitive,
  isPlainObject,
  isEvent,
  isThenable,
  isInstanceOf,
  htmlTreeAsString,
  SentryError,
  Dsn,
  isNodeEnv,
  truncate,
  safeJoin,
  isMatchingPattern,
  getGlobalObject,
  uuid4,
  parseUrl,
  getEventDescription,
  consoleSandbox,
  addExceptionTypeValue,
  addExceptionMechanism,
  getLocationHref,
  parseRetryAfterHeader,
  logger,
  getFunctionName,
  fill,
  urlEncode,
  normalizeToSize,
  normalize,
  extractExceptionKeysForMessage,
  dropUndefinedKeys,
  supportsFetch,
  isNativeFetch,
  supportsReportingObserver,
  supportsReferrerPolicy,
  addInstrumentationHandler,
  relative,
  basename,
  SyncPromise,
  PromiseBuffer,
  dateTimestampInSeconds,
  timestampWithMs,
  SessionStatus,
  Severity,
  Status
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=chunk-HEVF6ZVB.js.map
