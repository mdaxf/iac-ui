{
  "version": 3,
  "sources": ["../../jotai/esm/index.mjs", "../../jotai/esm/vanilla.mjs"],
  "sourcesContent": ["import { createContext, useState, useEffect, useRef, createElement, useContext, useReducer, useDebugValue, useCallback } from 'react';\nimport { atom as atom$1 } from 'jotai/vanilla';\n\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = (suspensePromise) => {\n  var _a;\n  const { b: basePromise, c: cancelPromise } = suspensePromise[SUSPENSE_PROMISE];\n  if (cancelPromise) {\n    cancelPromise();\n    (_a = promiseAbortMap.get(basePromise)) == null ? void 0 : _a();\n  }\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (basePromise, promise) => {\n  const suspensePromiseExtra = {\n    b: basePromise,\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise((resolve) => {\n    suspensePromiseExtra.c = () => {\n      suspensePromiseExtra.c = null;\n      resolve();\n    };\n    promise.finally(suspensePromiseExtra.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;\n  return suspensePromise;\n};\nconst copySuspensePromise = (suspensePromise) => createSuspensePromise(\n  suspensePromise[SUSPENSE_PROMISE].b,\n  suspensePromise[SUSPENSE_PROMISE].o\n);\nconst promiseAbortMap = /* @__PURE__ */ new WeakMap();\nconst registerPromiseAbort = (basePromise, abort) => {\n  promiseAbortMap.set(basePromise, abort);\n};\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = (initialValues) => {\n  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        y: true,\n        // not invalidated\n        d: /* @__PURE__ */ new Map()\n      };\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\n            \"Found initial value for derived atom which can cause unexpected behavior\",\n            atom\n          );\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */ new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = (atom) => {\n    const versionSet = /* @__PURE__ */ new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();\n  const getVersionedAtomStateMap = (version) => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */ new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState && \"p\" in atomState && isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          atomState = void 0;\n        }\n        if (atomState) {\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    dependencies.forEach((atom) => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = !(atomState == null ? void 0 : atomState.y);\n    if (!atomState || !(\"v\" in atomState) || // new value, or\n    !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      // set read error\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n        if (!atomState.y) {\n          return { ...atomState, y: true };\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(\n        promiseOrValue,\n        promiseOrValue.then((value) => {\n          setAtomValue(version, atom, value, dependencies, suspensePromise);\n        }).catch((e) => {\n          if (e instanceof Promise) {\n            if (isSuspensePromise(e)) {\n              return e.then(() => {\n                readAtomState(version, atom, true);\n              });\n            }\n            return e;\n          }\n          setAtomReadError(version, atom, e, dependencies, suspensePromise);\n        })\n      );\n      return setAtomSuspensePromise(\n        version,\n        atom,\n        suspensePromise,\n        dependencies\n      );\n    }\n    return setAtomValue(\n      version,\n      atom,\n      promiseOrValue,\n      dependencies\n    );\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = {\n        ...atomState,\n        // copy everything\n        y: false\n        // invalidated\n      };\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.y && // not invalidated\n        \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && !aState.y) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(([a, r]) => {\n          const aState = getAtomState(version, a);\n          return aState && !(\"p\" in aState) && // has no suspense promise\n          aState.r === r;\n        })) {\n          if (!atomState.y) {\n            return { ...atomState, y: true };\n          }\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */ new Set();\n    try {\n      const promiseOrValue = atom.read((a) => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);\n        return setAtomSuspensePromise(\n          version,\n          atom,\n          suspensePromise,\n          dependencies\n        );\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (version, addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (version, deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(() => {\n            const s = getAtomState(version, a);\n            if (s && \"p\" in s && s.p === aState.p) {\n              return new Promise((resolve) => setTimeout(resolve)).then(\n                () => writeGetter(a, options)\n              );\n            }\n            return writeGetter(a, options);\n          });\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\n            \"Reading pending atom state in write operation. We throw a promise for now.\",\n            a\n          );\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\n          \"[Bug] no value found while reading atom in write operation. This is probably a bug.\",\n          a\n        );\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach((cancelledVersion) => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom) => !!atom.write;\n  const mountAtom = (version, atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = (update) => writeAtom(atom, update, version);\n      const onUnmount = atom.onMount(setAtom);\n      version = void 0;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (version, atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (version, atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  const flushPending = (version) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && // invalidated\n        (atomState == null ? void 0 : atomState.y)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const commitVersionedAtomStateMap = (version) => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback, version) => {\n    const mounted = addAtom(version, atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = (initialValues) => {\n  const store = createStore(initialValues);\n  const get = (atom) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = (atom) => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return { s: store };\n};\nconst ScopeContextMap = /* @__PURE__ */ new Map();\nconst getScopeContext = (scope) => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nconst Provider = ({\n  children,\n  initialValues,\n  scope,\n  unstable_createStore,\n  unstable_enableVersionedWrite\n}) => {\n  const [version, setVersion] = useState({});\n  useEffect(() => {\n    const scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    const scopeContainer = createScopeContainer(\n      initialValues,\n      unstable_createStore\n    );\n    if (unstable_enableVersionedWrite) {\n      let retrying = 0;\n      scopeContainer.w = (write) => {\n        setVersion((parentVersion) => {\n          const nextVersion = retrying ? parentVersion : { p: parentVersion };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = (fn) => {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(\n    ScopeContainerContext.Provider,\n    {\n      value: scopeContainerRef.current\n    },\n    children\n  );\n};\n\nfunction atom(read, write) {\n  return atom$1(read, write);\n}\n\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const { s: store, v: versionFromProvider } = scopeContainer;\n  const getAtomValue = (version2) => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !atomState.y) {\n      throw new Error(\"should not be invalidated\");\n    }\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  };\n  const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] = useReducer(\n    (prev, nextVersion) => {\n      const nextValue = getAtomValue(nextVersion);\n      if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n        return prev;\n      }\n      return [nextVersion, nextValue, atom];\n    },\n    versionFromProvider,\n    (initialVersion) => {\n      const initialValue = getAtomValue(initialVersion);\n      return [initialVersion, initialValue, atom];\n    }\n  );\n  let value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  useEffect(() => {\n    const { v: versionFromProvider2 } = scopeContainer;\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom, versionFromProvider2);\n    }\n    const unsubscribe = store[SUBSCRIBE_ATOM](\n      atom,\n      rerenderIfChanged,\n      versionFromProvider2\n    );\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store, w: versionedWrite } = useContext(ScopeContext);\n  const setAtom = useCallback(\n    (update) => {\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      const write = (version) => store[WRITE_ATOM](atom, update, version);\n      return versionedWrite ? versionedWrite(write) : write();\n    },\n    [store, versionedWrite, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\n      \"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\"\n    );\n    scope = atom.scope;\n  }\n  return [\n    useAtomValue(atom, scope),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, scope)\n  ];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, registerPromiseAbort as SECRET_INTERNAL_registerPromiseAbort, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };\n", "let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, arg) => set(\n      config,\n      typeof arg === \"function\" ? arg(get(config)) : arg\n    );\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isEqualAtomValue = (a, b) => \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => \"v\" in a && a.v instanceof Promise;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, depSet) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    depSet.forEach((a) => {\n      const aState = a === atom ? nextAtomState : getAtomState(a);\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomError = (atom, error, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom) => {\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(\n        ([a, s]) => a === atom || getAtomState(a) === s\n      )) {\n        return atomState;\n      }\n    }\n    const depSet = /* @__PURE__ */ new Set();\n    let isSync = true;\n    const getter = (a) => {\n      depSet.add(a);\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env && import.meta.env.MODE) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const value = atom.read(getter, options);\n      if (value instanceof Promise) {\n        let continuePromise;\n        const promise = new Promise((resolve, reject) => {\n          let settled = false;\n          value.then(\n            (v) => {\n              if (!settled) {\n                resolvePromise(promise, v);\n                resolve(v);\n              }\n            },\n            (e) => {\n              if (!settled) {\n                rejectPromise(promise, e);\n                reject(e);\n              }\n            }\n          ).finally(() => {\n            if (!settled) {\n              settled = true;\n              setAtomValue(atom, promise, depSet);\n            }\n          });\n          continuePromise = (next) => {\n            if (!settled) {\n              settled = true;\n              next.then(\n                (v) => resolvePromise(promise, v),\n                (e) => rejectPromise(promise, e)\n              );\n              resolve(next);\n            }\n          };\n        });\n        promise.status = \"pending\";\n        registerCancelPromise(promise, (next) => {\n          if (next) {\n            continuePromise(next);\n          }\n          controller == null ? void 0 : controller.abort();\n        });\n        return setAtomValue(atom, promise, depSet);\n      }\n      return setAtomValue(atom, value, depSet);\n    } catch (error) {\n      return setAtomError(atom, error, depSet);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        const prevAtomState = getAtomState(dependent);\n        const nextAtomState = readAtomState(dependent);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(dependent);\n        }\n      }\n    });\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValue(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    flushPending();\n    return result;\n  };\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const onUnmount = atom.onMount((...args) => writeAtom(atom, ...args));\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          const mounted = mountedMap.get(atom);\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n          }\n        } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n    };\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change)\n      dev_subscribe_state: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, value] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValue(atom, value);\n            recomputeDependents(atom);\n          }\n        }\n        flushPending();\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n"],
  "mappings": ";;;;;;;;AAAA,mBAA8H;;;ACA9H,IAAI,WAAW;AACf,SAAS,KAAK,MAAM,OAAO;AACzB,QAAM,MAAM,OAAO,EAAE,QAAQ;AAC7B,QAAM,SAAS;AAAA,IACb,UAAU,MAAM;AAAA,EAClB;AACA,MAAI,OAAO,SAAS,YAAY;AAC9B,WAAO,OAAO;AAAA,EAChB,OAAO;AACL,WAAO,OAAO;AACd,WAAO,OAAO,CAAC,QAAQ,IAAI,MAAM;AACjC,WAAO,QAAQ,CAAC,KAAK,KAAK,QAAQ;AAAA,MAChC;AAAA,MACA,OAAO,QAAQ,aAAa,IAAI,IAAI,MAAM,CAAC,IAAI;AAAA,IACjD;AAAA,EACF;AACA,MAAI,OAAO;AACT,WAAO,QAAQ;AAAA,EACjB;AACA,SAAO;AACT;;;ADjBA,IAAM,mBAAmB,OAAO;AAChC,IAAM,oBAAoB,CAAC,YAAY,CAAC,CAAC,QAAQ,gBAAgB;AACjE,IAAM,oCAAoC,CAAC,oBAAoB,CAAC,gBAAgB,gBAAgB,EAAE;AAClG,IAAM,wBAAwB,CAAC,oBAAoB;AACjD,MAAI;AACJ,QAAM,EAAE,GAAG,aAAa,GAAG,cAAc,IAAI,gBAAgB,gBAAgB;AAC7E,MAAI,eAAe;AACjB,kBAAc;AACd,KAAC,KAAK,gBAAgB,IAAI,WAAW,MAAM,OAAO,SAAS,GAAG;AAAA,EAChE;AACF;AACA,IAAM,yBAAyB,CAAC,oBAAoB,uBAAuB;AACzE,QAAM,qBAAqB,mBAAmB,gBAAgB,EAAE;AAChE,QAAM,qBAAqB,mBAAmB,gBAAgB,EAAE;AAChE,SAAO,uBAAuB,sBAAsB,uBAAuB,sBAAsB,kBAAkB,kBAAkB,KAAK,uBAAuB,oBAAoB,kBAAkB;AACzM;AACA,IAAM,wBAAwB,CAAC,aAAa,YAAY;AACtD,QAAM,uBAAuB;AAAA,IAC3B,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,EACL;AACA,QAAM,kBAAkB,IAAI,QAAQ,CAAC,YAAY;AAC/C,yBAAqB,IAAI,MAAM;AAC7B,2BAAqB,IAAI;AACzB,cAAQ;AAAA,IACV;AACA,YAAQ,QAAQ,qBAAqB,CAAC;AAAA,EACxC,CAAC;AACD,kBAAgB,gBAAgB,IAAI;AACpC,SAAO;AACT;AACA,IAAM,sBAAsB,CAAC,oBAAoB;AAAA,EAC/C,gBAAgB,gBAAgB,EAAE;AAAA,EAClC,gBAAgB,gBAAgB,EAAE;AACpC;AACA,IAAM,kBAAkC,oBAAI,QAAQ;AACpD,IAAM,uBAAuB,CAAC,aAAa,UAAU;AACnD,kBAAgB,IAAI,aAAa,KAAK;AACxC;AAEA,IAAM,kBAAkB,CAACA,UAAS,UAAUA;AAC5C,IAAM,YAAY;AAClB,IAAM,aAAa;AACnB,IAAM,cAAc;AACpB,IAAM,iBAAiB;AACvB,IAAM,gBAAgB;AACtB,IAAM,sBAAsB;AAC5B,IAAM,wBAAwB;AAC9B,IAAM,qBAAqB;AAC3B,IAAM,kBAAkB;AACxB,IAAM,cAAc,CAAC,kBAAkB;AACrC,QAAM,wBAAwC,oBAAI,QAAQ;AAC1D,QAAM,aAA6B,oBAAI,QAAQ;AAC/C,QAAM,aAA6B,oBAAI,IAAI;AAC3C,MAAI;AACJ,MAAI;AACJ,OAAK,YAAY,OAAO,YAAY,IAAI,UAAU,cAAc;AAC9D,qBAAiC,oBAAI,IAAI;AACzC,mBAA+B,oBAAI,IAAI;AAAA,EACzC;AACA,MAAI,eAAe;AACjB,eAAW,CAACA,OAAM,KAAK,KAAK,eAAe;AACzC,YAAM,YAAY;AAAA,QAChB,GAAG;AAAA,QACH,GAAG;AAAA,QACH,GAAG;AAAA;AAAA,QAEH,GAAmB,oBAAI,IAAI;AAAA,MAC7B;AACA,WAAK,YAAY,OAAO,YAAY,IAAI,UAAU,cAAc;AAC9D,eAAO,OAAO,SAAS;AACvB,YAAI,CAAC,gBAAgBA,KAAI,GAAG;AAC1B,kBAAQ;AAAA,YACN;AAAA,YACAA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,4BAAsB,IAAIA,OAAM,SAAS;AAAA,IAC3C;AAAA,EACF;AACA,QAAM,0BAA0C,oBAAI,QAAQ;AAC5D,QAAM,4BAA4B,CAAC,SAASA,OAAM,oBAAoB;AACpE,QAAI,QAAQ,wBAAwB,IAAIA,KAAI;AAC5C,QAAI,CAAC,OAAO;AACV,cAAwB,oBAAI,IAAI;AAChC,8BAAwB,IAAIA,OAAM,KAAK;AAAA,IACzC;AACA,oBAAgB,KAAK,MAAM;AACzB,UAAI,MAAM,IAAI,OAAO,MAAM,iBAAiB;AAC1C,cAAM,OAAO,OAAO;AACpB,YAAI,CAAC,MAAM,MAAM;AACf,kCAAwB,OAAOA,KAAI;AAAA,QACrC;AAAA,MACF;AAAA,IACF,CAAC;AACD,UAAM,IAAI,SAAS,eAAe;AAAA,EACpC;AACA,QAAM,kCAAkC,CAACA,UAAS;AAChD,UAAM,aAA6B,oBAAI,IAAI;AAC3C,UAAM,QAAQ,wBAAwB,IAAIA,KAAI;AAC9C,QAAI,OAAO;AACT,8BAAwB,OAAOA,KAAI;AACnC,YAAM,QAAQ,CAAC,iBAAiB,YAAY;AAC1C,8BAAsB,eAAe;AACrC,mBAAW,IAAI,OAAO;AAAA,MACxB,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT;AACA,QAAM,2BAA2C,oBAAI,QAAQ;AAC7D,QAAM,2BAA2B,CAAC,YAAY;AAC5C,QAAI,wBAAwB,yBAAyB,IAAI,OAAO;AAChE,QAAI,CAAC,uBAAuB;AAC1B,8BAAwC,oBAAI,IAAI;AAChD,+BAAyB,IAAI,SAAS,qBAAqB;AAAA,IAC7D;AACA,WAAO;AAAA,EACT;AACA,QAAM,eAAe,CAAC,SAASA,UAAS;AACtC,QAAI,SAAS;AACX,YAAM,wBAAwB,yBAAyB,OAAO;AAC9D,UAAI,YAAY,sBAAsB,IAAIA,KAAI;AAC9C,UAAI,CAAC,WAAW;AACd,oBAAY,aAAa,QAAQ,GAAGA,KAAI;AACxC,YAAI,aAAa,OAAO,aAAa,kCAAkC,UAAU,CAAC,GAAG;AACnF,sBAAY;AAAA,QACd;AACA,YAAI,WAAW;AACb,gCAAsB,IAAIA,OAAM,SAAS;AAAA,QAC3C;AAAA,MACF;AACA,aAAO;AAAA,IACT;AACA,WAAO,sBAAsB,IAAIA,KAAI;AAAA,EACvC;AACA,QAAM,eAAe,CAAC,SAASA,OAAM,cAAc;AACjD,SAAK,YAAY,OAAO,YAAY,IAAI,UAAU,cAAc;AAC9D,aAAO,OAAO,SAAS;AAAA,IACzB;AACA,QAAI,SAAS;AACX,YAAM,wBAAwB,yBAAyB,OAAO;AAC9D,4BAAsB,IAAIA,OAAM,SAAS;AAAA,IAC3C,OAAO;AACL,YAAM,gBAAgB,sBAAsB,IAAIA,KAAI;AACpD,4BAAsB,IAAIA,OAAM,SAAS;AACzC,UAAI,CAAC,WAAW,IAAIA,KAAI,GAAG;AACzB,mBAAW,IAAIA,OAAM,aAAa;AAAA,MACpC;AAAA,IACF;AAAA,EACF;AACA,QAAM,yBAAyB,CAAC,SAAS,uBAAuC,oBAAI,IAAI,GAAG,iBAAiB;AAC1G,QAAI,CAAC,cAAc;AACjB,aAAO;AAAA,IACT;AACA,UAAM,mBAAmC,oBAAI,IAAI;AACjD,QAAI,UAAU;AACd,iBAAa,QAAQ,CAACA,UAAS;AAC7B,UAAI;AACJ,YAAM,aAAa,KAAK,aAAa,SAASA,KAAI,MAAM,OAAO,SAAS,GAAG,MAAM;AACjF,uBAAiB,IAAIA,OAAM,QAAQ;AACnC,UAAI,qBAAqB,IAAIA,KAAI,MAAM,UAAU;AAC/C,kBAAU;AAAA,MACZ;AAAA,IACF,CAAC;AACD,QAAI,qBAAqB,SAAS,iBAAiB,QAAQ,CAAC,SAAS;AACnE,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AACA,QAAM,eAAe,CAAC,SAASA,OAAM,OAAO,cAAc,oBAAoB;AAC5E,UAAM,YAAY,aAAa,SAASA,KAAI;AAC5C,QAAI,WAAW;AACb,UAAI,oBAAoB,EAAE,OAAO,cAAc,CAAC,uBAAuB,UAAU,GAAG,eAAe,IAAI;AACrG,eAAO;AAAA,MACT;AACA,UAAI,OAAO,WAAW;AACpB,8BAAsB,UAAU,CAAC;AAAA,MACnC;AAAA,IACF;AACA,UAAM,gBAAgB;AAAA,MACpB,GAAG;AAAA,MACH,IAAI,aAAa,OAAO,SAAS,UAAU,MAAM;AAAA,MACjD,GAAG;AAAA;AAAA,MAEH,GAAG,uBAAuB,SAAS,aAAa,OAAO,SAAS,UAAU,GAAG,YAAY;AAAA,IAC3F;AACA,QAAI,UAAU,EAAE,aAAa,OAAO,SAAS,UAAU;AACvD,QAAI,CAAC,aAAa,EAAE,OAAO;AAAA,IAC3B,CAAC,OAAO,GAAG,UAAU,GAAG,KAAK,GAAG;AAC9B,gBAAU;AACV,QAAE,cAAc;AAChB,UAAI,cAAc,EAAE,IAAIA,KAAI,GAAG;AAC7B,sBAAc,IAAI,IAAI,IAAI,cAAc,CAAC,EAAE,IAAIA,OAAM,cAAc,CAAC;AAAA,MACtE;AAAA,IACF,WAAW,cAAc,MAAM,UAAU,MAAM,cAAc,EAAE,SAAS,UAAU,EAAE,QAAQ,CAAC,MAAM,KAAK,cAAc,EAAE,KAAK,CAAC,EAAE,MAAM,CAAC,MAAM,UAAU,EAAE,IAAI,CAAC,CAAC,IAAI;AACjK,gBAAU;AACV,cAAQ,QAAQ,EAAE,KAAK,MAAM;AAC3B,qBAAa,OAAO;AAAA,MACtB,CAAC;AAAA,IACH;AACA,QAAI,aAAa,CAAC,SAAS;AACzB,aAAO;AAAA,IACT;AACA,iBAAa,SAASA,OAAM,aAAa;AACzC,WAAO;AAAA,EACT;AACA,QAAM,mBAAmB,CAAC,SAASA,OAAM,OAAO,cAAc,oBAAoB;AAChF,UAAM,YAAY,aAAa,SAASA,KAAI;AAC5C,QAAI,WAAW;AACb,UAAI,oBAAoB,EAAE,OAAO,cAAc,CAAC,uBAAuB,UAAU,GAAG,eAAe,IAAI;AACrG,eAAO;AAAA,MACT;AACA,UAAI,OAAO,WAAW;AACpB,8BAAsB,UAAU,CAAC;AAAA,MACnC;AAAA,IACF;AACA,UAAM,gBAAgB;AAAA,MACpB,GAAG;AAAA;AAAA,MAEH,KAAK,aAAa,OAAO,SAAS,UAAU,MAAM,KAAK;AAAA,MACvD,GAAG;AAAA;AAAA,MAEH,GAAG,uBAAuB,SAAS,aAAa,OAAO,SAAS,UAAU,GAAG,YAAY;AAAA,IAC3F;AACA,iBAAa,SAASA,OAAM,aAAa;AACzC,WAAO;AAAA,EACT;AACA,QAAM,yBAAyB,CAAC,SAASA,OAAM,iBAAiB,iBAAiB;AAC/E,UAAM,YAAY,aAAa,SAASA,KAAI;AAC5C,QAAI,aAAa,OAAO,WAAW;AACjC,UAAI,uBAAuB,UAAU,GAAG,eAAe,KAAK,CAAC,kCAAkC,UAAU,CAAC,GAAG;AAC3G,YAAI,CAAC,UAAU,GAAG;AAChB,iBAAO,EAAE,GAAG,WAAW,GAAG,KAAK;AAAA,QACjC;AACA,eAAO;AAAA,MACT;AACA,4BAAsB,UAAU,CAAC;AAAA,IACnC;AACA,8BAA0B,SAASA,OAAM,eAAe;AACxD,UAAM,gBAAgB;AAAA,MACpB,GAAG;AAAA,MACH,KAAK,aAAa,OAAO,SAAS,UAAU,MAAM,KAAK;AAAA,MACvD,GAAG;AAAA;AAAA,MAEH,GAAG,uBAAuB,SAAS,aAAa,OAAO,SAAS,UAAU,GAAG,YAAY;AAAA,IAC3F;AACA,iBAAa,SAASA,OAAM,aAAa;AACzC,WAAO;AAAA,EACT;AACA,QAAM,wBAAwB,CAAC,SAASA,OAAM,gBAAgB,iBAAiB;AAC7E,QAAI,0BAA0B,SAAS;AACrC,YAAM,kBAAkB;AAAA,QACtB;AAAA,QACA,eAAe,KAAK,CAAC,UAAU;AAC7B,uBAAa,SAASA,OAAM,OAAO,cAAc,eAAe;AAAA,QAClE,CAAC,EAAE,MAAM,CAAC,MAAM;AACd,cAAI,aAAa,SAAS;AACxB,gBAAI,kBAAkB,CAAC,GAAG;AACxB,qBAAO,EAAE,KAAK,MAAM;AAClB,8BAAc,SAASA,OAAM,IAAI;AAAA,cACnC,CAAC;AAAA,YACH;AACA,mBAAO;AAAA,UACT;AACA,2BAAiB,SAASA,OAAM,GAAG,cAAc,eAAe;AAAA,QAClE,CAAC;AAAA,MACH;AACA,aAAO;AAAA,QACL;AAAA,QACAA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,MACL;AAAA,MACAA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACA,QAAM,qBAAqB,CAAC,SAASA,UAAS;AAC5C,UAAM,YAAY,aAAa,SAASA,KAAI;AAC5C,QAAI,WAAW;AACb,YAAM,gBAAgB;AAAA,QACpB,GAAG;AAAA;AAAA,QAEH,GAAG;AAAA;AAAA,MAEL;AACA,mBAAa,SAASA,OAAM,aAAa;AAAA,IAC3C,YAAY,YAAY,OAAO,YAAY,IAAI,UAAU,cAAc;AACrE,cAAQ,KAAK,gDAAgDA,KAAI;AAAA,IACnE;AAAA,EACF;AACA,QAAM,gBAAgB,CAAC,SAASA,OAAM,UAAU;AAC9C,QAAI,CAAC,OAAO;AACV,YAAM,YAAY,aAAa,SAASA,KAAI;AAC5C,UAAI,WAAW;AACb,YAAI,UAAU;AAAA,QACd,OAAO,aAAa,CAAC,kCAAkC,UAAU,CAAC,GAAG;AACnE,iBAAO;AAAA,QACT;AACA,kBAAU,EAAE,QAAQ,CAAC,GAAG,MAAM;AAC5B,cAAI,MAAMA,OAAM;AACd,gBAAI,CAAC,WAAW,IAAI,CAAC,GAAG;AACtB,4BAAc,SAAS,CAAC;AAAA,YAC1B,OAAO;AACL,oBAAM,SAAS,aAAa,SAAS,CAAC;AACtC,kBAAI,UAAU,CAAC,OAAO,GAAG;AACvB,8BAAc,SAAS,CAAC;AAAA,cAC1B;AAAA,YACF;AAAA,UACF;AAAA,QACF,CAAC;AACD,YAAI,MAAM,KAAK,UAAU,CAAC,EAAE,MAAM,CAAC,CAAC,GAAG,CAAC,MAAM;AAC5C,gBAAM,SAAS,aAAa,SAAS,CAAC;AACtC,iBAAO,UAAU,EAAE,OAAO;AAAA,UAC1B,OAAO,MAAM;AAAA,QACf,CAAC,GAAG;AACF,cAAI,CAAC,UAAU,GAAG;AAChB,mBAAO,EAAE,GAAG,WAAW,GAAG,KAAK;AAAA,UACjC;AACA,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AACA,UAAM,eAA+B,oBAAI,IAAI;AAC7C,QAAI;AACF,YAAM,iBAAiBA,MAAK,KAAK,CAAC,MAAM;AACtC,qBAAa,IAAI,CAAC;AAClB,cAAM,SAAS,MAAMA,QAAO,aAAa,SAAS,CAAC,IAAI,cAAc,SAAS,CAAC;AAC/E,YAAI,QAAQ;AACV,cAAI,OAAO,QAAQ;AACjB,kBAAM,OAAO;AAAA,UACf;AACA,cAAI,OAAO,QAAQ;AACjB,kBAAM,OAAO;AAAA,UACf;AACA,iBAAO,OAAO;AAAA,QAChB;AACA,YAAI,gBAAgB,CAAC,GAAG;AACtB,iBAAO,EAAE;AAAA,QACX;AACA,cAAM,IAAI,MAAM,cAAc;AAAA,MAChC,CAAC;AACD,aAAO,sBAAsB,SAASA,OAAM,gBAAgB,YAAY;AAAA,IAC1E,SAAS,gBAAgB;AACvB,UAAI,0BAA0B,SAAS;AACrC,cAAM,kBAAkB,kBAAkB,cAAc,KAAK,kCAAkC,cAAc,IAAI,oBAAoB,cAAc,IAAI,sBAAsB,gBAAgB,cAAc;AAC3M,eAAO;AAAA,UACL;AAAA,UACAA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AACA,aAAO,iBAAiB,SAASA,OAAM,gBAAgB,YAAY;AAAA,IACrE;AAAA,EACF;AACA,QAAM,WAAW,CAAC,aAAa,YAAY;AACzC,UAAM,YAAY,cAAc,SAAS,WAAW;AACpD,WAAO;AAAA,EACT;AACA,QAAM,UAAU,CAAC,SAAS,eAAe;AACvC,QAAI,UAAU,WAAW,IAAI,UAAU;AACvC,QAAI,CAAC,SAAS;AACZ,gBAAU,UAAU,SAAS,UAAU;AAAA,IACzC;AACA,WAAO;AAAA,EACT;AACA,QAAM,iBAAiB,CAACA,OAAM,YAAY,CAAC,QAAQ,EAAE,SAAS,CAAC,QAAQ,EAAE,QAAQ,QAAQ,EAAE,SAAS,KAAK,QAAQ,EAAE,IAAIA,KAAI;AAC3H,QAAM,UAAU,CAAC,SAAS,iBAAiB;AACzC,UAAM,UAAU,WAAW,IAAI,YAAY;AAC3C,QAAI,WAAW,eAAe,cAAc,OAAO,GAAG;AACpD,kBAAY,SAAS,YAAY;AAAA,IACnC;AAAA,EACF;AACA,QAAM,uBAAuB,CAAC,SAASA,UAAS;AAC9C,UAAM,UAAU,WAAW,IAAIA,KAAI;AACnC,eAAW,OAAO,SAAS,QAAQ,EAAE,QAAQ,CAAC,cAAc;AAC1D,UAAI,cAAcA,OAAM;AACtB,2BAAmB,SAAS,SAAS;AACrC,6BAAqB,SAAS,SAAS;AAAA,MACzC;AAAA,IACF,CAAC;AAAA,EACH;AACA,QAAM,iBAAiB,CAAC,SAASA,OAAM,WAAW;AAChD,QAAI,SAAS;AACb,UAAM,cAAc,CAAC,GAAG,YAAY;AAClC,YAAM,SAAS,cAAc,SAAS,CAAC;AACvC,UAAI,OAAO,QAAQ;AACjB,cAAM,OAAO;AAAA,MACf;AACA,UAAI,OAAO,QAAQ;AACjB,YAAI,WAAW,OAAO,SAAS,QAAQ,kBAAkB;AACvD,iBAAO,OAAO,EAAE,KAAK,MAAM;AACzB,kBAAM,IAAI,aAAa,SAAS,CAAC;AACjC,gBAAI,KAAK,OAAO,KAAK,EAAE,MAAM,OAAO,GAAG;AACrC,qBAAO,IAAI,QAAQ,CAAC,YAAY,WAAW,OAAO,CAAC,EAAE;AAAA,gBACnD,MAAM,YAAY,GAAG,OAAO;AAAA,cAC9B;AAAA,YACF;AACA,mBAAO,YAAY,GAAG,OAAO;AAAA,UAC/B,CAAC;AAAA,QACH;AACA,aAAK,YAAY,OAAO,YAAY,IAAI,UAAU,cAAc;AAC9D,kBAAQ;AAAA,YACN;AAAA,YACA;AAAA,UACF;AAAA,QACF;AACA,cAAM,OAAO;AAAA,MACf;AACA,UAAI,OAAO,QAAQ;AACjB,eAAO,OAAO;AAAA,MAChB;AACA,WAAK,YAAY,OAAO,YAAY,IAAI,UAAU,cAAc;AAC9D,gBAAQ;AAAA,UACN;AAAA,UACA;AAAA,QACF;AAAA,MACF;AACA,YAAM,IAAI,MAAM,gBAAgB;AAAA,IAClC;AACA,UAAM,SAAS,CAAC,GAAG,MAAM;AACvB,UAAI;AACJ,UAAI,MAAMA,OAAM;AACd,YAAI,CAAC,gBAAgB,CAAC,GAAG;AACvB,gBAAM,IAAI,MAAM,mBAAmB;AAAA,QACrC;AACA,cAAM,aAAa,gCAAgC,CAAC;AACpD,mBAAW,QAAQ,CAAC,qBAAqB;AACvC,cAAI,qBAAqB,SAAS;AAChC,kCAAsB,kBAAkB,GAAG,CAAC;AAAA,UAC9C;AAAA,QACF,CAAC;AACD,cAAM,gBAAgB,aAAa,SAAS,CAAC;AAC7C,cAAM,gBAAgB,sBAAsB,SAAS,GAAG,CAAC;AACzD,YAAI,kBAAkB,eAAe;AACnC,+BAAqB,SAAS,CAAC;AAAA,QACjC;AAAA,MACF,OAAO;AACL,yBAAiB,eAAe,SAAS,GAAG,CAAC;AAAA,MAC/C;AACA,UAAI,CAAC,QAAQ;AACX,qBAAa,OAAO;AAAA,MACtB;AACA,aAAO;AAAA,IACT;AACA,UAAM,gBAAgBA,MAAK,MAAM,aAAa,QAAQ,MAAM;AAC5D,aAAS;AACT,WAAO;AAAA,EACT;AACA,QAAM,YAAY,CAAC,aAAa,QAAQ,YAAY;AAClD,UAAM,gBAAgB,eAAe,SAAS,aAAa,MAAM;AACjE,iBAAa,OAAO;AACpB,WAAO;AAAA,EACT;AACA,QAAM,yBAAyB,CAACA,UAAS,CAAC,CAACA,MAAK;AAChD,QAAM,YAAY,CAAC,SAASA,OAAM,qBAAqB;AACrD,UAAM,UAAU;AAAA,MACd,GAAG,IAAI,IAAI,oBAAoB,CAAC,gBAAgB,CAAC;AAAA,MACjD,GAAmB,oBAAI,IAAI;AAAA,IAC7B;AACA,eAAW,IAAIA,OAAM,OAAO;AAC5B,SAAK,YAAY,OAAO,YAAY,IAAI,UAAU,cAAc;AAC9D,mBAAa,IAAIA,KAAI;AAAA,IACvB;AACA,UAAM,YAAY,cAAc,QAAQA,KAAI;AAC5C,cAAU,EAAE,QAAQ,CAAC,GAAG,MAAM;AAC5B,YAAM,WAAW,WAAW,IAAI,CAAC;AACjC,UAAI,UAAU;AACZ,iBAAS,EAAE,IAAIA,KAAI;AAAA,MACrB,OAAO;AACL,YAAI,MAAMA,OAAM;AACd,oBAAU,SAAS,GAAGA,KAAI;AAAA,QAC5B;AAAA,MACF;AAAA,IACF,CAAC;AACD,QAAI,uBAAuBA,KAAI,KAAKA,MAAK,SAAS;AAChD,YAAM,UAAU,CAAC,WAAW,UAAUA,OAAM,QAAQ,OAAO;AAC3D,YAAM,YAAYA,MAAK,QAAQ,OAAO;AACtC,gBAAU;AACV,UAAI,WAAW;AACb,gBAAQ,IAAI;AAAA,MACd;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACA,QAAM,cAAc,CAAC,SAASA,UAAS;AACrC,QAAI;AACJ,UAAM,aAAa,KAAK,WAAW,IAAIA,KAAI,MAAM,OAAO,SAAS,GAAG;AACpE,QAAI,WAAW;AACb,gBAAU;AAAA,IACZ;AACA,eAAW,OAAOA,KAAI;AACtB,SAAK,YAAY,OAAO,YAAY,IAAI,UAAU,cAAc;AAC9D,mBAAa,OAAOA,KAAI;AAAA,IAC1B;AACA,UAAM,YAAY,aAAa,SAASA,KAAI;AAC5C,QAAI,WAAW;AACb,UAAI,OAAO,WAAW;AACpB,8BAAsB,UAAU,CAAC;AAAA,MACnC;AACA,gBAAU,EAAE,QAAQ,CAAC,GAAG,MAAM;AAC5B,YAAI,MAAMA,OAAM;AACd,gBAAM,UAAU,WAAW,IAAI,CAAC;AAChC,cAAI,SAAS;AACX,oBAAQ,EAAE,OAAOA,KAAI;AACrB,gBAAI,eAAe,GAAG,OAAO,GAAG;AAC9B,0BAAY,SAAS,CAAC;AAAA,YACxB;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH,YAAY,YAAY,OAAO,YAAY,IAAI,UAAU,cAAc;AACrE,cAAQ,KAAK,8CAA8CA,KAAI;AAAA,IACjE;AAAA,EACF;AACA,QAAM,oBAAoB,CAAC,SAASA,OAAM,WAAW,yBAAyB;AAC5E,UAAM,eAAe,IAAI,IAAI,UAAU,EAAE,KAAK,CAAC;AAC/C,4BAAwB,OAAO,SAAS,qBAAqB,QAAQ,CAAC,GAAG,MAAM;AAC7E,UAAI,aAAa,IAAI,CAAC,GAAG;AACvB,qBAAa,OAAO,CAAC;AACrB;AAAA,MACF;AACA,YAAM,UAAU,WAAW,IAAI,CAAC;AAChC,UAAI,SAAS;AACX,gBAAQ,EAAE,OAAOA,KAAI;AACrB,YAAI,eAAe,GAAG,OAAO,GAAG;AAC9B,sBAAY,SAAS,CAAC;AAAA,QACxB;AAAA,MACF;AAAA,IACF,CAAC;AACD,iBAAa,QAAQ,CAAC,MAAM;AAC1B,YAAM,UAAU,WAAW,IAAI,CAAC;AAChC,UAAI,SAAS;AACX,gBAAQ,EAAE,IAAIA,KAAI;AAAA,MACpB,WAAW,WAAW,IAAIA,KAAI,GAAG;AAC/B,kBAAU,SAAS,GAAGA,KAAI;AAAA,MAC5B;AAAA,IACF,CAAC;AAAA,EACH;AACA,QAAM,eAAe,CAAC,YAAY;AAChC,QAAI,SAAS;AACX,YAAM,wBAAwB,yBAAyB,OAAO;AAC9D,4BAAsB,QAAQ,CAAC,WAAWA,UAAS;AACjD,cAAM,qBAAqB,sBAAsB,IAAIA,KAAI;AACzD,YAAI,cAAc,oBAAoB;AACpC,gBAAM,UAAU,WAAW,IAAIA,KAAI;AACnC,qBAAW,OAAO,SAAS,QAAQ,EAAE,QAAQ,CAAC,aAAa,SAAS,OAAO,CAAC;AAAA,QAC9E;AAAA,MACF,CAAC;AACD;AAAA,IACF;AACA,WAAO,WAAW,MAAM;AACtB,YAAM,UAAU,MAAM,KAAK,UAAU;AACrC,iBAAW,MAAM;AACjB,cAAQ,QAAQ,CAAC,CAACA,OAAM,aAAa,MAAM;AACzC,cAAM,YAAY,aAAa,QAAQA,KAAI;AAC3C,YAAI,aAAa,UAAU,OAAO,iBAAiB,OAAO,SAAS,cAAc,IAAI;AACnF,4BAAkB,QAAQA,OAAM,WAAW,iBAAiB,OAAO,SAAS,cAAc,CAAC;AAAA,QAC7F;AACA,YAAI,iBAAiB,CAAC,cAAc;AAAA,SACnC,aAAa,OAAO,SAAS,UAAU,IAAI;AAC1C;AAAA,QACF;AACA,cAAM,UAAU,WAAW,IAAIA,KAAI;AACnC,mBAAW,OAAO,SAAS,QAAQ,EAAE,QAAQ,CAAC,aAAa,SAAS,CAAC;AAAA,MACvE,CAAC;AAAA,IACH;AACA,SAAK,YAAY,OAAO,YAAY,IAAI,UAAU,cAAc;AAC9D,qBAAe,QAAQ,CAAC,MAAM,EAAE,CAAC;AAAA,IACnC;AAAA,EACF;AACA,QAAM,8BAA8B,CAAC,YAAY;AAC/C,UAAM,wBAAwB,yBAAyB,OAAO;AAC9D,0BAAsB,QAAQ,CAAC,WAAWA,UAAS;AACjD,YAAM,gBAAgB,sBAAsB,IAAIA,KAAI;AACpD,UAAI,CAAC,iBAAiB,UAAU,IAAI,cAAc,KAAK,UAAU,MAAM,cAAc,KAAK,UAAU,MAAM,cAAc,KAAK,UAAU,MAAM,cAAc,GAAG;AAC5J,8BAAsB,IAAIA,OAAM,SAAS;AACzC,YAAI,UAAU,OAAO,iBAAiB,OAAO,SAAS,cAAc,IAAI;AACtE,4BAAkB,SAASA,OAAM,WAAW,iBAAiB,OAAO,SAAS,cAAc,CAAC;AAAA,QAC9F;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACA,QAAM,aAAa,CAAC,OAAO,YAAY;AACrC,QAAI,SAAS;AACX,kCAA4B,OAAO;AAAA,IACrC;AACA,iBAAa,MAAM;AAAA,EACrB;AACA,QAAM,gBAAgB,CAACA,OAAM,UAAU,YAAY;AACjD,UAAM,UAAU,QAAQ,SAASA,KAAI;AACrC,UAAM,YAAY,QAAQ;AAC1B,cAAU,IAAI,QAAQ;AACtB,WAAO,MAAM;AACX,gBAAU,OAAO,QAAQ;AACzB,cAAQ,SAASA,KAAI;AAAA,IACvB;AAAA,EACF;AACA,QAAM,eAAe,CAAC,QAAQ,YAAY;AACxC,eAAW,CAACA,OAAM,KAAK,KAAK,QAAQ;AAClC,UAAI,gBAAgBA,KAAI,GAAG;AACzB,8BAAsB,SAASA,OAAM,KAAK;AAC1C,6BAAqB,SAASA,KAAI;AAAA,MACpC;AAAA,IACF;AACA,iBAAa,OAAO;AAAA,EACtB;AACA,OAAK,YAAY,OAAO,YAAY,IAAI,UAAU,cAAc;AAC9D,WAAO;AAAA,MACL,CAAC,SAAS,GAAG;AAAA,MACb,CAAC,UAAU,GAAG;AAAA,MACd,CAAC,WAAW,GAAG;AAAA,MACf,CAAC,cAAc,GAAG;AAAA,MAClB,CAAC,aAAa,GAAG;AAAA,MACjB,CAAC,mBAAmB,GAAG,CAAC,MAAM;AAC5B,uBAAe,IAAI,CAAC;AACpB,eAAO,MAAM;AACX,yBAAe,OAAO,CAAC;AAAA,QACzB;AAAA,MACF;AAAA,MACA,CAAC,qBAAqB,GAAG,MAAM,aAAa,OAAO;AAAA,MACnD,CAAC,kBAAkB,GAAG,CAAC,MAAM,sBAAsB,IAAI,CAAC;AAAA,MACxD,CAAC,eAAe,GAAG,CAAC,MAAM,WAAW,IAAI,CAAC;AAAA,IAC5C;AAAA,EACF;AACA,SAAO;AAAA,IACL,CAAC,SAAS,GAAG;AAAA,IACb,CAAC,UAAU,GAAG;AAAA,IACd,CAAC,WAAW,GAAG;AAAA,IACf,CAAC,cAAc,GAAG;AAAA,IAClB,CAAC,aAAa,GAAG;AAAA,EACnB;AACF;AACA,IAAM,uBAAuB,CAAC,kBAAkB;AAC9C,QAAM,QAAQ,YAAY,aAAa;AACvC,QAAM,MAAM,CAACA,UAAS;AACpB,UAAM,YAAY,MAAM,SAAS,EAAEA,KAAI;AACvC,QAAI,OAAO,WAAW;AACpB,YAAM,UAAU;AAAA,IAClB;AACA,QAAI,OAAO,WAAW;AACpB,aAAO;AAAA,IACT;AACA,WAAO,UAAU;AAAA,EACnB;AACA,QAAM,WAAW,CAACA,UAAS,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC1D,UAAM,YAAY,MAAM,SAAS,EAAEA,KAAI;AACvC,QAAI,OAAO,WAAW;AACpB,aAAO,UAAU,CAAC;AAAA,IACpB,WAAW,OAAO,WAAW;AAC3B,cAAQ,UAAU,EAAE,KAAK,MAAM,SAASA,KAAI,CAAC,CAAC;AAAA,IAChD,OAAO;AACL,cAAQ,UAAU,CAAC;AAAA,IACrB;AAAA,EACF,CAAC;AACD,QAAM,MAAM,CAACA,OAAM,WAAW,MAAM,UAAU,EAAEA,OAAM,MAAM;AAC5D,QAAM,MAAM,CAACA,OAAM,aAAa,MAAM,cAAc,EAAEA,OAAM,QAAQ;AACpE,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,uBAAuB;AAAA,EACzB;AACF;AAEA,IAAM,uBAAuB,CAAC,eAAe,yBAAyB;AACpE,QAAM,QAAQ,uBAAuB,qBAAqB,aAAa,EAAE,wBAAwB,YAAY,aAAa;AAC1H,SAAO,EAAE,GAAG,MAAM;AACpB;AACA,IAAM,kBAAkC,oBAAI,IAAI;AAChD,IAAM,kBAAkB,CAAC,UAAU;AACjC,MAAI,CAAC,gBAAgB,IAAI,KAAK,GAAG;AAC/B,oBAAgB,IAAI,WAAO,4BAAc,qBAAqB,CAAC,CAAC;AAAA,EAClE;AACA,SAAO,gBAAgB,IAAI,KAAK;AAClC;AAEA,IAAM,WAAW,CAAC;AAAA,EAChB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM;AACJ,QAAM,CAAC,SAAS,UAAU,QAAI,uBAAS,CAAC,CAAC;AACzC,8BAAU,MAAM;AACd,UAAM,iBAAiB,kBAAkB;AACzC,QAAI,eAAe,GAAG;AACpB,qBAAe,EAAE,WAAW,EAAE,MAAM,OAAO;AAC3C,aAAO,QAAQ;AACf,qBAAe,IAAI;AAAA,IACrB;AAAA,EACF,GAAG,CAAC,OAAO,CAAC;AACZ,QAAM,wBAAoB,qBAAO;AACjC,MAAI,CAAC,kBAAkB,SAAS;AAC9B,UAAM,iBAAiB;AAAA,MACrB;AAAA,MACA;AAAA,IACF;AACA,QAAI,+BAA+B;AACjC,UAAI,WAAW;AACf,qBAAe,IAAI,CAAC,UAAU;AAC5B,mBAAW,CAAC,kBAAkB;AAC5B,gBAAM,cAAc,WAAW,gBAAgB,EAAE,GAAG,cAAc;AAClE,gBAAM,WAAW;AACjB,iBAAO;AAAA,QACT,CAAC;AAAA,MACH;AACA,qBAAe,IAAI;AACnB,qBAAe,IAAI,CAAC,OAAO;AACzB,UAAE;AACF,WAAG;AACH,UAAE;AAAA,MACJ;AAAA,IACF;AACA,sBAAkB,UAAU;AAAA,EAC9B;AACA,QAAM,wBAAwB,gBAAgB,KAAK;AACnD,aAAO;AAAA,IACL,sBAAsB;AAAA,IACtB;AAAA,MACE,OAAO,kBAAkB;AAAA,IAC3B;AAAA,IACA;AAAA,EACF;AACF;AAEA,SAASA,MAAK,MAAM,OAAO;AACzB,SAAO,KAAO,MAAM,KAAK;AAC3B;AAEA,SAAS,aAAaA,OAAM,OAAO;AACjC,QAAM,eAAe,gBAAgB,KAAK;AAC1C,QAAM,qBAAiB,yBAAW,YAAY;AAC9C,QAAM,EAAE,GAAG,OAAO,GAAG,oBAAoB,IAAI;AAC7C,QAAM,eAAe,CAAC,aAAa;AACjC,UAAM,YAAY,MAAM,SAAS,EAAEA,OAAM,QAAQ;AACjD,SAAK,YAAY,OAAO,YAAY,IAAI,UAAU,gBAAgB,CAAC,UAAU,GAAG;AAC9E,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AACA,QAAI,OAAO,WAAW;AACpB,YAAM,UAAU;AAAA,IAClB;AACA,QAAI,OAAO,WAAW;AACpB,YAAM,UAAU;AAAA,IAClB;AACA,QAAI,OAAO,WAAW;AACpB,aAAO,UAAU;AAAA,IACnB;AACA,UAAM,IAAI,MAAM,eAAe;AAAA,EACjC;AACA,QAAM,CAAC,CAAC,SAAS,kBAAkB,eAAe,GAAG,iBAAiB,QAAI;AAAA,IACxE,CAAC,MAAM,gBAAgB;AACrB,YAAM,YAAY,aAAa,WAAW;AAC1C,UAAI,OAAO,GAAG,KAAK,CAAC,GAAG,SAAS,KAAK,KAAK,CAAC,MAAMA,OAAM;AACrD,eAAO;AAAA,MACT;AACA,aAAO,CAAC,aAAa,WAAWA,KAAI;AAAA,IACtC;AAAA,IACA;AAAA,IACA,CAAC,mBAAmB;AAClB,YAAM,eAAe,aAAa,cAAc;AAChD,aAAO,CAAC,gBAAgB,cAAcA,KAAI;AAAA,IAC5C;AAAA,EACF;AACA,MAAI,QAAQ;AACZ,MAAI,oBAAoBA,OAAM;AAC5B,sBAAkB,OAAO;AACzB,YAAQ,aAAa,OAAO;AAAA,EAC9B;AACA,8BAAU,MAAM;AACd,UAAM,EAAE,GAAG,qBAAqB,IAAI;AACpC,QAAI,sBAAsB;AACxB,YAAM,WAAW,EAAEA,OAAM,oBAAoB;AAAA,IAC/C;AACA,UAAM,cAAc,MAAM,cAAc;AAAA,MACtCA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,sBAAkB,oBAAoB;AACtC,WAAO;AAAA,EACT,GAAG,CAAC,OAAOA,OAAM,cAAc,CAAC;AAChC,8BAAU,MAAM;AACd,UAAM,WAAW,EAAEA,OAAM,OAAO;AAAA,EAClC,CAAC;AACD,kCAAc,KAAK;AACnB,SAAO;AACT;AAEA,SAAS,WAAWA,OAAM,OAAO;AAC/B,QAAM,eAAe,gBAAgB,KAAK;AAC1C,QAAM,EAAE,GAAG,OAAO,GAAG,eAAe,QAAI,yBAAW,YAAY;AAC/D,QAAM,cAAU;AAAA,IACd,CAAC,WAAW;AACV,WAAK,YAAY,OAAO,YAAY,IAAI,UAAU,gBAAgB,EAAE,WAAWA,QAAO;AACpF,cAAM,IAAI,MAAM,mBAAmB;AAAA,MACrC;AACA,YAAM,QAAQ,CAAC,YAAY,MAAM,UAAU,EAAEA,OAAM,QAAQ,OAAO;AAClE,aAAO,iBAAiB,eAAe,KAAK,IAAI,MAAM;AAAA,IACxD;AAAA,IACA,CAAC,OAAO,gBAAgBA,KAAI;AAAA,EAC9B;AACA,SAAO;AACT;AAEA,SAAS,QAAQA,OAAM,OAAO;AAC5B,MAAI,WAAWA,OAAM;AACnB,YAAQ;AAAA,MACN;AAAA,IACF;AACA,YAAQA,MAAK;AAAA,EACf;AACA,SAAO;AAAA,IACL,aAAaA,OAAM,KAAK;AAAA;AAAA,IAExB,WAAWA,OAAM,KAAK;AAAA,EACxB;AACF;",
  "names": ["atom"]
}
