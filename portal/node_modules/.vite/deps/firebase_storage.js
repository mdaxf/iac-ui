import {
  Component,
  FirebaseError,
  getModularInstance,
  index_esm_default
} from "./chunk-TPGNHK6L.js";
import {
  __assign,
  __awaiter,
  __extends,
  __generator,
  __spreadArray
} from "./chunk-YZCXNGQM.js";
import "./chunk-M4N47H3X.js";

// node_modules/@firebase/storage/dist/index.esm.js
var DEFAULT_HOST = "firebasestorage.googleapis.com";
var CONFIG_STORAGE_BUCKET_KEY = "storageBucket";
var DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1e3;
var DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1e3;
var FirebaseStorageError = (
  /** @class */
  function(_super) {
    __extends(FirebaseStorageError2, _super);
    function FirebaseStorageError2(code, message) {
      var _this = _super.call(this, prependCode(code), "Firebase Storage: " + message + " (" + prependCode(code) + ")") || this;
      _this.customData = { serverResponse: null };
      Object.setPrototypeOf(_this, FirebaseStorageError2.prototype);
      return _this;
    }
    FirebaseStorageError2.prototype._codeEquals = function(code) {
      return prependCode(code) === this.code;
    };
    Object.defineProperty(FirebaseStorageError2.prototype, "message", {
      /**
       * Error message including serverResponse if available.
       */
      get: function() {
        if (this.customData.serverResponse) {
          return this.message + "\n" + this.customData.serverResponse;
        } else {
          return this.message;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FirebaseStorageError2.prototype, "serverResponse", {
      /**
       * Optional response message that was added by the server.
       */
      get: function() {
        return this.customData.serverResponse;
      },
      set: function(serverResponse) {
        this.customData.serverResponse = serverResponse;
      },
      enumerable: false,
      configurable: true
    });
    return FirebaseStorageError2;
  }(FirebaseError)
);
function prependCode(code) {
  return "storage/" + code;
}
function unknown() {
  var message = "An unknown error occurred, please check the error payload for server response.";
  return new FirebaseStorageError("unknown", message);
}
function objectNotFound(path) {
  return new FirebaseStorageError("object-not-found", "Object '" + path + "' does not exist.");
}
function quotaExceeded(bucket) {
  return new FirebaseStorageError("quota-exceeded", "Quota for bucket '" + bucket + "' exceeded, please view quota on https://firebase.google.com/pricing/.");
}
function unauthenticated() {
  var message = "User is not authenticated, please authenticate using Firebase Authentication and try again.";
  return new FirebaseStorageError("unauthenticated", message);
}
function unauthorized(path) {
  return new FirebaseStorageError("unauthorized", "User does not have permission to access '" + path + "'.");
}
function retryLimitExceeded() {
  return new FirebaseStorageError("retry-limit-exceeded", "Max retry time for operation exceeded, please try again.");
}
function canceled() {
  return new FirebaseStorageError("canceled", "User canceled the upload/download.");
}
function invalidUrl(url) {
  return new FirebaseStorageError("invalid-url", "Invalid URL '" + url + "'.");
}
function invalidDefaultBucket(bucket) {
  return new FirebaseStorageError("invalid-default-bucket", "Invalid default bucket '" + bucket + "'.");
}
function noDefaultBucket() {
  return new FirebaseStorageError("no-default-bucket", "No default bucket found. Did you set the '" + CONFIG_STORAGE_BUCKET_KEY + "' property when initializing the app?");
}
function cannotSliceBlob() {
  return new FirebaseStorageError("cannot-slice-blob", "Cannot slice blob for upload. Please retry the upload.");
}
function serverFileWrongSize() {
  return new FirebaseStorageError("server-file-wrong-size", "Server recorded incorrect upload file size, please retry the upload.");
}
function noDownloadURL() {
  return new FirebaseStorageError("no-download-url", "The given file does not have any download URLs.");
}
function invalidArgument(message) {
  return new FirebaseStorageError("invalid-argument", message);
}
function appDeleted() {
  return new FirebaseStorageError("app-deleted", "The Firebase app was deleted.");
}
function invalidRootOperation(name2) {
  return new FirebaseStorageError("invalid-root-operation", "The operation '" + name2 + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
}
function invalidFormat(format, message) {
  return new FirebaseStorageError("invalid-format", "String does not match format '" + format + "': " + message);
}
function internalError(message) {
  throw new FirebaseStorageError("internal-error", "Internal error: " + message);
}
var StringFormat = {
  /**
   * Indicates the string should be interpreted "raw", that is, as normal text.
   * The string will be interpreted as UTF-16, then uploaded as a UTF-8 byte
   * sequence.
   * Example: The string 'Hello! \\ud83d\\ude0a' becomes the byte sequence
   * 48 65 6c 6c 6f 21 20 f0 9f 98 8a
   */
  RAW: "raw",
  /**
   * Indicates the string should be interpreted as base64-encoded data.
   * Padding characters (trailing '='s) are optional.
   * Example: The string 'rWmO++E6t7/rlw==' becomes the byte sequence
   * ad 69 8e fb e1 3a b7 bf eb 97
   */
  BASE64: "base64",
  /**
   * Indicates the string should be interpreted as base64url-encoded data.
   * Padding characters (trailing '='s) are optional.
   * Example: The string 'rWmO--E6t7_rlw==' becomes the byte sequence
   * ad 69 8e fb e1 3a b7 bf eb 97
   */
  BASE64URL: "base64url",
  /**
   * Indicates the string is a data URL, such as one obtained from
   * canvas.toDataURL().
   * Example: the string 'data:application/octet-stream;base64,aaaa'
   * becomes the byte sequence
   * 69 a6 9a
   * (the content-type "application/octet-stream" is also applied, but can
   * be overridden in the metadata object).
   */
  DATA_URL: "data_url"
};
var StringData = (
  /** @class */
  function() {
    function StringData2(data, contentType) {
      this.data = data;
      this.contentType = contentType || null;
    }
    return StringData2;
  }()
);
function dataFromString(format, stringData) {
  switch (format) {
    case StringFormat.RAW:
      return new StringData(utf8Bytes_(stringData));
    case StringFormat.BASE64:
    case StringFormat.BASE64URL:
      return new StringData(base64Bytes_(format, stringData));
    case StringFormat.DATA_URL:
      return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));
  }
  throw unknown();
}
function utf8Bytes_(value) {
  var b = [];
  for (var i = 0; i < value.length; i++) {
    var c = value.charCodeAt(i);
    if (c <= 127) {
      b.push(c);
    } else {
      if (c <= 2047) {
        b.push(192 | c >> 6, 128 | c & 63);
      } else {
        if ((c & 64512) === 55296) {
          var valid = i < value.length - 1 && (value.charCodeAt(i + 1) & 64512) === 56320;
          if (!valid) {
            b.push(239, 191, 189);
          } else {
            var hi = c;
            var lo = value.charCodeAt(++i);
            c = 65536 | (hi & 1023) << 10 | lo & 1023;
            b.push(240 | c >> 18, 128 | c >> 12 & 63, 128 | c >> 6 & 63, 128 | c & 63);
          }
        } else {
          if ((c & 64512) === 56320) {
            b.push(239, 191, 189);
          } else {
            b.push(224 | c >> 12, 128 | c >> 6 & 63, 128 | c & 63);
          }
        }
      }
    }
  }
  return new Uint8Array(b);
}
function percentEncodedBytes_(value) {
  var decoded;
  try {
    decoded = decodeURIComponent(value);
  } catch (e) {
    throw invalidFormat(StringFormat.DATA_URL, "Malformed data URL.");
  }
  return utf8Bytes_(decoded);
}
function base64Bytes_(format, value) {
  switch (format) {
    case StringFormat.BASE64: {
      var hasMinus = value.indexOf("-") !== -1;
      var hasUnder = value.indexOf("_") !== -1;
      if (hasMinus || hasUnder) {
        var invalidChar = hasMinus ? "-" : "_";
        throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64url encoded?");
      }
      break;
    }
    case StringFormat.BASE64URL: {
      var hasPlus = value.indexOf("+") !== -1;
      var hasSlash = value.indexOf("/") !== -1;
      if (hasPlus || hasSlash) {
        var invalidChar = hasPlus ? "+" : "/";
        throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64 encoded?");
      }
      value = value.replace(/-/g, "+").replace(/_/g, "/");
      break;
    }
  }
  var bytes;
  try {
    bytes = atob(value);
  } catch (e) {
    throw invalidFormat(format, "Invalid character found");
  }
  var array = new Uint8Array(bytes.length);
  for (var i = 0; i < bytes.length; i++) {
    array[i] = bytes.charCodeAt(i);
  }
  return array;
}
var DataURLParts = (
  /** @class */
  function() {
    function DataURLParts2(dataURL) {
      this.base64 = false;
      this.contentType = null;
      var matches = dataURL.match(/^data:([^,]+)?,/);
      if (matches === null) {
        throw invalidFormat(StringFormat.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
      }
      var middle = matches[1] || null;
      if (middle != null) {
        this.base64 = endsWith(middle, ";base64");
        this.contentType = this.base64 ? middle.substring(0, middle.length - ";base64".length) : middle;
      }
      this.rest = dataURL.substring(dataURL.indexOf(",") + 1);
    }
    return DataURLParts2;
  }()
);
function dataURLBytes_(dataUrl) {
  var parts = new DataURLParts(dataUrl);
  if (parts.base64) {
    return base64Bytes_(StringFormat.BASE64, parts.rest);
  } else {
    return percentEncodedBytes_(parts.rest);
  }
}
function dataURLContentType_(dataUrl) {
  var parts = new DataURLParts(dataUrl);
  return parts.contentType;
}
function endsWith(s, end) {
  var longEnough = s.length >= end.length;
  if (!longEnough) {
    return false;
  }
  return s.substring(s.length - end.length) === end;
}
var TaskEvent = {
  /**
   * For this event,
   * <ul>
   *   <li>The `next` function is triggered on progress updates and when the
   *       task is paused/resumed with an `UploadTaskSnapshot` as the first
   *       argument.</li>
   *   <li>The `error` function is triggered if the upload is canceled or fails
   *       for another reason.</li>
   *   <li>The `complete` function is triggered if the upload completes
   *       successfully.</li>
   * </ul>
   */
  STATE_CHANGED: "state_changed"
};
var TaskState = {
  /** The task is currently transferring data. */
  RUNNING: "running",
  /** The task was paused by the user. */
  PAUSED: "paused",
  /** The task completed successfully. */
  SUCCESS: "success",
  /** The task was canceled. */
  CANCELED: "canceled",
  /** The task failed with an error. */
  ERROR: "error"
};
function taskStateFromInternalTaskState(state) {
  switch (state) {
    case "running":
    case "pausing":
    case "canceling":
      return TaskState.RUNNING;
    case "paused":
      return TaskState.PAUSED;
    case "success":
      return TaskState.SUCCESS;
    case "canceled":
      return TaskState.CANCELED;
    case "error":
      return TaskState.ERROR;
    default:
      return TaskState.ERROR;
  }
}
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["NO_ERROR"] = 0] = "NO_ERROR";
  ErrorCode2[ErrorCode2["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
  ErrorCode2[ErrorCode2["ABORT"] = 2] = "ABORT";
})(ErrorCode || (ErrorCode = {}));
var NetworkXhrIo = (
  /** @class */
  function() {
    function NetworkXhrIo2() {
      var _this = this;
      this.sent_ = false;
      this.xhr_ = new XMLHttpRequest();
      this.errorCode_ = ErrorCode.NO_ERROR;
      this.sendPromise_ = new Promise(function(resolve) {
        _this.xhr_.addEventListener("abort", function() {
          _this.errorCode_ = ErrorCode.ABORT;
          resolve(_this);
        });
        _this.xhr_.addEventListener("error", function() {
          _this.errorCode_ = ErrorCode.NETWORK_ERROR;
          resolve(_this);
        });
        _this.xhr_.addEventListener("load", function() {
          resolve(_this);
        });
      });
    }
    NetworkXhrIo2.prototype.send = function(url, method, body, headers) {
      if (this.sent_) {
        throw internalError("cannot .send() more than once");
      }
      this.sent_ = true;
      this.xhr_.open(method, url, true);
      if (headers !== void 0) {
        for (var key in headers) {
          if (headers.hasOwnProperty(key)) {
            this.xhr_.setRequestHeader(key, headers[key].toString());
          }
        }
      }
      if (body !== void 0) {
        this.xhr_.send(body);
      } else {
        this.xhr_.send();
      }
      return this.sendPromise_;
    };
    NetworkXhrIo2.prototype.getErrorCode = function() {
      if (!this.sent_) {
        throw internalError("cannot .getErrorCode() before sending");
      }
      return this.errorCode_;
    };
    NetworkXhrIo2.prototype.getStatus = function() {
      if (!this.sent_) {
        throw internalError("cannot .getStatus() before sending");
      }
      try {
        return this.xhr_.status;
      } catch (e) {
        return -1;
      }
    };
    NetworkXhrIo2.prototype.getResponseText = function() {
      if (!this.sent_) {
        throw internalError("cannot .getResponseText() before sending");
      }
      return this.xhr_.responseText;
    };
    NetworkXhrIo2.prototype.abort = function() {
      this.xhr_.abort();
    };
    NetworkXhrIo2.prototype.getResponseHeader = function(header) {
      return this.xhr_.getResponseHeader(header);
    };
    NetworkXhrIo2.prototype.addUploadProgressListener = function(listener) {
      if (this.xhr_.upload != null) {
        this.xhr_.upload.addEventListener("progress", listener);
      }
    };
    NetworkXhrIo2.prototype.removeUploadProgressListener = function(listener) {
      if (this.xhr_.upload != null) {
        this.xhr_.upload.removeEventListener("progress", listener);
      }
    };
    return NetworkXhrIo2;
  }()
);
var XhrIoPool = (
  /** @class */
  function() {
    function XhrIoPool2() {
    }
    XhrIoPool2.prototype.createXhrIo = function() {
      return new NetworkXhrIo();
    };
    return XhrIoPool2;
  }()
);
var Location = (
  /** @class */
  function() {
    function Location2(bucket, path) {
      this.bucket = bucket;
      this.path_ = path;
    }
    Object.defineProperty(Location2.prototype, "path", {
      get: function() {
        return this.path_;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Location2.prototype, "isRoot", {
      get: function() {
        return this.path.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Location2.prototype.fullServerUrl = function() {
      var encode = encodeURIComponent;
      return "/b/" + encode(this.bucket) + "/o/" + encode(this.path);
    };
    Location2.prototype.bucketOnlyServerUrl = function() {
      var encode = encodeURIComponent;
      return "/b/" + encode(this.bucket) + "/o";
    };
    Location2.makeFromBucketSpec = function(bucketString) {
      var bucketLocation;
      try {
        bucketLocation = Location2.makeFromUrl(bucketString);
      } catch (e) {
        return new Location2(bucketString, "");
      }
      if (bucketLocation.path === "") {
        return bucketLocation;
      } else {
        throw invalidDefaultBucket(bucketString);
      }
    };
    Location2.makeFromUrl = function(url) {
      var location = null;
      var bucketDomain = "([A-Za-z0-9.\\-_]+)";
      function gsModify(loc) {
        if (loc.path.charAt(loc.path.length - 1) === "/") {
          loc.path_ = loc.path_.slice(0, -1);
        }
      }
      var gsPath = "(/(.*))?$";
      var gsRegex = new RegExp("^gs://" + bucketDomain + gsPath, "i");
      var gsIndices = { bucket: 1, path: 3 };
      function httpModify(loc) {
        loc.path_ = decodeURIComponent(loc.path);
      }
      var version2 = "v[A-Za-z0-9_]+";
      var firebaseStorageHost = DEFAULT_HOST.replace(/[.]/g, "\\.");
      var firebaseStoragePath = "(/([^?#]*).*)?$";
      var firebaseStorageRegExp = new RegExp("^https?://" + firebaseStorageHost + "/" + version2 + "/b/" + bucketDomain + "/o" + firebaseStoragePath, "i");
      var firebaseStorageIndices = { bucket: 1, path: 3 };
      var cloudStorageHost = "(?:storage.googleapis.com|storage.cloud.google.com)";
      var cloudStoragePath = "([^?#]*)";
      var cloudStorageRegExp = new RegExp("^https?://" + cloudStorageHost + "/" + bucketDomain + "/" + cloudStoragePath, "i");
      var cloudStorageIndices = { bucket: 1, path: 2 };
      var groups = [
        { regex: gsRegex, indices: gsIndices, postModify: gsModify },
        {
          regex: firebaseStorageRegExp,
          indices: firebaseStorageIndices,
          postModify: httpModify
        },
        {
          regex: cloudStorageRegExp,
          indices: cloudStorageIndices,
          postModify: httpModify
        }
      ];
      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        var captures = group.regex.exec(url);
        if (captures) {
          var bucketValue = captures[group.indices.bucket];
          var pathValue = captures[group.indices.path];
          if (!pathValue) {
            pathValue = "";
          }
          location = new Location2(bucketValue, pathValue);
          group.postModify(location);
          break;
        }
      }
      if (location == null) {
        throw invalidUrl(url);
      }
      return location;
    };
    return Location2;
  }()
);
var FailRequest = (
  /** @class */
  function() {
    function FailRequest2(error) {
      this.promise_ = Promise.reject(error);
    }
    FailRequest2.prototype.getPromise = function() {
      return this.promise_;
    };
    FailRequest2.prototype.cancel = function(_appDelete) {
    };
    return FailRequest2;
  }()
);
function start(f, callback, timeout) {
  var waitSeconds = 1;
  var timeoutId = null;
  var hitTimeout = false;
  var cancelState = 0;
  function canceled2() {
    return cancelState === 2;
  }
  var triggeredCallback = false;
  function triggerCallback() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!triggeredCallback) {
      triggeredCallback = true;
      callback.apply(null, args);
    }
  }
  function callWithDelay(millis) {
    timeoutId = setTimeout(function() {
      timeoutId = null;
      f(handler, canceled2());
    }, millis);
  }
  function handler(success) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (triggeredCallback) {
      return;
    }
    if (success) {
      triggerCallback.call.apply(triggerCallback, __spreadArray([null, success], args));
      return;
    }
    var mustStop = canceled2() || hitTimeout;
    if (mustStop) {
      triggerCallback.call.apply(triggerCallback, __spreadArray([null, success], args));
      return;
    }
    if (waitSeconds < 64) {
      waitSeconds *= 2;
    }
    var waitMillis;
    if (cancelState === 1) {
      cancelState = 2;
      waitMillis = 0;
    } else {
      waitMillis = (waitSeconds + Math.random()) * 1e3;
    }
    callWithDelay(waitMillis);
  }
  var stopped = false;
  function stop2(wasTimeout) {
    if (stopped) {
      return;
    }
    stopped = true;
    if (triggeredCallback) {
      return;
    }
    if (timeoutId !== null) {
      if (!wasTimeout) {
        cancelState = 2;
      }
      clearTimeout(timeoutId);
      callWithDelay(0);
    } else {
      if (!wasTimeout) {
        cancelState = 1;
      }
    }
  }
  callWithDelay(0);
  setTimeout(function() {
    hitTimeout = true;
    stop2(true);
  }, timeout);
  return stop2;
}
function stop(id) {
  id(false);
}
function isJustDef(p) {
  return p !== void 0;
}
function isFunction(p) {
  return typeof p === "function";
}
function isNonArrayObject(p) {
  return typeof p === "object" && !Array.isArray(p);
}
function isString(p) {
  return typeof p === "string" || p instanceof String;
}
function isNativeBlob(p) {
  return isNativeBlobDefined() && p instanceof Blob;
}
function isNativeBlobDefined() {
  return typeof Blob !== "undefined";
}
function validateNumber(argument, minValue, maxValue, value) {
  if (value < minValue) {
    throw invalidArgument("Invalid value for '" + argument + "'. Expected " + minValue + " or greater.");
  }
  if (value > maxValue) {
    throw invalidArgument("Invalid value for '" + argument + "'. Expected " + maxValue + " or less.");
  }
}
function makeUrl(urlPart) {
  return "https://" + DEFAULT_HOST + "/v0" + urlPart;
}
function makeQueryString(params) {
  var encode = encodeURIComponent;
  var queryPart = "?";
  for (var key in params) {
    if (params.hasOwnProperty(key)) {
      var nextPart = encode(key) + "=" + encode(params[key]);
      queryPart = queryPart + nextPart + "&";
    }
  }
  queryPart = queryPart.slice(0, -1);
  return queryPart;
}
var NetworkRequest = (
  /** @class */
  function() {
    function NetworkRequest2(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) {
      var _this = this;
      this.pendingXhr_ = null;
      this.backoffId_ = null;
      this.canceled_ = false;
      this.appDelete_ = false;
      this.url_ = url;
      this.method_ = method;
      this.headers_ = headers;
      this.body_ = body;
      this.successCodes_ = successCodes.slice();
      this.additionalRetryCodes_ = additionalRetryCodes.slice();
      this.callback_ = callback;
      this.errorCallback_ = errorCallback;
      this.progressCallback_ = progressCallback;
      this.timeout_ = timeout;
      this.pool_ = pool;
      this.promise_ = new Promise(function(resolve, reject) {
        _this.resolve_ = resolve;
        _this.reject_ = reject;
        _this.start_();
      });
    }
    NetworkRequest2.prototype.start_ = function() {
      var self = this;
      function doTheRequest(backoffCallback, canceled2) {
        if (canceled2) {
          backoffCallback(false, new RequestEndStatus(false, null, true));
          return;
        }
        var xhr = self.pool_.createXhrIo();
        self.pendingXhr_ = xhr;
        function progressListener(progressEvent) {
          var loaded = progressEvent.loaded;
          var total = progressEvent.lengthComputable ? progressEvent.total : -1;
          if (self.progressCallback_ !== null) {
            self.progressCallback_(loaded, total);
          }
        }
        if (self.progressCallback_ !== null) {
          xhr.addUploadProgressListener(progressListener);
        }
        xhr.send(self.url_, self.method_, self.body_, self.headers_).then(function(xhr2) {
          if (self.progressCallback_ !== null) {
            xhr2.removeUploadProgressListener(progressListener);
          }
          self.pendingXhr_ = null;
          xhr2 = xhr2;
          var hitServer = xhr2.getErrorCode() === ErrorCode.NO_ERROR;
          var status = xhr2.getStatus();
          if (!hitServer || self.isRetryStatusCode_(status)) {
            var wasCanceled = xhr2.getErrorCode() === ErrorCode.ABORT;
            backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
            return;
          }
          var successCode = self.successCodes_.indexOf(status) !== -1;
          backoffCallback(true, new RequestEndStatus(successCode, xhr2));
        });
      }
      function backoffDone(requestWentThrough, status) {
        var resolve = self.resolve_;
        var reject = self.reject_;
        var xhr = status.xhr;
        if (status.wasSuccessCode) {
          try {
            var result = self.callback_(xhr, xhr.getResponseText());
            if (isJustDef(result)) {
              resolve(result);
            } else {
              resolve();
            }
          } catch (e) {
            reject(e);
          }
        } else {
          if (xhr !== null) {
            var err = unknown();
            err.serverResponse = xhr.getResponseText();
            if (self.errorCallback_) {
              reject(self.errorCallback_(xhr, err));
            } else {
              reject(err);
            }
          } else {
            if (status.canceled) {
              var err = self.appDelete_ ? appDeleted() : canceled();
              reject(err);
            } else {
              var err = retryLimitExceeded();
              reject(err);
            }
          }
        }
      }
      if (this.canceled_) {
        backoffDone(false, new RequestEndStatus(false, null, true));
      } else {
        this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);
      }
    };
    NetworkRequest2.prototype.getPromise = function() {
      return this.promise_;
    };
    NetworkRequest2.prototype.cancel = function(appDelete) {
      this.canceled_ = true;
      this.appDelete_ = appDelete || false;
      if (this.backoffId_ !== null) {
        stop(this.backoffId_);
      }
      if (this.pendingXhr_ !== null) {
        this.pendingXhr_.abort();
      }
    };
    NetworkRequest2.prototype.isRetryStatusCode_ = function(status) {
      var isFiveHundredCode = status >= 500 && status < 600;
      var extraRetryCodes = [
        // Request Timeout: web server didn't receive full request in time.
        408,
        // Too Many Requests: you're getting rate-limited, basically.
        429
      ];
      var isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;
      var isRequestSpecificRetryCode = this.additionalRetryCodes_.indexOf(status) !== -1;
      return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;
    };
    return NetworkRequest2;
  }()
);
var RequestEndStatus = (
  /** @class */
  function() {
    function RequestEndStatus2(wasSuccessCode, xhr, canceled2) {
      this.wasSuccessCode = wasSuccessCode;
      this.xhr = xhr;
      this.canceled = !!canceled2;
    }
    return RequestEndStatus2;
  }()
);
function addAuthHeader_(headers, authToken) {
  if (authToken !== null && authToken.length > 0) {
    headers["Authorization"] = "Firebase " + authToken;
  }
}
function addVersionHeader_(headers, firebaseVersion) {
  headers["X-Firebase-Storage-Version"] = "webjs/" + (firebaseVersion !== null && firebaseVersion !== void 0 ? firebaseVersion : "AppManager");
}
function addGmpidHeader_(headers, appId) {
  if (appId) {
    headers["X-Firebase-GMPID"] = appId;
  }
}
function makeRequest(requestInfo, appId, authToken, pool, firebaseVersion) {
  var queryPart = makeQueryString(requestInfo.urlParams);
  var url = requestInfo.url + queryPart;
  var headers = Object.assign({}, requestInfo.headers);
  addGmpidHeader_(headers, appId);
  addAuthHeader_(headers, authToken);
  addVersionHeader_(headers, firebaseVersion);
  return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);
}
function getBlobBuilder() {
  if (typeof BlobBuilder !== "undefined") {
    return BlobBuilder;
  } else if (typeof WebKitBlobBuilder !== "undefined") {
    return WebKitBlobBuilder;
  } else {
    return void 0;
  }
}
function getBlob() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var BlobBuilder2 = getBlobBuilder();
  if (BlobBuilder2 !== void 0) {
    var bb = new BlobBuilder2();
    for (var i = 0; i < args.length; i++) {
      bb.append(args[i]);
    }
    return bb.getBlob();
  } else {
    if (isNativeBlobDefined()) {
      return new Blob(args);
    } else {
      throw new FirebaseStorageError("unsupported-environment", "This browser doesn't seem to support creating Blobs");
    }
  }
}
function sliceBlob(blob, start2, end) {
  if (blob.webkitSlice) {
    return blob.webkitSlice(start2, end);
  } else if (blob.mozSlice) {
    return blob.mozSlice(start2, end);
  } else if (blob.slice) {
    return blob.slice(start2, end);
  }
  return null;
}
var FbsBlob = (
  /** @class */
  function() {
    function FbsBlob2(data, elideCopy) {
      var size = 0;
      var blobType = "";
      if (isNativeBlob(data)) {
        this.data_ = data;
        size = data.size;
        blobType = data.type;
      } else if (data instanceof ArrayBuffer) {
        if (elideCopy) {
          this.data_ = new Uint8Array(data);
        } else {
          this.data_ = new Uint8Array(data.byteLength);
          this.data_.set(new Uint8Array(data));
        }
        size = this.data_.length;
      } else if (data instanceof Uint8Array) {
        if (elideCopy) {
          this.data_ = data;
        } else {
          this.data_ = new Uint8Array(data.length);
          this.data_.set(data);
        }
        size = data.length;
      }
      this.size_ = size;
      this.type_ = blobType;
    }
    FbsBlob2.prototype.size = function() {
      return this.size_;
    };
    FbsBlob2.prototype.type = function() {
      return this.type_;
    };
    FbsBlob2.prototype.slice = function(startByte, endByte) {
      if (isNativeBlob(this.data_)) {
        var realBlob = this.data_;
        var sliced = sliceBlob(realBlob, startByte, endByte);
        if (sliced === null) {
          return null;
        }
        return new FbsBlob2(sliced);
      } else {
        var slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);
        return new FbsBlob2(slice, true);
      }
    };
    FbsBlob2.getBlob = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (isNativeBlobDefined()) {
        var blobby = args.map(function(val) {
          if (val instanceof FbsBlob2) {
            return val.data_;
          } else {
            return val;
          }
        });
        return new FbsBlob2(getBlob.apply(null, blobby));
      } else {
        var uint8Arrays = args.map(function(val) {
          if (isString(val)) {
            return dataFromString(StringFormat.RAW, val).data;
          } else {
            return val.data_;
          }
        });
        var finalLength_1 = 0;
        uint8Arrays.forEach(function(array) {
          finalLength_1 += array.byteLength;
        });
        var merged_1 = new Uint8Array(finalLength_1);
        var index_1 = 0;
        uint8Arrays.forEach(function(array) {
          for (var i = 0; i < array.length; i++) {
            merged_1[index_1++] = array[i];
          }
        });
        return new FbsBlob2(merged_1, true);
      }
    };
    FbsBlob2.prototype.uploadData = function() {
      return this.data_;
    };
    return FbsBlob2;
  }()
);
function jsonObjectOrNull(s) {
  var obj;
  try {
    obj = JSON.parse(s);
  } catch (e) {
    return null;
  }
  if (isNonArrayObject(obj)) {
    return obj;
  } else {
    return null;
  }
}
function parent(path) {
  if (path.length === 0) {
    return null;
  }
  var index = path.lastIndexOf("/");
  if (index === -1) {
    return "";
  }
  var newPath = path.slice(0, index);
  return newPath;
}
function child(path, childPath) {
  var canonicalChildPath = childPath.split("/").filter(function(component) {
    return component.length > 0;
  }).join("/");
  if (path.length === 0) {
    return canonicalChildPath;
  } else {
    return path + "/" + canonicalChildPath;
  }
}
function lastComponent(path) {
  var index = path.lastIndexOf("/", path.length - 2);
  if (index === -1) {
    return path;
  } else {
    return path.slice(index + 1);
  }
}
function noXform_(metadata, value) {
  return value;
}
var Mapping = (
  /** @class */
  function() {
    function Mapping2(server, local, writable, xform) {
      this.server = server;
      this.local = local || server;
      this.writable = !!writable;
      this.xform = xform || noXform_;
    }
    return Mapping2;
  }()
);
var mappings_ = null;
function xformPath(fullPath) {
  if (!isString(fullPath) || fullPath.length < 2) {
    return fullPath;
  } else {
    return lastComponent(fullPath);
  }
}
function getMappings() {
  if (mappings_) {
    return mappings_;
  }
  var mappings = [];
  mappings.push(new Mapping("bucket"));
  mappings.push(new Mapping("generation"));
  mappings.push(new Mapping("metageneration"));
  mappings.push(new Mapping("name", "fullPath", true));
  function mappingsXformPath(_metadata, fullPath) {
    return xformPath(fullPath);
  }
  var nameMapping = new Mapping("name");
  nameMapping.xform = mappingsXformPath;
  mappings.push(nameMapping);
  function xformSize(_metadata, size) {
    if (size !== void 0) {
      return Number(size);
    } else {
      return size;
    }
  }
  var sizeMapping = new Mapping("size");
  sizeMapping.xform = xformSize;
  mappings.push(sizeMapping);
  mappings.push(new Mapping("timeCreated"));
  mappings.push(new Mapping("updated"));
  mappings.push(new Mapping("md5Hash", null, true));
  mappings.push(new Mapping("cacheControl", null, true));
  mappings.push(new Mapping("contentDisposition", null, true));
  mappings.push(new Mapping("contentEncoding", null, true));
  mappings.push(new Mapping("contentLanguage", null, true));
  mappings.push(new Mapping("contentType", null, true));
  mappings.push(new Mapping("metadata", "customMetadata", true));
  mappings_ = mappings;
  return mappings_;
}
function addRef(metadata, service) {
  function generateRef() {
    var bucket = metadata["bucket"];
    var path = metadata["fullPath"];
    var loc = new Location(bucket, path);
    return service._makeStorageReference(loc);
  }
  Object.defineProperty(metadata, "ref", { get: generateRef });
}
function fromResource(service, resource, mappings) {
  var metadata = {};
  metadata["type"] = "file";
  var len = mappings.length;
  for (var i = 0; i < len; i++) {
    var mapping = mappings[i];
    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
  }
  addRef(metadata, service);
  return metadata;
}
function fromResourceString(service, resourceString, mappings) {
  var obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  var resource = obj;
  return fromResource(service, resource, mappings);
}
function downloadUrlFromResourceString(metadata, resourceString) {
  var obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  if (!isString(obj["downloadTokens"])) {
    return null;
  }
  var tokens = obj["downloadTokens"];
  if (tokens.length === 0) {
    return null;
  }
  var encode = encodeURIComponent;
  var tokensList = tokens.split(",");
  var urls = tokensList.map(function(token) {
    var bucket = metadata["bucket"];
    var path = metadata["fullPath"];
    var urlPart = "/b/" + encode(bucket) + "/o/" + encode(path);
    var base = makeUrl(urlPart);
    var queryString = makeQueryString({
      alt: "media",
      token
    });
    return base + queryString;
  });
  return urls[0];
}
function toResourceString(metadata, mappings) {
  var resource = {};
  var len = mappings.length;
  for (var i = 0; i < len; i++) {
    var mapping = mappings[i];
    if (mapping.writable) {
      resource[mapping.server] = metadata[mapping.local];
    }
  }
  return JSON.stringify(resource);
}
var PREFIXES_KEY = "prefixes";
var ITEMS_KEY = "items";
function fromBackendResponse(service, bucket, resource) {
  var listResult = {
    prefixes: [],
    items: [],
    nextPageToken: resource["nextPageToken"]
  };
  if (resource[PREFIXES_KEY]) {
    for (var _i = 0, _a = resource[PREFIXES_KEY]; _i < _a.length; _i++) {
      var path = _a[_i];
      var pathWithoutTrailingSlash = path.replace(/\/$/, "");
      var reference = service._makeStorageReference(new Location(bucket, pathWithoutTrailingSlash));
      listResult.prefixes.push(reference);
    }
  }
  if (resource[ITEMS_KEY]) {
    for (var _b = 0, _c = resource[ITEMS_KEY]; _b < _c.length; _b++) {
      var item = _c[_b];
      var reference = service._makeStorageReference(new Location(bucket, item["name"]));
      listResult.items.push(reference);
    }
  }
  return listResult;
}
function fromResponseString(service, bucket, resourceString) {
  var obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  var resource = obj;
  return fromBackendResponse(service, bucket, resource);
}
var RequestInfo = (
  /** @class */
  function() {
    function RequestInfo2(url, method, handler, timeout) {
      this.url = url;
      this.method = method;
      this.handler = handler;
      this.timeout = timeout;
      this.urlParams = {};
      this.headers = {};
      this.body = null;
      this.errorHandler = null;
      this.progressCallback = null;
      this.successCodes = [200];
      this.additionalRetryCodes = [];
    }
    return RequestInfo2;
  }()
);
function handlerCheck(cndn) {
  if (!cndn) {
    throw unknown();
  }
}
function metadataHandler(service, mappings) {
  function handler(xhr, text) {
    var metadata = fromResourceString(service, text, mappings);
    handlerCheck(metadata !== null);
    return metadata;
  }
  return handler;
}
function listHandler(service, bucket) {
  function handler(xhr, text) {
    var listResult = fromResponseString(service, bucket, text);
    handlerCheck(listResult !== null);
    return listResult;
  }
  return handler;
}
function downloadUrlHandler(service, mappings) {
  function handler(xhr, text) {
    var metadata = fromResourceString(service, text, mappings);
    handlerCheck(metadata !== null);
    return downloadUrlFromResourceString(metadata, text);
  }
  return handler;
}
function sharedErrorHandler(location) {
  function errorHandler(xhr, err) {
    var newErr;
    if (xhr.getStatus() === 401) {
      newErr = unauthenticated();
    } else {
      if (xhr.getStatus() === 402) {
        newErr = quotaExceeded(location.bucket);
      } else {
        if (xhr.getStatus() === 403) {
          newErr = unauthorized(location.path);
        } else {
          newErr = err;
        }
      }
    }
    newErr.serverResponse = err.serverResponse;
    return newErr;
  }
  return errorHandler;
}
function objectErrorHandler(location) {
  var shared = sharedErrorHandler(location);
  function errorHandler(xhr, err) {
    var newErr = shared(xhr, err);
    if (xhr.getStatus() === 404) {
      newErr = objectNotFound(location.path);
    }
    newErr.serverResponse = err.serverResponse;
    return newErr;
  }
  return errorHandler;
}
function getMetadata(service, location, mappings) {
  var urlPart = location.fullServerUrl();
  var url = makeUrl(urlPart);
  var method = "GET";
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function list(service, location, delimiter, pageToken, maxResults) {
  var urlParams = {};
  if (location.isRoot) {
    urlParams["prefix"] = "";
  } else {
    urlParams["prefix"] = location.path + "/";
  }
  if (delimiter && delimiter.length > 0) {
    urlParams["delimiter"] = delimiter;
  }
  if (pageToken) {
    urlParams["pageToken"] = pageToken;
  }
  if (maxResults) {
    urlParams["maxResults"] = maxResults;
  }
  var urlPart = location.bucketOnlyServerUrl();
  var url = makeUrl(urlPart);
  var method = "GET";
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, listHandler(service, location.bucket), timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
function getDownloadUrl(service, location, mappings) {
  var urlPart = location.fullServerUrl();
  var url = makeUrl(urlPart);
  var method = "GET";
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function updateMetadata(service, location, metadata, mappings) {
  var urlPart = location.fullServerUrl();
  var url = makeUrl(urlPart);
  var method = "PATCH";
  var body = toResourceString(metadata, mappings);
  var headers = { "Content-Type": "application/json; charset=utf-8" };
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.headers = headers;
  requestInfo.body = body;
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function deleteObject(service, location) {
  var urlPart = location.fullServerUrl();
  var url = makeUrl(urlPart);
  var method = "DELETE";
  var timeout = service.maxOperationRetryTime;
  function handler(_xhr, _text) {
  }
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.successCodes = [200, 204];
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function determineContentType_(metadata, blob) {
  return metadata && metadata["contentType"] || blob && blob.type() || "application/octet-stream";
}
function metadataForUpload_(location, blob, metadata) {
  var metadataClone = Object.assign({}, metadata);
  metadataClone["fullPath"] = location.path;
  metadataClone["size"] = blob.size();
  if (!metadataClone["contentType"]) {
    metadataClone["contentType"] = determineContentType_(null, blob);
  }
  return metadataClone;
}
function multipartUpload(service, location, mappings, blob, metadata) {
  var urlPart = location.bucketOnlyServerUrl();
  var headers = {
    "X-Goog-Upload-Protocol": "multipart"
  };
  function genBoundary() {
    var str = "";
    for (var i = 0; i < 2; i++) {
      str = str + Math.random().toString().slice(2);
    }
    return str;
  }
  var boundary = genBoundary();
  headers["Content-Type"] = "multipart/related; boundary=" + boundary;
  var metadata_ = metadataForUpload_(location, blob, metadata);
  var metadataString = toResourceString(metadata_, mappings);
  var preBlobPart = "--" + boundary + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + metadataString + "\r\n--" + boundary + "\r\nContent-Type: " + metadata_["contentType"] + "\r\n\r\n";
  var postBlobPart = "\r\n--" + boundary + "--";
  var body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);
  if (body === null) {
    throw cannotSliceBlob();
  }
  var urlParams = { name: metadata_["fullPath"] };
  var url = makeUrl(urlPart);
  var method = "POST";
  var timeout = service.maxUploadRetryTime;
  var requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.headers = headers;
  requestInfo.body = body.uploadData();
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
var ResumableUploadStatus = (
  /** @class */
  function() {
    function ResumableUploadStatus2(current, total, finalized, metadata) {
      this.current = current;
      this.total = total;
      this.finalized = !!finalized;
      this.metadata = metadata || null;
    }
    return ResumableUploadStatus2;
  }()
);
function checkResumeHeader_(xhr, allowed) {
  var status = null;
  try {
    status = xhr.getResponseHeader("X-Goog-Upload-Status");
  } catch (e) {
    handlerCheck(false);
  }
  var allowedStatus = allowed || ["active"];
  handlerCheck(!!status && allowedStatus.indexOf(status) !== -1);
  return status;
}
function createResumableUpload(service, location, mappings, blob, metadata) {
  var urlPart = location.bucketOnlyServerUrl();
  var metadataForUpload = metadataForUpload_(location, blob, metadata);
  var urlParams = { name: metadataForUpload["fullPath"] };
  var url = makeUrl(urlPart);
  var method = "POST";
  var headers = {
    "X-Goog-Upload-Protocol": "resumable",
    "X-Goog-Upload-Command": "start",
    "X-Goog-Upload-Header-Content-Length": blob.size(),
    "X-Goog-Upload-Header-Content-Type": metadataForUpload["contentType"],
    "Content-Type": "application/json; charset=utf-8"
  };
  var body = toResourceString(metadataForUpload, mappings);
  var timeout = service.maxUploadRetryTime;
  function handler(xhr) {
    checkResumeHeader_(xhr);
    var url2;
    try {
      url2 = xhr.getResponseHeader("X-Goog-Upload-URL");
    } catch (e) {
      handlerCheck(false);
    }
    handlerCheck(isString(url2));
    return url2;
  }
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.headers = headers;
  requestInfo.body = body;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
function getResumableUploadStatus(service, location, url, blob) {
  var headers = { "X-Goog-Upload-Command": "query" };
  function handler(xhr) {
    var status = checkResumeHeader_(xhr, ["active", "final"]);
    var sizeString = null;
    try {
      sizeString = xhr.getResponseHeader("X-Goog-Upload-Size-Received");
    } catch (e) {
      handlerCheck(false);
    }
    if (!sizeString) {
      handlerCheck(false);
    }
    var size = Number(sizeString);
    handlerCheck(!isNaN(size));
    return new ResumableUploadStatus(size, blob.size(), status === "final");
  }
  var method = "POST";
  var timeout = service.maxUploadRetryTime;
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.headers = headers;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
var RESUMABLE_UPLOAD_CHUNK_SIZE = 256 * 1024;
function continueResumableUpload(location, service, url, blob, chunkSize, mappings, status, progressCallback) {
  var status_ = new ResumableUploadStatus(0, 0);
  if (status) {
    status_.current = status.current;
    status_.total = status.total;
  } else {
    status_.current = 0;
    status_.total = blob.size();
  }
  if (blob.size() !== status_.total) {
    throw serverFileWrongSize();
  }
  var bytesLeft = status_.total - status_.current;
  var bytesToUpload = bytesLeft;
  if (chunkSize > 0) {
    bytesToUpload = Math.min(bytesToUpload, chunkSize);
  }
  var startByte = status_.current;
  var endByte = startByte + bytesToUpload;
  var uploadCommand = bytesToUpload === bytesLeft ? "upload, finalize" : "upload";
  var headers = {
    "X-Goog-Upload-Command": uploadCommand,
    "X-Goog-Upload-Offset": status_.current
  };
  var body = blob.slice(startByte, endByte);
  if (body === null) {
    throw cannotSliceBlob();
  }
  function handler(xhr, text) {
    var uploadStatus = checkResumeHeader_(xhr, ["active", "final"]);
    var newCurrent = status_.current + bytesToUpload;
    var size = blob.size();
    var metadata;
    if (uploadStatus === "final") {
      metadata = metadataHandler(service, mappings)(xhr, text);
    } else {
      metadata = null;
    }
    return new ResumableUploadStatus(newCurrent, size, uploadStatus === "final", metadata);
  }
  var method = "POST";
  var timeout = service.maxUploadRetryTime;
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.headers = headers;
  requestInfo.body = body.uploadData();
  requestInfo.progressCallback = progressCallback || null;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
var Observer = (
  /** @class */
  function() {
    function Observer2(nextOrObserver, error, complete) {
      var asFunctions = isFunction(nextOrObserver) || error != null || complete != null;
      if (asFunctions) {
        this.next = nextOrObserver;
        this.error = error;
        this.complete = complete;
      } else {
        var observer = nextOrObserver;
        this.next = observer.next;
        this.error = observer.error;
        this.complete = observer.complete;
      }
    }
    return Observer2;
  }()
);
function async(f) {
  return function() {
    var argsToForward = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      argsToForward[_i] = arguments[_i];
    }
    Promise.resolve().then(function() {
      return f.apply(void 0, argsToForward);
    });
  };
}
var UploadTask = (
  /** @class */
  function() {
    function UploadTask2(ref2, blob, metadata) {
      var _this = this;
      if (metadata === void 0) {
        metadata = null;
      }
      this._transferred = 0;
      this._needToFetchStatus = false;
      this._needToFetchMetadata = false;
      this._observers = [];
      this._error = void 0;
      this._uploadUrl = void 0;
      this._request = void 0;
      this._chunkMultiplier = 1;
      this._resolve = void 0;
      this._reject = void 0;
      this._ref = ref2;
      this._blob = blob;
      this._metadata = metadata;
      this._mappings = getMappings();
      this._resumable = this._shouldDoResumable(this._blob);
      this._state = "running";
      this._errorHandler = function(error) {
        _this._request = void 0;
        _this._chunkMultiplier = 1;
        if (error._codeEquals(
          "canceled"
          /* CANCELED */
        )) {
          _this._needToFetchStatus = true;
          _this.completeTransitions_();
        } else {
          _this._error = error;
          _this._transition(
            "error"
            /* ERROR */
          );
        }
      };
      this._metadataErrorHandler = function(error) {
        _this._request = void 0;
        if (error._codeEquals(
          "canceled"
          /* CANCELED */
        )) {
          _this.completeTransitions_();
        } else {
          _this._error = error;
          _this._transition(
            "error"
            /* ERROR */
          );
        }
      };
      this._promise = new Promise(function(resolve, reject) {
        _this._resolve = resolve;
        _this._reject = reject;
        _this._start();
      });
      this._promise.then(null, function() {
      });
    }
    UploadTask2.prototype._makeProgressCallback = function() {
      var _this = this;
      var sizeBefore = this._transferred;
      return function(loaded) {
        return _this._updateProgress(sizeBefore + loaded);
      };
    };
    UploadTask2.prototype._shouldDoResumable = function(blob) {
      return blob.size() > 256 * 1024;
    };
    UploadTask2.prototype._start = function() {
      if (this._state !== "running") {
        return;
      }
      if (this._request !== void 0) {
        return;
      }
      if (this._resumable) {
        if (this._uploadUrl === void 0) {
          this._createResumable();
        } else {
          if (this._needToFetchStatus) {
            this._fetchStatus();
          } else {
            if (this._needToFetchMetadata) {
              this._fetchMetadata();
            } else {
              this._continueUpload();
            }
          }
        }
      } else {
        this._oneShotUpload();
      }
    };
    UploadTask2.prototype._resolveToken = function(callback) {
      var _this = this;
      this._ref.storage._getAuthToken().then(function(authToken) {
        switch (_this._state) {
          case "running":
            callback(authToken);
            break;
          case "canceling":
            _this._transition(
              "canceled"
              /* CANCELED */
            );
            break;
          case "pausing":
            _this._transition(
              "paused"
              /* PAUSED */
            );
            break;
        }
      });
    };
    UploadTask2.prototype._createResumable = function() {
      var _this = this;
      this._resolveToken(function(authToken) {
        var requestInfo = createResumableUpload(_this._ref.storage, _this._ref._location, _this._mappings, _this._blob, _this._metadata);
        var createRequest = _this._ref.storage._makeRequest(requestInfo, authToken);
        _this._request = createRequest;
        createRequest.getPromise().then(function(url) {
          _this._request = void 0;
          _this._uploadUrl = url;
          _this._needToFetchStatus = false;
          _this.completeTransitions_();
        }, _this._errorHandler);
      });
    };
    UploadTask2.prototype._fetchStatus = function() {
      var _this = this;
      var url = this._uploadUrl;
      this._resolveToken(function(authToken) {
        var requestInfo = getResumableUploadStatus(_this._ref.storage, _this._ref._location, url, _this._blob);
        var statusRequest = _this._ref.storage._makeRequest(requestInfo, authToken);
        _this._request = statusRequest;
        statusRequest.getPromise().then(function(status) {
          status = status;
          _this._request = void 0;
          _this._updateProgress(status.current);
          _this._needToFetchStatus = false;
          if (status.finalized) {
            _this._needToFetchMetadata = true;
          }
          _this.completeTransitions_();
        }, _this._errorHandler);
      });
    };
    UploadTask2.prototype._continueUpload = function() {
      var _this = this;
      var chunkSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
      var status = new ResumableUploadStatus(this._transferred, this._blob.size());
      var url = this._uploadUrl;
      this._resolveToken(function(authToken) {
        var requestInfo;
        try {
          requestInfo = continueResumableUpload(_this._ref._location, _this._ref.storage, url, _this._blob, chunkSize, _this._mappings, status, _this._makeProgressCallback());
        } catch (e) {
          _this._error = e;
          _this._transition(
            "error"
            /* ERROR */
          );
          return;
        }
        var uploadRequest = _this._ref.storage._makeRequest(requestInfo, authToken);
        _this._request = uploadRequest;
        uploadRequest.getPromise().then(function(newStatus) {
          _this._increaseMultiplier();
          _this._request = void 0;
          _this._updateProgress(newStatus.current);
          if (newStatus.finalized) {
            _this._metadata = newStatus.metadata;
            _this._transition(
              "success"
              /* SUCCESS */
            );
          } else {
            _this.completeTransitions_();
          }
        }, _this._errorHandler);
      });
    };
    UploadTask2.prototype._increaseMultiplier = function() {
      var currentSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
      if (currentSize < 32 * 1024 * 1024) {
        this._chunkMultiplier *= 2;
      }
    };
    UploadTask2.prototype._fetchMetadata = function() {
      var _this = this;
      this._resolveToken(function(authToken) {
        var requestInfo = getMetadata(_this._ref.storage, _this._ref._location, _this._mappings);
        var metadataRequest = _this._ref.storage._makeRequest(requestInfo, authToken);
        _this._request = metadataRequest;
        metadataRequest.getPromise().then(function(metadata) {
          _this._request = void 0;
          _this._metadata = metadata;
          _this._transition(
            "success"
            /* SUCCESS */
          );
        }, _this._metadataErrorHandler);
      });
    };
    UploadTask2.prototype._oneShotUpload = function() {
      var _this = this;
      this._resolveToken(function(authToken) {
        var requestInfo = multipartUpload(_this._ref.storage, _this._ref._location, _this._mappings, _this._blob, _this._metadata);
        var multipartRequest = _this._ref.storage._makeRequest(requestInfo, authToken);
        _this._request = multipartRequest;
        multipartRequest.getPromise().then(function(metadata) {
          _this._request = void 0;
          _this._metadata = metadata;
          _this._updateProgress(_this._blob.size());
          _this._transition(
            "success"
            /* SUCCESS */
          );
        }, _this._errorHandler);
      });
    };
    UploadTask2.prototype._updateProgress = function(transferred) {
      var old = this._transferred;
      this._transferred = transferred;
      if (this._transferred !== old) {
        this._notifyObservers();
      }
    };
    UploadTask2.prototype._transition = function(state) {
      if (this._state === state) {
        return;
      }
      switch (state) {
        case "canceling":
          this._state = state;
          if (this._request !== void 0) {
            this._request.cancel();
          }
          break;
        case "pausing":
          this._state = state;
          if (this._request !== void 0) {
            this._request.cancel();
          }
          break;
        case "running":
          var wasPaused = this._state === "paused";
          this._state = state;
          if (wasPaused) {
            this._notifyObservers();
            this._start();
          }
          break;
        case "paused":
          this._state = state;
          this._notifyObservers();
          break;
        case "canceled":
          this._error = canceled();
          this._state = state;
          this._notifyObservers();
          break;
        case "error":
          this._state = state;
          this._notifyObservers();
          break;
        case "success":
          this._state = state;
          this._notifyObservers();
          break;
      }
    };
    UploadTask2.prototype.completeTransitions_ = function() {
      switch (this._state) {
        case "pausing":
          this._transition(
            "paused"
            /* PAUSED */
          );
          break;
        case "canceling":
          this._transition(
            "canceled"
            /* CANCELED */
          );
          break;
        case "running":
          this._start();
          break;
      }
    };
    Object.defineProperty(UploadTask2.prototype, "snapshot", {
      /**
       * A snapshot of the current task state.
       */
      get: function() {
        var externalState = taskStateFromInternalTaskState(this._state);
        return {
          bytesTransferred: this._transferred,
          totalBytes: this._blob.size(),
          state: externalState,
          metadata: this._metadata,
          task: this,
          ref: this._ref
        };
      },
      enumerable: false,
      configurable: true
    });
    UploadTask2.prototype.on = function(type, nextOrObserver, error, completed) {
      var _this = this;
      var observer = new Observer(nextOrObserver, error, completed);
      this._addObserver(observer);
      return function() {
        _this._removeObserver(observer);
      };
    };
    UploadTask2.prototype.then = function(onFulfilled, onRejected) {
      return this._promise.then(onFulfilled, onRejected);
    };
    UploadTask2.prototype.catch = function(onRejected) {
      return this.then(null, onRejected);
    };
    UploadTask2.prototype._addObserver = function(observer) {
      this._observers.push(observer);
      this._notifyObserver(observer);
    };
    UploadTask2.prototype._removeObserver = function(observer) {
      var i = this._observers.indexOf(observer);
      if (i !== -1) {
        this._observers.splice(i, 1);
      }
    };
    UploadTask2.prototype._notifyObservers = function() {
      var _this = this;
      this._finishPromise();
      var observers = this._observers.slice();
      observers.forEach(function(observer) {
        _this._notifyObserver(observer);
      });
    };
    UploadTask2.prototype._finishPromise = function() {
      if (this._resolve !== void 0) {
        var triggered = true;
        switch (taskStateFromInternalTaskState(this._state)) {
          case TaskState.SUCCESS:
            async(this._resolve.bind(null, this.snapshot))();
            break;
          case TaskState.CANCELED:
          case TaskState.ERROR:
            var toCall = this._reject;
            async(toCall.bind(null, this._error))();
            break;
          default:
            triggered = false;
            break;
        }
        if (triggered) {
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
    };
    UploadTask2.prototype._notifyObserver = function(observer) {
      var externalState = taskStateFromInternalTaskState(this._state);
      switch (externalState) {
        case TaskState.RUNNING:
        case TaskState.PAUSED:
          if (observer.next) {
            async(observer.next.bind(observer, this.snapshot))();
          }
          break;
        case TaskState.SUCCESS:
          if (observer.complete) {
            async(observer.complete.bind(observer))();
          }
          break;
        case TaskState.CANCELED:
        case TaskState.ERROR:
          if (observer.error) {
            async(observer.error.bind(observer, this._error))();
          }
          break;
        default:
          if (observer.error) {
            async(observer.error.bind(observer, this._error))();
          }
      }
    };
    UploadTask2.prototype.resume = function() {
      var valid = this._state === "paused" || this._state === "pausing";
      if (valid) {
        this._transition(
          "running"
          /* RUNNING */
        );
      }
      return valid;
    };
    UploadTask2.prototype.pause = function() {
      var valid = this._state === "running";
      if (valid) {
        this._transition(
          "pausing"
          /* PAUSING */
        );
      }
      return valid;
    };
    UploadTask2.prototype.cancel = function() {
      var valid = this._state === "running" || this._state === "pausing";
      if (valid) {
        this._transition(
          "canceling"
          /* CANCELING */
        );
      }
      return valid;
    };
    return UploadTask2;
  }()
);
var Reference = (
  /** @class */
  function() {
    function Reference2(_service, location) {
      this._service = _service;
      if (location instanceof Location) {
        this._location = location;
      } else {
        this._location = Location.makeFromUrl(location);
      }
    }
    Reference2.prototype.toString = function() {
      return "gs://" + this._location.bucket + "/" + this._location.path;
    };
    Reference2.prototype._newRef = function(service, location) {
      return new Reference2(service, location);
    };
    Object.defineProperty(Reference2.prototype, "root", {
      /**
       * A reference to the root of this object's bucket.
       */
      get: function() {
        var location = new Location(this._location.bucket, "");
        return this._newRef(this._service, location);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference2.prototype, "bucket", {
      /**
       * The name of the bucket containing this reference's object.
       */
      get: function() {
        return this._location.bucket;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference2.prototype, "fullPath", {
      /**
       * The full path of this object.
       */
      get: function() {
        return this._location.path;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference2.prototype, "name", {
      /**
       * The short name of this object, which is the last component of the full path.
       * For example, if fullPath is 'full/path/image.png', name is 'image.png'.
       */
      get: function() {
        return lastComponent(this._location.path);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference2.prototype, "storage", {
      /**
       * The `StorageService` instance this `StorageReference` is associated with.
       */
      get: function() {
        return this._service;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference2.prototype, "parent", {
      /**
       * A `StorageReference` pointing to the parent location of this `StorageReference`, or null if
       * this reference is the root.
       */
      get: function() {
        var newPath = parent(this._location.path);
        if (newPath === null) {
          return null;
        }
        var location = new Location(this._location.bucket, newPath);
        return new Reference2(this._service, location);
      },
      enumerable: false,
      configurable: true
    });
    Reference2.prototype._throwIfRoot = function(name2) {
      if (this._location.path === "") {
        throw invalidRootOperation(name2);
      }
    };
    return Reference2;
  }()
);
function uploadBytesResumable(ref2, data, metadata) {
  ref2._throwIfRoot("uploadBytesResumable");
  return new UploadTask(ref2, new FbsBlob(data), metadata);
}
function listAll(ref2) {
  var accumulator = {
    prefixes: [],
    items: []
  };
  return listAllHelper(ref2, accumulator).then(function() {
    return accumulator;
  });
}
function listAllHelper(ref2, accumulator, pageToken) {
  return __awaiter(this, void 0, void 0, function() {
    var opt, nextPage;
    var _a, _b;
    return __generator(this, function(_c) {
      switch (_c.label) {
        case 0:
          opt = {
            // maxResults is 1000 by default.
            pageToken
          };
          return [4, list$1(ref2, opt)];
        case 1:
          nextPage = _c.sent();
          (_a = accumulator.prefixes).push.apply(_a, nextPage.prefixes);
          (_b = accumulator.items).push.apply(_b, nextPage.items);
          if (!(nextPage.nextPageToken != null))
            return [3, 3];
          return [4, listAllHelper(ref2, accumulator, nextPage.nextPageToken)];
        case 2:
          _c.sent();
          _c.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function list$1(ref2, options) {
  return __awaiter(this, void 0, void 0, function() {
    var authToken, op, requestInfo;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          if (options != null) {
            if (typeof options.maxResults === "number") {
              validateNumber(
                "options.maxResults",
                /* minValue= */
                1,
                /* maxValue= */
                1e3,
                options.maxResults
              );
            }
          }
          return [4, ref2.storage._getAuthToken()];
        case 1:
          authToken = _a.sent();
          op = options || {};
          requestInfo = list(
            ref2.storage,
            ref2._location,
            /*delimiter= */
            "/",
            op.pageToken,
            op.maxResults
          );
          return [2, ref2.storage._makeRequest(requestInfo, authToken).getPromise()];
      }
    });
  });
}
function getMetadata$1(ref2) {
  return __awaiter(this, void 0, void 0, function() {
    var authToken, requestInfo;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          ref2._throwIfRoot("getMetadata");
          return [4, ref2.storage._getAuthToken()];
        case 1:
          authToken = _a.sent();
          requestInfo = getMetadata(ref2.storage, ref2._location, getMappings());
          return [2, ref2.storage._makeRequest(requestInfo, authToken).getPromise()];
      }
    });
  });
}
function updateMetadata$1(ref2, metadata) {
  return __awaiter(this, void 0, void 0, function() {
    var authToken, requestInfo;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          ref2._throwIfRoot("updateMetadata");
          return [4, ref2.storage._getAuthToken()];
        case 1:
          authToken = _a.sent();
          requestInfo = updateMetadata(ref2.storage, ref2._location, metadata, getMappings());
          return [2, ref2.storage._makeRequest(requestInfo, authToken).getPromise()];
      }
    });
  });
}
function getDownloadURL(ref2) {
  return __awaiter(this, void 0, void 0, function() {
    var authToken, requestInfo;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          ref2._throwIfRoot("getDownloadURL");
          return [4, ref2.storage._getAuthToken()];
        case 1:
          authToken = _a.sent();
          requestInfo = getDownloadUrl(ref2.storage, ref2._location, getMappings());
          return [2, ref2.storage._makeRequest(requestInfo, authToken).getPromise().then(function(url) {
            if (url === null) {
              throw noDownloadURL();
            }
            return url;
          })];
      }
    });
  });
}
function deleteObject$1(ref2) {
  return __awaiter(this, void 0, void 0, function() {
    var authToken, requestInfo;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          ref2._throwIfRoot("deleteObject");
          return [4, ref2.storage._getAuthToken()];
        case 1:
          authToken = _a.sent();
          requestInfo = deleteObject(ref2.storage, ref2._location);
          return [2, ref2.storage._makeRequest(requestInfo, authToken).getPromise()];
      }
    });
  });
}
function _getChild(ref2, childPath) {
  var newPath = child(ref2._location.path, childPath);
  var location = new Location(ref2._location.bucket, newPath);
  return new Reference(ref2.storage, location);
}
function isUrl(path) {
  return /^[A-Za-z]+:\/\//.test(path);
}
function refFromURL(service, url) {
  return new Reference(service, url);
}
function refFromPath(ref2, path) {
  if (ref2 instanceof StorageService) {
    var service = ref2;
    if (service._bucket == null) {
      throw noDefaultBucket();
    }
    var reference = new Reference(service, service._bucket);
    if (path != null) {
      return refFromPath(reference, path);
    } else {
      return reference;
    }
  } else {
    if (path !== void 0) {
      if (path.includes("..")) {
        throw invalidArgument('`path` param cannot contain ".."');
      }
      return _getChild(ref2, path);
    } else {
      return ref2;
    }
  }
}
function ref(serviceOrRef, pathOrUrl) {
  if (pathOrUrl && isUrl(pathOrUrl)) {
    if (serviceOrRef instanceof StorageService) {
      return refFromURL(serviceOrRef, pathOrUrl);
    } else {
      throw invalidArgument("To use ref(service, url), the first argument must be a Storage instance.");
    }
  } else {
    return refFromPath(serviceOrRef, pathOrUrl);
  }
}
function extractBucket(config) {
  var bucketString = config === null || config === void 0 ? void 0 : config[CONFIG_STORAGE_BUCKET_KEY];
  if (bucketString == null) {
    return null;
  }
  return Location.makeFromBucketSpec(bucketString);
}
var StorageService = (
  /** @class */
  function() {
    function StorageService2(app, _authProvider, _pool, _url, _firebaseVersion) {
      this.app = app;
      this._authProvider = _authProvider;
      this._pool = _pool;
      this._url = _url;
      this._firebaseVersion = _firebaseVersion;
      this._bucket = null;
      this._appId = null;
      this._deleted = false;
      this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;
      this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;
      this._requests = /* @__PURE__ */ new Set();
      if (_url != null) {
        this._bucket = Location.makeFromBucketSpec(_url);
      } else {
        this._bucket = extractBucket(this.app.options);
      }
    }
    Object.defineProperty(StorageService2.prototype, "maxUploadRetryTime", {
      /**
       * The maximum time to retry uploads in milliseconds.
       */
      get: function() {
        return this._maxUploadRetryTime;
      },
      set: function(time) {
        validateNumber(
          "time",
          /* minValue=*/
          0,
          /* maxValue= */
          Number.POSITIVE_INFINITY,
          time
        );
        this._maxUploadRetryTime = time;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(StorageService2.prototype, "maxOperationRetryTime", {
      /**
       * The maximum time to retry operations other than uploads or downloads in
       * milliseconds.
       */
      get: function() {
        return this._maxOperationRetryTime;
      },
      set: function(time) {
        validateNumber(
          "time",
          /* minValue=*/
          0,
          /* maxValue= */
          Number.POSITIVE_INFINITY,
          time
        );
        this._maxOperationRetryTime = time;
      },
      enumerable: false,
      configurable: true
    });
    StorageService2.prototype._getAuthToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        var auth, tokenData;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              auth = this._authProvider.getImmediate({ optional: true });
              if (!auth)
                return [3, 2];
              return [4, auth.getToken()];
            case 1:
              tokenData = _a.sent();
              if (tokenData !== null) {
                return [2, tokenData.accessToken];
              }
              _a.label = 2;
            case 2:
              return [2, null];
          }
        });
      });
    };
    StorageService2.prototype._delete = function() {
      this._deleted = true;
      this._requests.forEach(function(request) {
        return request.cancel();
      });
      this._requests.clear();
      return Promise.resolve();
    };
    StorageService2.prototype._makeStorageReference = function(loc) {
      return new Reference(this, loc);
    };
    StorageService2.prototype._makeRequest = function(requestInfo, authToken) {
      var _this = this;
      if (!this._deleted) {
        var request_1 = makeRequest(requestInfo, this._appId, authToken, this._pool, this._firebaseVersion);
        this._requests.add(request_1);
        request_1.getPromise().then(function() {
          return _this._requests.delete(request_1);
        }, function() {
          return _this._requests.delete(request_1);
        });
        return request_1;
      } else {
        return new FailRequest(appDeleted());
      }
    };
    return StorageService2;
  }()
);
function uploadBytesResumable$1(ref2, data, metadata) {
  ref2 = getModularInstance(ref2);
  return uploadBytesResumable(ref2, data, metadata);
}
function getMetadata$2(ref2) {
  ref2 = getModularInstance(ref2);
  return getMetadata$1(ref2);
}
function updateMetadata$2(ref2, metadata) {
  ref2 = getModularInstance(ref2);
  return updateMetadata$1(ref2, metadata);
}
function list$2(ref2, options) {
  ref2 = getModularInstance(ref2);
  return list$1(ref2, options);
}
function listAll$1(ref2) {
  ref2 = getModularInstance(ref2);
  return listAll(ref2);
}
function getDownloadURL$1(ref2) {
  ref2 = getModularInstance(ref2);
  return getDownloadURL(ref2);
}
function deleteObject$2(ref2) {
  ref2 = getModularInstance(ref2);
  return deleteObject$1(ref2);
}
function ref$1(serviceOrRef, pathOrUrl) {
  serviceOrRef = getModularInstance(serviceOrRef);
  return ref(serviceOrRef, pathOrUrl);
}
function _getChild$1(ref2, childPath) {
  return _getChild(ref2, childPath);
}
var UploadTaskSnapshotCompat = (
  /** @class */
  function() {
    function UploadTaskSnapshotCompat2(_delegate, task, ref2) {
      this._delegate = _delegate;
      this.task = task;
      this.ref = ref2;
    }
    Object.defineProperty(UploadTaskSnapshotCompat2.prototype, "bytesTransferred", {
      get: function() {
        return this._delegate.bytesTransferred;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(UploadTaskSnapshotCompat2.prototype, "metadata", {
      get: function() {
        return this._delegate.metadata;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(UploadTaskSnapshotCompat2.prototype, "state", {
      get: function() {
        return this._delegate.state;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(UploadTaskSnapshotCompat2.prototype, "totalBytes", {
      get: function() {
        return this._delegate.totalBytes;
      },
      enumerable: false,
      configurable: true
    });
    return UploadTaskSnapshotCompat2;
  }()
);
var UploadTaskCompat = (
  /** @class */
  function() {
    function UploadTaskCompat2(_delegate, _ref) {
      this._delegate = _delegate;
      this._ref = _ref;
      this.cancel = this._delegate.cancel.bind(this._delegate);
      this.catch = this._delegate.catch.bind(this._delegate);
      this.pause = this._delegate.pause.bind(this._delegate);
      this.resume = this._delegate.resume.bind(this._delegate);
    }
    Object.defineProperty(UploadTaskCompat2.prototype, "snapshot", {
      get: function() {
        return new UploadTaskSnapshotCompat(this._delegate.snapshot, this, this._ref);
      },
      enumerable: false,
      configurable: true
    });
    UploadTaskCompat2.prototype.then = function(onFulfilled, onRejected) {
      var _this = this;
      return this._delegate.then(function(snapshot) {
        if (onFulfilled) {
          return onFulfilled(new UploadTaskSnapshotCompat(snapshot, _this, _this._ref));
        }
      }, onRejected);
    };
    UploadTaskCompat2.prototype.on = function(type, nextOrObserver, error, completed) {
      var _this = this;
      var wrappedNextOrObserver = void 0;
      if (!!nextOrObserver) {
        if (typeof nextOrObserver === "function") {
          wrappedNextOrObserver = function(taskSnapshot) {
            return nextOrObserver(new UploadTaskSnapshotCompat(taskSnapshot, _this, _this._ref));
          };
        } else {
          wrappedNextOrObserver = {
            next: !!nextOrObserver.next ? function(taskSnapshot) {
              return nextOrObserver.next(new UploadTaskSnapshotCompat(taskSnapshot, _this, _this._ref));
            } : void 0,
            complete: nextOrObserver.complete || void 0,
            error: nextOrObserver.error || void 0
          };
        }
      }
      return this._delegate.on(type, wrappedNextOrObserver, error || void 0, completed || void 0);
    };
    return UploadTaskCompat2;
  }()
);
var ListResultCompat = (
  /** @class */
  function() {
    function ListResultCompat2(_delegate, _service) {
      this._delegate = _delegate;
      this._service = _service;
    }
    Object.defineProperty(ListResultCompat2.prototype, "prefixes", {
      get: function() {
        var _this = this;
        return this._delegate.prefixes.map(function(ref2) {
          return new ReferenceCompat(ref2, _this._service);
        });
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ListResultCompat2.prototype, "items", {
      get: function() {
        var _this = this;
        return this._delegate.items.map(function(ref2) {
          return new ReferenceCompat(ref2, _this._service);
        });
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ListResultCompat2.prototype, "nextPageToken", {
      get: function() {
        return this._delegate.nextPageToken || null;
      },
      enumerable: false,
      configurable: true
    });
    return ListResultCompat2;
  }()
);
var ReferenceCompat = (
  /** @class */
  function() {
    function ReferenceCompat2(_delegate, storage) {
      this._delegate = _delegate;
      this.storage = storage;
    }
    Object.defineProperty(ReferenceCompat2.prototype, "name", {
      get: function() {
        return this._delegate.name;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReferenceCompat2.prototype, "bucket", {
      get: function() {
        return this._delegate.bucket;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReferenceCompat2.prototype, "fullPath", {
      get: function() {
        return this._delegate.fullPath;
      },
      enumerable: false,
      configurable: true
    });
    ReferenceCompat2.prototype.toString = function() {
      return this._delegate.toString();
    };
    ReferenceCompat2.prototype.child = function(childPath) {
      var reference = _getChild$1(this._delegate, childPath);
      return new ReferenceCompat2(reference, this.storage);
    };
    Object.defineProperty(ReferenceCompat2.prototype, "root", {
      get: function() {
        return new ReferenceCompat2(this._delegate.root, this.storage);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReferenceCompat2.prototype, "parent", {
      /**
       * @returns A reference to the parent of the
       * current object, or null if the current object is the root.
       */
      get: function() {
        var reference = this._delegate.parent;
        if (reference == null) {
          return null;
        }
        return new ReferenceCompat2(reference, this.storage);
      },
      enumerable: false,
      configurable: true
    });
    ReferenceCompat2.prototype.put = function(data, metadata) {
      this._throwIfRoot("put");
      return new UploadTaskCompat(uploadBytesResumable$1(this._delegate, data, metadata), this);
    };
    ReferenceCompat2.prototype.putString = function(value, format, metadata) {
      if (format === void 0) {
        format = StringFormat.RAW;
      }
      this._throwIfRoot("putString");
      var data = dataFromString(format, value);
      var metadataClone = __assign({}, metadata);
      if (metadataClone["contentType"] == null && data.contentType != null) {
        metadataClone["contentType"] = data.contentType;
      }
      return new UploadTaskCompat(new UploadTask(this._delegate, new FbsBlob(data.data, true), metadataClone), this);
    };
    ReferenceCompat2.prototype.listAll = function() {
      var _this = this;
      return listAll$1(this._delegate).then(function(r) {
        return new ListResultCompat(r, _this.storage);
      });
    };
    ReferenceCompat2.prototype.list = function(options) {
      var _this = this;
      return list$2(this._delegate, options || void 0).then(function(r) {
        return new ListResultCompat(r, _this.storage);
      });
    };
    ReferenceCompat2.prototype.getMetadata = function() {
      return getMetadata$2(this._delegate);
    };
    ReferenceCompat2.prototype.updateMetadata = function(metadata) {
      return updateMetadata$2(this._delegate, metadata);
    };
    ReferenceCompat2.prototype.getDownloadURL = function() {
      return getDownloadURL$1(this._delegate);
    };
    ReferenceCompat2.prototype.delete = function() {
      this._throwIfRoot("delete");
      return deleteObject$2(this._delegate);
    };
    ReferenceCompat2.prototype._throwIfRoot = function(name2) {
      if (this._delegate._location.path === "") {
        throw invalidRootOperation(name2);
      }
    };
    return ReferenceCompat2;
  }()
);
var StorageServiceCompat = (
  /** @class */
  function() {
    function StorageServiceCompat2(app, _delegate) {
      var _this = this;
      this.app = app;
      this._delegate = _delegate;
      this.INTERNAL = {
        /**
         * Called when the associated app is deleted.
         */
        delete: function() {
          return _this._delegate._delete();
        }
      };
    }
    Object.defineProperty(StorageServiceCompat2.prototype, "maxOperationRetryTime", {
      get: function() {
        return this._delegate.maxOperationRetryTime;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(StorageServiceCompat2.prototype, "maxUploadRetryTime", {
      get: function() {
        return this._delegate.maxUploadRetryTime;
      },
      enumerable: false,
      configurable: true
    });
    StorageServiceCompat2.prototype.ref = function(path) {
      if (isUrl(path)) {
        throw invalidArgument("ref() expected a child path but got a URL, use refFromURL instead.");
      }
      return new ReferenceCompat(ref$1(this._delegate, path), this);
    };
    StorageServiceCompat2.prototype.refFromURL = function(url) {
      if (!isUrl(url)) {
        throw invalidArgument("refFromURL() expected a full URL but got a child path, use ref() instead.");
      }
      try {
        Location.makeFromUrl(url);
      } catch (e) {
        throw invalidArgument("refFromUrl() expected a valid full URL but got an invalid one.");
      }
      return new ReferenceCompat(ref$1(this._delegate, url), this);
    };
    StorageServiceCompat2.prototype.setMaxUploadRetryTime = function(time) {
      this._delegate.maxUploadRetryTime = time;
    };
    StorageServiceCompat2.prototype.setMaxOperationRetryTime = function(time) {
      this._delegate.maxOperationRetryTime = time;
    };
    return StorageServiceCompat2;
  }()
);
var name = "@firebase/storage";
var version = "0.4.7";
var STORAGE_TYPE = "storage";
function factory(container, _a) {
  var url = _a.instanceIdentifier;
  var app = container.getProvider("app").getImmediate();
  var authProvider = container.getProvider("auth-internal");
  var storageServiceCompat = new StorageServiceCompat(app, new StorageService(app, authProvider, new XhrIoPool(), url, index_esm_default.SDK_VERSION));
  return storageServiceCompat;
}
function registerStorage(instance) {
  var namespaceExports = {
    // no-inline
    TaskState,
    TaskEvent,
    StringFormat,
    Storage: StorageService,
    Reference: ReferenceCompat
  };
  instance.INTERNAL.registerComponent(new Component(
    STORAGE_TYPE,
    factory,
    "PUBLIC"
    /* PUBLIC */
  ).setServiceProps(namespaceExports).setMultipleInstances(true));
  instance.registerVersion(name, version);
}
registerStorage(index_esm_default);
/*! Bundled license information:

@firebase/storage/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *  http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=firebase_storage.js.map
