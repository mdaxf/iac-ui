{
  "version": 3,
  "sources": ["../../@excalidraw/laser-pointer/dist/src/index.ts", "../../@excalidraw/laser-pointer/dist/src/state.ts", "../../@excalidraw/laser-pointer/dist/src/math.ts", "../../@excalidraw/laser-pointer/dist/src/simplify.ts"],
  "sourcesContent": ["export * from './state'\nexport type { Point } from './math'\n", "import type { Point } from './math'\nimport * as m from './math'\nimport { douglasPeucker } from './simplify'\n\nexport type SizeMappingDetails = {\n  pressure: number\n  runningLength: number\n  currentIndex: number\n  totalLength: number\n}\n\nexport type LaserPointerOptions = {\n  size: number\n\n  streamline: number\n  simplify: number\n  simplifyPhase: 'tail' | 'output' | 'input'\n\n  sizeMapping: (details: SizeMappingDetails) => number\n}\n\nexport class LaserPointer {\n  static defaults: LaserPointerOptions = {\n    size: 2,\n    streamline: 0.45,\n    simplify: 0.1,\n    simplifyPhase: 'output',\n\n    sizeMapping: () => 1,\n  }\n\n  static constants = {\n    cornerDetectionMaxAngle: 120,\n    cornerDetectionVariance: (s: number) => (s > 35 ? 0.5 : 1),\n    maxTailLength: 50,\n  }\n\n  options: LaserPointerOptions\n  constructor(options: Partial<LaserPointerOptions>) {\n    this.options = Object.assign({}, LaserPointer.defaults, options)\n  }\n\n  originalPoints: Point[] = []\n\n  private stablePoints: Point[] = []\n  private tailPoints: Point[] = []\n\n  private isFresh = true\n\n  private get lastPoint(): Point {\n    return this.tailPoints[this.tailPoints.length - 1] ?? this.stablePoints[this.stablePoints.length - 1]\n  }\n\n  addPoint(point: Point) {\n    const lastPoint = this.originalPoints[this.originalPoints.length - 1]\n\n    if (lastPoint && lastPoint[0] === point[0] && lastPoint[1] === point[1]) {\n      return\n    }\n\n    this.originalPoints.push(point)\n\n    if (this.isFresh) {\n      this.isFresh = false\n      this.stablePoints.push(point)\n      return\n    }\n\n    if (this.options.streamline > 0) {\n      point = m.plerp(this.lastPoint, point, 1 - this.options.streamline)\n    }\n\n    this.tailPoints.push(point)\n\n    if (m.runLength(this.tailPoints) > LaserPointer.constants.maxTailLength) {\n      this.stabilizeTail()\n    }\n  }\n\n  close() {\n    this.stabilizeTail()\n  }\n\n  stabilizeTail() {\n    if (this.options.simplify > 0 && this.options.simplifyPhase == 'tail') {\n      throw new Error('Not implemented yet')\n    } else {\n      this.stablePoints.push(...this.tailPoints)\n      this.tailPoints = []\n    }\n  }\n\n  private getSize(\n    sizeOverride: number | undefined,\n    pressure: number,\n    index: number,\n    totalLength: number,\n    runningLength: number\n  ) {\n    return (\n      (sizeOverride ?? this.options.size) *\n      this.options.sizeMapping({\n        pressure: pressure,\n        runningLength: runningLength,\n        currentIndex: index,\n        totalLength: totalLength,\n      })\n    )\n  }\n\n  getStrokeOutline(sizeOverride?: number | undefined): Point[] {\n    if (this.isFresh) {\n      return []\n    }\n\n    let points = [...this.stablePoints, ...this.tailPoints]\n\n    if (this.options.simplify > 0 && this.options.simplifyPhase === 'input') {\n      points = douglasPeucker(points, this.options.simplify)\n    }\n\n    const len = points.length\n\n    if (len === 0) {\n      return []\n    }\n\n    if (len === 1) {\n      const c = points[0]\n\n      const ps: Point[] = []\n\n      for (let theta = 0; theta <= Math.PI * 2; theta += Math.PI / 16) {\n        ps.push(m.add(c, m.smul(m.rot([1, 0, 0] as Point, theta), this.getSize(sizeOverride, c[2], 0, len, 0))))\n      }\n\n      ps.push(m.add(c, m.smul([1, 0, 0] as Point, this.getSize(sizeOverride, c[2], 0, len, 0))))\n\n      return ps\n    }\n\n    if (len === 2) {\n      const c = points[0]\n      const n = points[1]\n\n      const ps: Point[] = []\n\n      const pAngle = m.angle(c, [c[0], c[1] - 100, c[2]] as Point, n)\n\n      for (let theta = pAngle; theta <= Math.PI + pAngle; theta += Math.PI / 16) {\n        ps.push(m.add(c, m.smul(m.rot([1, 0, 0] as Point, theta), this.getSize(sizeOverride, c[2], 0, len, 0))))\n      }\n\n      for (let theta = Math.PI + pAngle; theta <= Math.PI * 2 + pAngle; theta += Math.PI / 16) {\n        ps.push(m.add(n, m.smul(m.rot([1, 0, 0] as Point, theta), this.getSize(sizeOverride, n[2], 0, len, 0))))\n      }\n\n      ps.push(ps[0])\n\n      return ps\n    }\n\n    const forwardPoints: Point[] = []\n    const backwardPoints: Point[] = []\n\n    let speed = 0\n    let prevSpeed = 0\n\n    let visibleStartIndex = 0\n    let runningLength = 0\n\n    for (let i = 1; i < len - 1; i++) {\n      const p = points[i - 1],\n        c = points[i],\n        n = points[i + 1]\n\n      let pressure = c[2]\n\n      const d = m.dist(p, c)\n      runningLength += d\n      speed = prevSpeed + (d - prevSpeed) * 0.2\n\n      const cSize = this.getSize(sizeOverride, pressure, i, len, runningLength)\n\n      if (cSize === 0) {\n        visibleStartIndex = i + 1\n        continue\n      }\n\n      const dirPC = m.norm(m.sub(p, c))\n      const dirNC = m.norm(m.sub(n, c))\n      const p1dirPC = m.rot(dirPC, Math.PI / 2)\n      const p2dirPC = m.rot(dirPC, -Math.PI / 2)\n      const p1dirNC = m.rot(dirNC, Math.PI / 2)\n      const p2dirNC = m.rot(dirNC, -Math.PI / 2)\n\n      const p1PC = m.add(c, m.smul(p1dirPC, cSize))\n      const p2PC = m.add(c, m.smul(p2dirPC, cSize))\n      const p1NC = m.add(c, m.smul(p1dirNC, cSize))\n      const p2NC = m.add(c, m.smul(p2dirNC, cSize))\n\n      const ftdir = m.add(p1dirPC, p2dirNC)\n      const btdir = m.add(p2dirPC, p1dirNC)\n\n      const paPC = m.add(c, m.smul(m.mag(ftdir) === 0 ? dirPC : m.norm(ftdir), cSize))\n      const paNC = m.add(c, m.smul(m.mag(btdir) === 0 ? dirNC : m.norm(btdir), cSize))\n\n      const cAngle = m.normAngle(m.angle(c, p, n))\n      const D_ANGLE =\n        (LaserPointer.constants.cornerDetectionMaxAngle / 180) *\n        Math.PI *\n        LaserPointer.constants.cornerDetectionVariance(speed)\n\n      if (Math.abs(cAngle) < D_ANGLE) {\n        const tAngle = Math.abs(m.normAngle(Math.PI - cAngle)) // turn angle\n\n        if (tAngle === 0) {\n          continue\n        }\n\n        if (cAngle < 0) {\n          backwardPoints.push(p2PC, paNC)\n\n          for (let theta = 0; theta <= tAngle; theta += tAngle / 4) {\n            forwardPoints.push(m.add(c, m.rot(m.smul(p1dirPC, cSize), theta)))\n          }\n\n          for (let theta = tAngle; theta >= 0; theta -= tAngle / 4) {\n            backwardPoints.push(m.add(c, m.rot(m.smul(p1dirPC, cSize), theta)))\n          }\n\n          backwardPoints.push(paNC, p1NC)\n        } else {\n          forwardPoints.push(p1PC, paPC)\n\n          for (let theta = 0; theta <= tAngle; theta += tAngle / 4) {\n            backwardPoints.push(m.add(c, m.rot(m.smul(p1dirPC, -cSize), -theta)))\n          }\n\n          for (let theta = tAngle; theta >= 0; theta -= tAngle / 4) {\n            forwardPoints.push(m.add(c, m.rot(m.smul(p1dirPC, -cSize), -theta)))\n          }\n          forwardPoints.push(paPC, p2NC)\n        }\n      } else {\n        forwardPoints.push(paPC)\n        backwardPoints.push(paNC)\n      }\n\n      prevSpeed = speed\n    }\n\n    const first = points[visibleStartIndex]\n    const second = points[visibleStartIndex + 1]\n    const penultimate = points[len - 2]\n    const ultimate = points[len - 1]\n\n    if (visibleStartIndex >= len - 2) {\n      return []\n    }\n\n    const dirFS = m.norm(m.sub(second, first))\n    const dirPU = m.norm(m.sub(penultimate, ultimate))\n\n    const ppdirFS = m.rot(dirFS, -Math.PI / 2)\n    const ppdirPU = m.rot(dirPU, Math.PI / 2)\n\n    const startCapSize = this.getSize(sizeOverride, first[2], 0, len, 0)\n    const startCap: Point[] = []\n\n    const endCapSize = this.getSize(sizeOverride, penultimate[2], len - 2, len, runningLength)\n    const endCap: Point[] = []\n\n    for (let theta = 0; theta <= Math.PI; theta += Math.PI / 16) {\n      startCap.unshift(m.add(first, m.rot(m.smul(ppdirFS, startCapSize), -theta)))\n    }\n\n    startCap.unshift(m.add(first, m.smul(ppdirFS, -startCapSize)))\n\n    for (let theta = 0; theta <= Math.PI; theta += Math.PI / 16) {\n      endCap.push(m.add(ultimate, m.rot(m.smul(ppdirPU, -endCapSize), -theta)))\n    }\n\n    const strokeOutline = [...startCap, ...forwardPoints, ...endCap.reverse(), ...backwardPoints.reverse()]\n\n    if (startCap.length > 0) {\n      strokeOutline.push(startCap[0])\n    }\n\n    if (this.options.simplify > 0 && this.options.simplifyPhase === 'output') {\n      return douglasPeucker(strokeOutline, this.options.simplify)\n    }\n\n    return strokeOutline\n  }\n}\n", "export type Point = [x: number, y: number, r: number]\n\nexport function add([ax, ay, ar]: Point, [bx, by, br]: Point): Point {\n  return [ax + bx, ay + by, ar + br]\n}\n\nexport function sub([ax, ay, ar]: Point, [bx, by, br]: Point): Point {\n  return [ax - bx, ay - by, ar - br]\n}\n\nexport function smul([x, y, r]: Point, s: number): Point {\n  return [x * s, y * s, r * s]\n}\n\nexport function norm([x, y, r]: Point): Point {\n  return [x / Math.sqrt(x ** 2 + y ** 2), y / Math.sqrt(x ** 2 + y ** 2), r]\n}\n\nexport function rot([x, y, r]: Point, rad: number): Point {\n  return [Math.cos(rad) * x - Math.sin(rad) * y, Math.sin(rad) * x + Math.cos(rad) * y, r]\n}\n\nexport function plerp(a: Point, b: Point, t: number): Point {\n  return add(a, smul(sub(b, a), t))\n}\n\nexport function lerp(a: number, b: number, t: number): number {\n  return a + (b - a) * t\n}\n\nexport function angle(p: Point, p1: Point, p2: Point) {\n  return Math.atan2(p2[1] - p[1], p2[0] - p[0]) - Math.atan2(p1[1] - p[1], p1[0] - p[0])\n}\n\nexport function normAngle(a: number) {\n  return Math.atan2(Math.sin(a), Math.cos(a))\n}\n\nexport function mag([x, y]: Point) {\n  return Math.sqrt(x ** 2 + y ** 2)\n}\n\nexport function dist([ax, ay]: Point, [bx, by]: Point): number {\n  return Math.sqrt((bx - ax) ** 2 + (by - ay) ** 2)\n}\n\nexport function getCircleAndPerpendicularLineIntersectionsAtPoint(\n  point: Point,\n  direction: Point,\n  radius: number\n): [Point, Point] {\n  return [\n    add(point, smul(norm(rot(direction, Math.PI / 2)), radius)),\n    add(point, smul(norm(rot(direction, -Math.PI / 2)), radius)),\n  ]\n}\n\nexport function runLength(ps: Point[]): number {\n  if (ps.length < 2) return 0\n\n  let len = 0\n\n  for (let i = 1; i <= ps.length - 1; i++) {\n    len += dist(ps[i - 1], ps[i])\n  }\n\n  len += dist(ps[ps.length -2], ps[ps.length - 1])\n\n  return len\n}\n\nexport const clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(max, v))\n\nexport function distancePointToSegment(p3: Point, p1: Point, p2: Point) {\n  const sMag = dist(p1, p2)\n\n  if (sMag === 0) return dist(p3, p1)\n\n  const u = clamp(((p3[0] - p1[0]) * (p2[0] - p1[0]) + (p3[1] - p1[1]) * (p2[1] - p1[1])) / sMag ** 2, 0, 1)\n\n  const pi: Point = [p1[0] + u * (p2[0] - p1[0]), p1[1] + u * (p2[1] - p1[1]), p3[2]]\n\n  return dist(pi, p3)\n}\n", "import { Point, distancePointToSegment } from './math'\n\nexport function douglasPeucker(points: Point[], epsilon: number): Point[] {\n  if (epsilon === 0) {\n    return points\n  }\n\n  if (points.length <= 2) {\n    return points\n  }\n\n  const first = points[0]\n  const last = points[points.length - 1]\n\n  const [maxDistance, maxIndex] = points.reduce(\n    ([maxDistance, maxIndex], point, index) => {\n      const distance = distancePointToSegment(point, first, last)\n\n      return distance > maxDistance ? [distance, index] : [maxDistance, maxIndex]\n    },\n    [0, -1]\n  )\n\n  if (maxDistance >= epsilon) {\n    const maxIndexPoint = points[maxIndex]\n\n    return [\n      ...douglasPeucker([first, ...points.slice(1, maxIndex), maxIndexPoint], epsilon).slice(0, -1),\n      maxIndexPoint,\n      ...douglasPeucker([maxIndexPoint, ...points.slice(maxIndex, -1), last], epsilon).slice(1),\n    ]\n  } else {\n    return [first, last]\n  }\n}\n"],
  "mappings": "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",
  "names": ["maxDistance", "maxIndex"]
}
