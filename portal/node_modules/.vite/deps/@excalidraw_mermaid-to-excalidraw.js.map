{
  "version": 3,
  "sources": ["../../@excalidraw/markdown-to-text/dist/index.js", "../../@excalidraw/mermaid-to-excalidraw/dist/constants.js", "../../@excalidraw/mermaid-to-excalidraw/dist/converter/GraphConverter.js", "../../@excalidraw/mermaid-to-excalidraw/dist/interfaces.js", "../../@excalidraw/mermaid-to-excalidraw/dist/converter/helpers.js", "../../@excalidraw/mermaid-to-excalidraw/dist/converter/types/flowchart.js", "../../@excalidraw/mermaid-to-excalidraw/node_modules/nanoid/index.browser.js", "../../@excalidraw/mermaid-to-excalidraw/dist/converter/types/graphImage.js", "../../@excalidraw/mermaid-to-excalidraw/dist/converter/types/sequence.js", "../../@excalidraw/mermaid-to-excalidraw/dist/graphToExcalidraw.js", "../../mermaid/dist/mermaid.core.mjs", "../../@excalidraw/mermaid-to-excalidraw/dist/utils.js", "../../@excalidraw/mermaid-to-excalidraw/dist/parser/flowchart.js", "../../@excalidraw/mermaid-to-excalidraw/dist/parser/sequence.js", "../../@excalidraw/mermaid-to-excalidraw/dist/parseMermaid.js", "../../@excalidraw/mermaid-to-excalidraw/dist/index.js"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeMarkdown = void 0;\n/**\n * @function removeMarkdown\n *\n * @description\n * Parse the markdown and returns a string\n *\n * @param markdown - The markdown string to parse\n * @param options - The options for the function\n *\n * @returns The parsed plain text\n */\nvar removeMarkdown = function (markdown, options) {\n    if (options === void 0) { options = {\n        listUnicodeChar: \"\",\n    }; }\n    options = options || {};\n    options.listUnicodeChar = options.hasOwnProperty(\"listUnicodeChar\")\n        ? options.listUnicodeChar\n        : false;\n    options.stripListLeaders = options.hasOwnProperty(\"stripListLeaders\")\n        ? options.stripListLeaders\n        : true;\n    options.gfm = options.hasOwnProperty(\"gfm\") ? options.gfm : true;\n    options.useImgAltText = options.hasOwnProperty(\"useImgAltText\")\n        ? options.useImgAltText\n        : true;\n    options.preserveLinks = options.hasOwnProperty(\"preserveLinks\")\n        ? options.preserveLinks\n        : false;\n    var output = markdown || \"\";\n    // Remove horizontal rules (stripListHeaders conflict with this rule, which is why it has been moved to the top)\n    output = output.replace(/^(-\\s*?|\\*\\s*?|_\\s*?){3,}\\s*$/gm, \"\");\n    try {\n        if (options.stripListLeaders) {\n            if (options.listUnicodeChar)\n                output = output.replace(/^([\\s\\t]*)([\\*\\-\\+]|\\d+\\.)\\s+/gm, options.listUnicodeChar + \" $1\");\n            else\n                output = output.replace(/^([\\s\\t]*)([\\*\\-\\+]|\\d+\\.)\\s+/gm, \"$1\");\n        }\n        if (options.gfm) {\n            output = output\n                // Header\n                .replace(/\\n={2,}/g, \"\\n\")\n                // Fenced codeblocks\n                .replace(/~{3}.*\\n/g, \"\")\n                // Strikethrough\n                .replace(/~~/g, \"\")\n                // Fenced codeblocks\n                .replace(/`{3}.*\\n/g, \"\");\n        }\n        if (options.preserveLinks) {\n            // Remove inline links while preserving the links\n            output = output.replace(/\\[(.*?)\\][\\[\\(](.*?)[\\]\\)]/g, \"$1 ($2)\");\n        }\n        output = output\n            // Remove HTML tags\n            .replace(/<[^>]*>/g, \"\")\n            // Remove setext-style headers\n            .replace(/^[=\\-]{2,}\\s*$/g, \"\")\n            // Remove footnotes?\n            .replace(/\\[\\^.+?\\](\\: .*?$)?/g, \"\")\n            .replace(/\\s{0,2}\\[.*?\\]: .*?$/g, \"\")\n            // Remove images\n            .replace(/\\!\\[(.*?)\\][\\[\\(].*?[\\]\\)]/g, options.useImgAltText ? \"$1\" : \"\")\n            // Remove inline links\n            .replace(/\\[(.*?)\\][\\[\\(].*?[\\]\\)]/g, \"$1\")\n            // Remove blockquotes\n            .replace(/^\\s{0,3}>\\s?/g, \"\")\n            .replace(/(^|\\n)\\s{0,3}>\\s?/g, \"\\n\\n\")\n            // Remove reference-style links?\n            .replace(/^\\s{1,2}\\[(.*?)\\]: (\\S+)( \".*?\")?\\s*$/g, \"\")\n            // Remove atx-style headers\n            .replace(/^(\\n)?\\s{0,}#{1,6}\\s+| {0,}(\\n)?\\s{0,}#{0,} {0,}(\\n)?\\s{0,}$/gm, \"$1$2$3\")\n            // Remove emphasis (repeat the line to remove double emphasis)\n            .replace(/([\\*_]{1,3})(\\S.*?\\S{0,1})\\1/g, \"$2\")\n            .replace(/([\\*_]{1,3})(\\S.*?\\S{0,1})\\1/g, \"$2\")\n            // Remove code blocks\n            .replace(/(`{3,})(.*?)\\1/gm, \"$2\")\n            // Remove inline code\n            .replace(/`(.+?)`/g, \"$1\")\n            // Replace two or more newlines with exactly two? Not entirely sure this belongs here...\n            .replace(/\\n{2,}/g, \"\\n\\n\");\n    }\n    catch (e) {\n        console.error(e);\n        return markdown;\n    }\n    return output;\n};\nexports.removeMarkdown = removeMarkdown;\n", "export const DEFAULT_FONT_SIZE = 20;\nexport const SVG_TO_SHAPE_MAPPER = {\n    rect: \"rectangle\",\n    circle: \"ellipse\",\n};\n", "import { DEFAULT_FONT_SIZE } from \"../constants.js\";\nexport class GraphConverter {\n    constructor({ converter, }) {\n        this.convert = (graph, options) => {\n            return this.converter(graph, {\n                ...options,\n                fontSize: options.fontSize || DEFAULT_FONT_SIZE,\n            });\n        };\n        this.converter = converter;\n    }\n}\n", "export var VERTEX_TYPE;\n(function (VERTEX_TYPE) {\n    VERTEX_TYPE[\"ROUND\"] = \"round\";\n    VERTEX_TYPE[\"STADIUM\"] = \"stadium\";\n    VERTEX_TYPE[\"DOUBLECIRCLE\"] = \"doublecircle\";\n    VERTEX_TYPE[\"CIRCLE\"] = \"circle\";\n    VERTEX_TYPE[\"DIAMOND\"] = \"diamond\";\n})(VERTEX_TYPE || (VERTEX_TYPE = {}));\nexport var LABEL_STYLE_PROPERTY;\n(function (LABEL_STYLE_PROPERTY) {\n    LABEL_STYLE_PROPERTY[\"COLOR\"] = \"color\";\n})(LABEL_STYLE_PROPERTY || (LABEL_STYLE_PROPERTY = {}));\nexport var CONTAINER_STYLE_PROPERTY;\n(function (CONTAINER_STYLE_PROPERTY) {\n    CONTAINER_STYLE_PROPERTY[\"FILL\"] = \"fill\";\n    CONTAINER_STYLE_PROPERTY[\"STROKE\"] = \"stroke\";\n    CONTAINER_STYLE_PROPERTY[\"STROKE_WIDTH\"] = \"stroke-width\";\n    CONTAINER_STYLE_PROPERTY[\"STROKE_DASHARRAY\"] = \"stroke-dasharray\";\n})(CONTAINER_STYLE_PROPERTY || (CONTAINER_STYLE_PROPERTY = {}));\n", "import { CONTAINER_STYLE_PROPERTY, LABEL_STYLE_PROPERTY, } from \"../interfaces.js\";\nimport { removeMarkdown } from \"@excalidraw/markdown-to-text\";\n/**\n * Convert mermaid edge type to Excalidraw arrow type\n */\nconst MERMAID_EDGE_TYPE_MAPPER = {\n    arrow_circle: {\n        endArrowhead: \"dot\",\n    },\n    arrow_cross: {\n        endArrowhead: \"bar\",\n    },\n    double_arrow_circle: {\n        endArrowhead: \"dot\",\n        startArrowhead: \"dot\",\n    },\n    double_arrow_cross: {\n        endArrowhead: \"bar\",\n        startArrowhead: \"bar\",\n    },\n    double_arrow_point: {\n        endArrowhead: \"arrow\",\n        startArrowhead: \"arrow\",\n    },\n};\nexport const computeExcalidrawArrowType = (mermaidArrowType) => {\n    return MERMAID_EDGE_TYPE_MAPPER[mermaidArrowType];\n};\n// Get text from graph elements, fallback markdown to text\nexport const getText = (element) => {\n    let text = element.text;\n    if (element.labelType === \"markdown\") {\n        text = removeMarkdown(element.text);\n    }\n    return removeFontAwesomeIcons(text);\n};\n/**\n * Remove font awesome icons support from text\n */\nconst removeFontAwesomeIcons = (input) => {\n    const fontAwesomeRegex = /\\s?(fa|fab):[a-zA-Z0-9-]+/g;\n    return input.replace(fontAwesomeRegex, \"\");\n};\n/**\n * Compute style for vertex\n */\nexport const computeExcalidrawVertexStyle = (style) => {\n    const excalidrawProperty = {};\n    Object.keys(style).forEach((property) => {\n        switch (property) {\n            case CONTAINER_STYLE_PROPERTY.FILL: {\n                excalidrawProperty.backgroundColor = style[property];\n                excalidrawProperty.fillStyle = \"solid\";\n                break;\n            }\n            case CONTAINER_STYLE_PROPERTY.STROKE: {\n                excalidrawProperty.strokeColor = style[property];\n                break;\n            }\n            case CONTAINER_STYLE_PROPERTY.STROKE_WIDTH: {\n                excalidrawProperty.strokeWidth = Number(style[property]?.split(\"px\")[0]);\n                break;\n            }\n            case CONTAINER_STYLE_PROPERTY.STROKE_DASHARRAY: {\n                excalidrawProperty.strokeStyle = \"dashed\";\n                break;\n            }\n        }\n    });\n    return excalidrawProperty;\n};\n/**\n * Compute style for label\n */\nexport const computeExcalidrawVertexLabelStyle = (style) => {\n    const excalidrawProperty = {};\n    Object.keys(style).forEach((property) => {\n        switch (property) {\n            case LABEL_STYLE_PROPERTY.COLOR: {\n                excalidrawProperty.strokeColor = style[property];\n                break;\n            }\n        }\n    });\n    return excalidrawProperty;\n};\n", "import { GraphConverter } from \"../GraphConverter.js\";\nimport { getText, computeExcalidrawVertexStyle, computeExcalidrawVertexLabelStyle, computeExcalidrawArrowType, } from \"../helpers.js\";\nimport { VERTEX_TYPE } from \"../../interfaces.js\";\nconst computeGroupIds = (graph) => {\n    // Parse the diagram into a tree for rendering and grouping\n    const tree = {};\n    graph.subGraphs.map((subGraph) => {\n        subGraph.nodeIds.forEach((nodeId) => {\n            tree[subGraph.id] = {\n                id: subGraph.id,\n                parent: null,\n                isLeaf: false,\n            };\n            tree[nodeId] = {\n                id: nodeId,\n                parent: subGraph.id,\n                isLeaf: graph.vertices[nodeId] !== undefined,\n            };\n        });\n    });\n    const mapper = {};\n    [...Object.keys(graph.vertices), ...graph.subGraphs.map((c) => c.id)].forEach((id) => {\n        if (!tree[id]) {\n            return;\n        }\n        let curr = tree[id];\n        const groupIds = [];\n        if (!curr.isLeaf) {\n            groupIds.push(`subgraph_group_${curr.id}`);\n        }\n        while (true) {\n            if (curr.parent) {\n                groupIds.push(`subgraph_group_${curr.parent}`);\n                curr = tree[curr.parent];\n            }\n            else {\n                break;\n            }\n        }\n        mapper[id] = groupIds;\n    });\n    return {\n        getGroupIds: (elementId) => {\n            return mapper[elementId] || [];\n        },\n        getParentId: (elementId) => {\n            return tree[elementId] ? tree[elementId].parent : null;\n        },\n    };\n};\nexport const FlowchartToExcalidrawSkeletonConverter = new GraphConverter({\n    converter: (graph, options) => {\n        const elements = [];\n        const fontSize = options.fontSize;\n        const { getGroupIds, getParentId } = computeGroupIds(graph);\n        // SubGraphs\n        graph.subGraphs.reverse().forEach((subGraph) => {\n            const groupIds = getGroupIds(subGraph.id);\n            const containerElement = {\n                id: subGraph.id,\n                type: \"rectangle\",\n                groupIds,\n                x: subGraph.x,\n                y: subGraph.y,\n                width: subGraph.width,\n                height: subGraph.height,\n                label: {\n                    groupIds,\n                    text: getText(subGraph),\n                    fontSize,\n                    verticalAlign: \"top\",\n                },\n            };\n            elements.push(containerElement);\n        });\n        // Vertices\n        Object.values(graph.vertices).forEach((vertex) => {\n            if (!vertex) {\n                return;\n            }\n            const groupIds = getGroupIds(vertex.id);\n            // Compute custom style\n            const containerStyle = computeExcalidrawVertexStyle(vertex.containerStyle);\n            const labelStyle = computeExcalidrawVertexLabelStyle(vertex.labelStyle);\n            let containerElement = {\n                id: vertex.id,\n                type: \"rectangle\",\n                groupIds,\n                x: vertex.x,\n                y: vertex.y,\n                width: vertex.width,\n                height: vertex.height,\n                strokeWidth: 2,\n                label: {\n                    groupIds,\n                    text: getText(vertex),\n                    fontSize,\n                    ...labelStyle,\n                },\n                link: vertex.link || null,\n                ...containerStyle,\n            };\n            switch (vertex.type) {\n                case VERTEX_TYPE.STADIUM: {\n                    containerElement = { ...containerElement, roundness: { type: 3 } };\n                    break;\n                }\n                case VERTEX_TYPE.ROUND: {\n                    containerElement = { ...containerElement, roundness: { type: 3 } };\n                    break;\n                }\n                case VERTEX_TYPE.DOUBLECIRCLE: {\n                    const CIRCLE_MARGIN = 5;\n                    // Create new groupId for double circle\n                    groupIds.push(`doublecircle_${vertex.id}}`);\n                    // Create inner circle element\n                    const innerCircle = {\n                        type: \"ellipse\",\n                        groupIds,\n                        x: vertex.x + CIRCLE_MARGIN,\n                        y: vertex.y + CIRCLE_MARGIN,\n                        width: vertex.width - CIRCLE_MARGIN * 2,\n                        height: vertex.height - CIRCLE_MARGIN * 2,\n                        strokeWidth: 2,\n                        roundness: { type: 3 },\n                        label: {\n                            groupIds,\n                            text: getText(vertex),\n                            fontSize,\n                        },\n                    };\n                    containerElement = { ...containerElement, groupIds, type: \"ellipse\" };\n                    elements.push(innerCircle);\n                    break;\n                }\n                case VERTEX_TYPE.CIRCLE: {\n                    containerElement.type = \"ellipse\";\n                    break;\n                }\n                case VERTEX_TYPE.DIAMOND: {\n                    containerElement.type = \"diamond\";\n                    break;\n                }\n            }\n            elements.push(containerElement);\n        });\n        // Edges\n        graph.edges.forEach((edge) => {\n            let groupIds = [];\n            const startParentId = getParentId(edge.start);\n            const endParentId = getParentId(edge.end);\n            if (startParentId && startParentId === endParentId) {\n                groupIds = getGroupIds(startParentId);\n            }\n            // Get arrow position data\n            const { startX, startY, reflectionPoints } = edge;\n            // Calculate Excalidraw arrow's points\n            const points = reflectionPoints.map((point) => [\n                point.x - reflectionPoints[0].x,\n                point.y - reflectionPoints[0].y,\n            ]);\n            // Get supported arrow type\n            const arrowType = computeExcalidrawArrowType(edge.type);\n            const arrowId = `${edge.start}_${edge.end}`;\n            const containerElement = {\n                id: arrowId,\n                type: \"arrow\",\n                groupIds,\n                x: startX,\n                y: startY,\n                // 4 and 2 are the Excalidraw's stroke width of thick and thin respectively\n                // TODO: use constant exported from Excalidraw package\n                strokeWidth: edge.stroke === \"thick\" ? 4 : 2,\n                strokeStyle: edge.stroke === \"dotted\" ? \"dashed\" : undefined,\n                points,\n                ...(edge.text\n                    ? { label: { text: getText(edge), fontSize, groupIds } }\n                    : {}),\n                roundness: {\n                    type: 2,\n                },\n                ...arrowType,\n            };\n            // Bind start and end vertex to arrow\n            const startVertex = elements.find((e) => e.id === edge.start);\n            const endVertex = elements.find((e) => e.id === edge.end);\n            if (!startVertex || !endVertex) {\n                return;\n            }\n            containerElement.start = {\n                id: startVertex.id || \"\",\n            };\n            containerElement.end = {\n                id: endVertex.id || \"\",\n            };\n            elements.push(containerElement);\n        });\n        return {\n            elements,\n        };\n    },\n});\n", "export { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\n", "import { GraphConverter } from \"../GraphConverter.js\";\nimport { nanoid } from \"nanoid\";\nexport const GraphImageConverter = new GraphConverter({\n    converter: (graph) => {\n        const imageId = nanoid();\n        const { width, height } = graph;\n        const imageElement = {\n            type: \"image\",\n            x: 0,\n            y: 0,\n            width,\n            height,\n            status: \"saved\",\n            fileId: imageId,\n        };\n        const files = {\n            [imageId]: {\n                id: imageId,\n                mimeType: graph.mimeType,\n                dataURL: graph.dataURL,\n            },\n        };\n        return { files, elements: [imageElement] };\n    },\n});\n", "import { GraphConverter } from \"../GraphConverter.js\";\nimport { nanoid } from \"nanoid\";\n// Arrow mapper for the supported sequence arrow types\nconst EXCALIDRAW_STROKE_STYLE_FOR_ARROW = {\n    SOLID: \"solid\",\n    DOTTED: \"dotted\",\n    SOLID_CROSS: \"solid\",\n    DOTTED_CROSS: \"dotted\",\n    SOLID_OPEN: \"solid\",\n    DOTTED_OPEN: \"dotted\",\n    SOLID_POINT: \"solid\",\n    DOTTED_POINT: \"dotted\",\n};\nconst createLine = (line) => {\n    const lineElement = {\n        type: \"line\",\n        x: line.startX,\n        y: line.startY,\n        points: [\n            [0, 0],\n            [line.endX - line.startX, line.endY - line.startY],\n        ],\n        width: line.endX - line.startX,\n        height: line.endY - line.startY,\n        strokeStyle: line.strokeStyle || \"solid\",\n        strokeColor: line.strokeColor || \"#000\",\n        strokeWidth: line.strokeWidth || 1,\n    };\n    if (line.groupId) {\n        Object.assign(lineElement, { groupIds: [line.groupId] });\n    }\n    if (line.id) {\n        Object.assign(lineElement, { id: line.id });\n    }\n    return lineElement;\n};\nconst createText = (element) => {\n    const textElement = {\n        type: \"text\",\n        x: element.x,\n        y: element.y,\n        width: element.width,\n        height: element.height,\n        text: element.text || \"\",\n        fontSize: element.fontSize,\n        verticalAlign: \"middle\",\n    };\n    if (element.groupId) {\n        Object.assign(textElement, { groupIds: [element.groupId] });\n    }\n    if (element.id) {\n        Object.assign(textElement, { id: element.id });\n    }\n    return textElement;\n};\nconst createContainer = (element) => {\n    let extraProps = {};\n    if (element.type === \"rectangle\" && element.subtype === \"activation\") {\n        extraProps = {\n            backgroundColor: \"#e9ecef\",\n            fillStyle: \"solid\",\n        };\n    }\n    const container = {\n        id: element.id,\n        type: element.type,\n        x: element.x,\n        y: element.y,\n        width: element.width,\n        height: element.height,\n        label: {\n            text: element?.label?.text || \"\",\n            fontSize: element?.label?.fontSize,\n            verticalAlign: \"middle\",\n            strokeColor: element.label?.color || \"#000\",\n        },\n        strokeStyle: element?.strokeStyle,\n        strokeWidth: element?.strokeWidth,\n        strokeColor: element?.strokeColor,\n        backgroundColor: element?.bgColor,\n        fillStyle: \"solid\",\n        ...extraProps,\n    };\n    if (element.groupId) {\n        Object.assign(container, { groupIds: [element.groupId] });\n    }\n    return container;\n};\nconst createArrow = (arrow) => {\n    const strokeStyle = EXCALIDRAW_STROKE_STYLE_FOR_ARROW[arrow.strokeStyle];\n    const arrowElement = {\n        type: \"arrow\",\n        x: arrow.startX,\n        y: arrow.startY,\n        points: arrow.points || [\n            [0, 0],\n            [arrow.endX - arrow.startX, arrow.endY - arrow.startY],\n        ],\n        width: arrow.endX - arrow.startX,\n        height: arrow.endY - arrow.startY,\n        strokeStyle,\n        endArrowhead: arrow.strokeStyle === \"SOLID_OPEN\" || arrow.strokeStyle === \"DOTTED_OPEN\"\n            ? null\n            : \"arrow\",\n        label: {\n            text: arrow?.label?.text || \"\",\n            fontSize: 16,\n        },\n        roundness: {\n            type: 2,\n        },\n    };\n    if (arrow.groupId) {\n        Object.assign(arrowElement, { groupIds: [arrow.groupId] });\n    }\n    return arrowElement;\n};\nexport const SequenceToExcalidrawSkeletonConvertor = new GraphConverter({\n    converter: (chart) => {\n        const elements = [];\n        const activations = [];\n        Object.values(chart.nodes).forEach((node) => {\n            if (!node || !node.length) {\n                return;\n            }\n            node.forEach((element) => {\n                let excalidrawElement;\n                switch (element.type) {\n                    case \"line\":\n                        excalidrawElement = createLine(element);\n                        break;\n                    case \"rectangle\":\n                    case \"ellipse\":\n                        excalidrawElement = createContainer(element);\n                        break;\n                    case \"text\":\n                        excalidrawElement = createText(element);\n                        break;\n                    default:\n                        throw `unknown type ${element.type}`;\n                        break;\n                }\n                if (element.type === \"rectangle\" && element?.subtype === \"activation\") {\n                    activations.push(excalidrawElement);\n                }\n                else {\n                    elements.push(excalidrawElement);\n                }\n            });\n        });\n        Object.values(chart.lines).forEach((line) => {\n            if (!line) {\n                return;\n            }\n            elements.push(createLine(line));\n        });\n        Object.values(chart.arrows).forEach((arrow) => {\n            if (!arrow) {\n                return;\n            }\n            elements.push(createArrow(arrow));\n            if (arrow.sequenceNumber) {\n                elements.push(createContainer(arrow.sequenceNumber));\n            }\n        });\n        elements.push(...activations);\n        // loops\n        if (chart.loops) {\n            const { lines, texts, nodes } = chart.loops;\n            lines.forEach((line) => {\n                elements.push(createLine(line));\n            });\n            texts.forEach((text) => {\n                elements.push(createText(text));\n            });\n            nodes.forEach((node) => {\n                elements.push(createContainer(node));\n            });\n        }\n        if (chart.groups) {\n            chart.groups.forEach((group) => {\n                const { actorKeys, name } = group;\n                let minX = Infinity;\n                let minY = Infinity;\n                let maxX = 0;\n                let maxY = 0;\n                if (!actorKeys.length) {\n                    return;\n                }\n                const actors = elements.filter((ele) => {\n                    if (ele.id) {\n                        const hyphenIndex = ele.id.indexOf(\"-\");\n                        const id = ele.id.substring(0, hyphenIndex);\n                        return actorKeys.includes(id);\n                    }\n                });\n                actors.forEach((actor) => {\n                    if (actor.x === undefined ||\n                        actor.y === undefined ||\n                        actor.width === undefined ||\n                        actor.height === undefined) {\n                        throw new Error(`Actor attributes missing ${actor}`);\n                    }\n                    minX = Math.min(minX, actor.x);\n                    minY = Math.min(minY, actor.y);\n                    maxX = Math.max(maxX, actor.x + actor.width);\n                    maxY = Math.max(maxY, actor.y + actor.height);\n                });\n                // Draw the outer rectangle enclosing the group elements\n                const PADDING = 10;\n                const groupRectX = minX - PADDING;\n                const groupRectY = minY - PADDING;\n                const groupRectWidth = maxX - minX + PADDING * 2;\n                const groupRectHeight = maxY - minY + PADDING * 2;\n                const groupRectId = nanoid();\n                const groupRect = createContainer({\n                    type: \"rectangle\",\n                    x: groupRectX,\n                    y: groupRectY,\n                    width: groupRectWidth,\n                    height: groupRectHeight,\n                    bgColor: group.fill,\n                    id: groupRectId,\n                });\n                elements.unshift(groupRect);\n                const frameId = nanoid();\n                const frameChildren = [groupRectId];\n                elements.forEach((ele) => {\n                    if (ele.type === \"frame\") {\n                        return;\n                    }\n                    if (ele.x === undefined ||\n                        ele.y === undefined ||\n                        ele.width === undefined ||\n                        ele.height === undefined) {\n                        throw new Error(`Element attributes missing ${ele}`);\n                    }\n                    if (ele.x >= minX &&\n                        ele.x + ele.width <= maxX &&\n                        ele.y >= minY &&\n                        ele.y + ele.height <= maxY) {\n                        const elementId = ele.id || nanoid();\n                        if (!ele.id) {\n                            Object.assign(ele, { id: elementId });\n                        }\n                        frameChildren.push(elementId);\n                    }\n                });\n                const frame = {\n                    type: \"frame\",\n                    id: frameId,\n                    name,\n                    children: frameChildren,\n                };\n                elements.push(frame);\n            });\n        }\n        return { elements };\n    },\n});\n", "import { FlowchartToExcalidrawSkeletonConverter } from \"./converter/types/flowchart.js\";\nimport { GraphImageConverter } from \"./converter/types/graphImage.js\";\nimport { SequenceToExcalidrawSkeletonConvertor } from \"./converter/types/sequence.js\";\nexport const graphToExcalidraw = (graph, options = {}) => {\n    switch (graph.type) {\n        case \"graphImage\": {\n            return GraphImageConverter.convert(graph, options);\n        }\n        case \"flowchart\": {\n            return FlowchartToExcalidrawSkeletonConverter.convert(graph, options);\n        }\n        case \"sequence\": {\n            return SequenceToExcalidrawSkeletonConvertor.convert(graph, options);\n        }\n        default: {\n            throw new Error(`graphToExcalidraw: unknown graph type \"${graph.type}, only flowcharts are supported!\"`);\n        }\n    }\n};\n", "import \"ts-dedent\";\nimport { K } from \"./mermaid-b0ad2de1.js\";\nimport \"dayjs\";\nimport \"@braintree/sanitize-url\";\nimport \"d3\";\nimport \"dompurify\";\nimport \"khroma\";\nimport \"lodash-es/memoize.js\";\nimport \"stylis\";\nimport \"lodash-es/isEmpty.js\";\nexport {\n  K as default\n};\n", "// Convert mermaid entity codes to text e.g. \"#9829;\" to \"♥\"\nexport const entityCodesToText = (input) => {\n    input = decodeEntities(input);\n    const modifiedInput = input\n        .replace(/#(\\d+);/g, \"&#$1;\")\n        .replace(/#([a-z]+);/g, \"&$1;\");\n    const element = document.createElement(\"textarea\");\n    element.innerHTML = modifiedInput;\n    return element.value;\n};\nexport const getTransformAttr = (el) => {\n    const transformAttr = el.getAttribute(\"transform\");\n    const translateMatch = transformAttr?.match(/translate\\(([\\d.-]+),\\s*([\\d.-]+)\\)/);\n    let transformX = 0;\n    let transformY = 0;\n    if (translateMatch) {\n        transformX = Number(translateMatch[1]);\n        transformY = Number(translateMatch[2]);\n    }\n    return { transformX, transformY };\n};\n//TODO Once fixed in mermaid this will be removed\nexport const encodeEntities = (text) => {\n    let txt = text;\n    txt = txt.replace(/style.*:\\S*#.*;/g, (s) => {\n        return s.substring(0, s.length - 1);\n    });\n    txt = txt.replace(/classDef.*:\\S*#.*;/g, (s) => {\n        return s.substring(0, s.length - 1);\n    });\n    txt = txt.replace(/#\\w+;/g, (s) => {\n        const innerTxt = s.substring(1, s.length - 1);\n        const isInt = /^\\+?\\d+$/.test(innerTxt);\n        if (isInt) {\n            return `ﬂ°°${innerTxt}¶ß`;\n        }\n        return `ﬂ°${innerTxt}¶ß`;\n    });\n    return txt;\n};\nexport const decodeEntities = function (text) {\n    return text.replace(/ﬂ°°/g, \"#\").replace(/ﬂ°/g, \"&\").replace(/¶ß/g, \";\");\n};\n", "import { entityCodesToText, getTransformAttr } from \"../utils.js\";\nconst parseSubGraph = (data, containerEl) => {\n    // Extract only node id for better reference\n    // e.g. full element id = \"flowchart-c1-205\" will map to \"c1\"\n    const nodeIds = data.nodes.map((n) => {\n        if (n.startsWith(\"flowchart-\")) {\n            return n.split(\"-\")[1];\n        }\n        return n;\n    });\n    // Get position\n    const el = containerEl.querySelector(`[id='${data.id}']`);\n    if (!el) {\n        throw new Error(\"SubGraph element not found\");\n    }\n    const position = computeElementPosition(el, containerEl);\n    // Get dimension\n    const boundingBox = el.getBBox();\n    const dimension = {\n        width: boundingBox.width,\n        height: boundingBox.height,\n    };\n    // Remove irrelevant properties\n    data.classes = undefined;\n    data.dir = undefined;\n    return {\n        ...data,\n        nodeIds,\n        ...position,\n        ...dimension,\n        text: entityCodesToText(data.title),\n    };\n};\nconst parseVertex = (data, containerEl) => {\n    // Find Vertex element\n    const el = containerEl.querySelector(`[id*=\"flowchart-${data.id}-\"]`);\n    if (!el) {\n        return undefined;\n    }\n    // Check if Vertex attached with link\n    let link;\n    if (el.parentElement?.tagName.toLowerCase() === \"a\") {\n        link = el.parentElement.getAttribute(\"xlink:href\");\n    }\n    // Get position\n    const position = computeElementPosition(link ? el.parentElement : el, containerEl);\n    // Get dimension\n    const boundingBox = el.getBBox();\n    const dimension = {\n        width: boundingBox.width,\n        height: boundingBox.height,\n    };\n    // Extract style\n    const labelContainerStyleText = el\n        .querySelector(\".label-container\")\n        ?.getAttribute(\"style\");\n    const labelStyleText = el.querySelector(\".label\")?.getAttribute(\"style\");\n    const containerStyle = {};\n    labelContainerStyleText?.split(\";\").forEach((property) => {\n        if (!property) {\n            return;\n        }\n        const key = property.split(\":\")[0].trim();\n        const value = property.split(\":\")[1].trim();\n        containerStyle[key] = value;\n    });\n    const labelStyle = {};\n    labelStyleText?.split(\";\").forEach((property) => {\n        if (!property) {\n            return;\n        }\n        const key = property.split(\":\")[0].trim();\n        const value = property.split(\":\")[1].trim();\n        labelStyle[key] = value;\n    });\n    return {\n        id: data.id,\n        labelType: data.labelType,\n        text: entityCodesToText(data.text),\n        type: data.type,\n        link: link || undefined,\n        ...position,\n        ...dimension,\n        containerStyle,\n        labelStyle,\n    };\n};\nconst parseEdge = (data, containerEl) => {\n    // Find edge element\n    const el = containerEl.querySelector(`[id*=\"L-${data.start}-${data.end}\"]`);\n    if (!el) {\n        throw new Error(\"Edge element not found\");\n    }\n    // Compute edge position data\n    const position = computeElementPosition(el, containerEl);\n    const edgePositionData = computeEdgePositions(el, position);\n    // Remove irrelevant properties\n    data.length = undefined;\n    return {\n        ...data,\n        ...edgePositionData,\n        text: entityCodesToText(data.text),\n    };\n};\n// Compute element position\nconst computeElementPosition = (el, containerEl) => {\n    if (!el) {\n        throw new Error(\"Element not found\");\n    }\n    let root = el.parentElement?.parentElement;\n    const childElement = el.childNodes[0];\n    let childPosition = { x: 0, y: 0 };\n    if (childElement) {\n        const { transformX, transformY } = getTransformAttr(childElement);\n        const boundingBox = childElement.getBBox();\n        childPosition = {\n            x: Number(childElement.getAttribute(\"x\")) ||\n                transformX + boundingBox.x ||\n                0,\n            y: Number(childElement.getAttribute(\"y\")) ||\n                transformY + boundingBox.y ||\n                0,\n        };\n    }\n    const { transformX, transformY } = getTransformAttr(el);\n    const position = {\n        x: transformX + childPosition.x,\n        y: transformY + childPosition.y,\n    };\n    while (root && root.id !== containerEl.id) {\n        if (root.classList.value === \"root\" && root.hasAttribute(\"transform\")) {\n            const { transformX, transformY } = getTransformAttr(root);\n            position.x += transformX;\n            position.y += transformY;\n        }\n        root = root.parentElement;\n    }\n    return position;\n};\nconst computeEdgePositions = (pathElement, offset = { x: 0, y: 0 }) => {\n    if (pathElement.tagName.toLowerCase() !== \"path\") {\n        throw new Error(`Invalid input: Expected an HTMLElement of tag \"path\", got ${pathElement.tagName}`);\n    }\n    const dAttr = pathElement.getAttribute(\"d\");\n    if (!dAttr) {\n        throw new Error('Path element does not contain a \"d\" attribute');\n    }\n    // Split the d attribute based on M (Move To) and L (Line To) commands\n    const commands = dAttr.split(/(?=[LM])/);\n    const startPosition = commands[0]\n        .substring(1)\n        .split(\",\")\n        .map((coord) => parseFloat(coord));\n    const endPosition = commands[commands.length - 1]\n        .substring(1)\n        .split(\",\")\n        .map((coord) => parseFloat(coord));\n    const reflectionPoints = commands\n        .map((command) => {\n        const coords = command\n            .substring(1)\n            .split(\",\")\n            .map((coord) => parseFloat(coord));\n        return { x: coords[0], y: coords[1] };\n    })\n        .filter((point, index, array) => {\n        if (index === array.length - 1) {\n            return true;\n        }\n        const prevPoint = array[index - 1];\n        return (index === 0 || (point.x !== prevPoint.x && point.y !== prevPoint.y));\n    })\n        .map((p) => {\n        return {\n            x: p.x + offset.x,\n            y: p.y + offset.y,\n        };\n    });\n    return {\n        startX: startPosition[0] + offset.x,\n        startY: startPosition[1] + offset.y,\n        endX: endPosition[0] + offset.x,\n        endY: endPosition[1] + offset.y,\n        reflectionPoints,\n    };\n};\nexport const parseMermaidFlowChartDiagram = (diagram, containerEl) => {\n    // This does some cleanup and initialization making sure\n    // diagram is parsed correctly. Useful when multiple diagrams are\n    // parsed together one after another, eg in playground\n    // https://github.com/mermaid-js/mermaid/blob/e561cbd3be2a93b8bedfa4839484966faad92ccf/packages/mermaid/src/Diagram.ts#L43\n    diagram.parse();\n    // Get mermaid parsed data from parser shared variable `yy`\n    const mermaidParser = diagram.parser.yy;\n    const vertices = mermaidParser.getVertices();\n    Object.keys(vertices).forEach((id) => {\n        vertices[id] = parseVertex(vertices[id], containerEl);\n    });\n    const edges = mermaidParser\n        .getEdges()\n        .map((data) => parseEdge(data, containerEl));\n    const subGraphs = mermaidParser\n        .getSubGraphs()\n        .map((data) => parseSubGraph(data, containerEl));\n    return {\n        type: \"flowchart\",\n        subGraphs,\n        vertices,\n        edges,\n    };\n};\n", "import { SVG_TO_SHAPE_MAPPER } from \"../constants.js\";\nimport { nanoid } from \"nanoid\";\nimport { entityCodesToText } from \"../utils.js\";\n// Currently mermaid supported these 6 arrow types, the names are taken from mermaidParser.LINETYPE\nconst SEQUENCE_ARROW_TYPES = {\n    0: \"SOLID\",\n    1: \"DOTTED\",\n    3: \"SOLID_CROSS\",\n    4: \"DOTTED_CROSS\",\n    5: \"SOLID_OPEN\",\n    6: \"DOTTED_OPEN\",\n    24: \"SOLID_POINT\",\n    25: \"DOTTED_POINT\",\n};\nconst MESSAGE_TYPE = {\n    SOLID: 0,\n    DOTTED: 1,\n    NOTE: 2,\n    SOLID_CROSS: 3,\n    DOTTED_CROSS: 4,\n    SOLID_OPEN: 5,\n    DOTTED_OPEN: 6,\n    LOOP_START: 10,\n    LOOP_END: 11,\n    ALT_START: 12,\n    ALT_ELSE: 13,\n    ALT_END: 14,\n    OPT_START: 15,\n    OPT_END: 16,\n    ACTIVE_START: 17,\n    ACTIVE_END: 18,\n    PAR_START: 19,\n    PAR_AND: 20,\n    PAR_END: 21,\n    RECT_START: 22,\n    RECT_END: 23,\n    SOLID_POINT: 24,\n    DOTTED_POINT: 25,\n    AUTONUMBER: 26,\n    CRITICAL_START: 27,\n    CRITICAL_OPTION: 28,\n    CRITICAL_END: 29,\n    BREAK_START: 30,\n    BREAK_END: 31,\n    PAR_OVER_START: 32,\n};\nconst createContainerElement = (node, type, opts = {}) => {\n    const container = {};\n    container.type = type;\n    const { text, subtype, id, groupId } = opts;\n    container.id = id;\n    if (groupId) {\n        container.groupId = groupId;\n    }\n    if (text) {\n        container.label = {\n            text: entityCodesToText(text),\n            fontSize: 16,\n        };\n    }\n    const boundingBox = node.getBBox();\n    container.x = boundingBox.x;\n    container.y = boundingBox.y;\n    container.width = boundingBox.width;\n    container.height = boundingBox.height;\n    container.subtype = subtype;\n    switch (subtype) {\n        case \"highlight\":\n            const bgColor = node.getAttribute(\"fill\");\n            if (bgColor) {\n                container.bgColor = bgColor;\n            }\n            break;\n        case \"note\":\n            container.strokeStyle = \"dashed\";\n            break;\n    }\n    return container;\n};\nconst createTextElement = (textNode, text, opts) => {\n    const node = {};\n    const x = Number(textNode.getAttribute(\"x\"));\n    const y = Number(textNode.getAttribute(\"y\"));\n    node.type = \"text\";\n    node.text = entityCodesToText(text);\n    if (opts?.id) {\n        node.id = opts.id;\n    }\n    if (opts?.groupId) {\n        node.groupId = opts.groupId;\n    }\n    const boundingBox = textNode.getBBox();\n    node.width = boundingBox.width;\n    node.height = boundingBox.height;\n    node.x = x - boundingBox.width / 2;\n    node.y = y;\n    const fontSize = parseInt(getComputedStyle(textNode).fontSize);\n    node.fontSize = fontSize;\n    return node;\n};\nconst createLineElement = (lineNode, startX, startY, endX, endY, opts) => {\n    const line = {};\n    line.startX = startX;\n    line.startY = startY;\n    line.endX = endX;\n    if (opts?.groupId) {\n        line.groupId = opts.groupId;\n    }\n    if (opts?.id) {\n        line.id = opts.id;\n    }\n    // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent\n    line.endY = endY;\n    line.strokeColor = lineNode.getAttribute(\"stroke\");\n    line.strokeWidth = Number(lineNode.getAttribute(\"stroke-width\"));\n    line.type = \"line\";\n    return line;\n};\nconst createArrowElement = (arrowNode, message) => {\n    const arrow = {};\n    arrow.label = { text: entityCodesToText(message.message), fontSize: 16 };\n    const tagName = arrowNode.tagName;\n    if (tagName === \"line\") {\n        arrow.startX = Number(arrowNode.getAttribute(\"x1\"));\n        arrow.startY = Number(arrowNode.getAttribute(\"y1\"));\n        arrow.endX = Number(arrowNode.getAttribute(\"x2\"));\n        arrow.endY = Number(arrowNode.getAttribute(\"y2\"));\n    }\n    else if (tagName === \"path\") {\n        const dAttr = arrowNode.getAttribute(\"d\");\n        if (!dAttr) {\n            throw new Error('Path element does not contain a \"d\" attribute');\n        }\n        // Split the d attribute based on M (Move To)  and C (Curve) commands\n        const commands = dAttr.split(/(?=[LC])/);\n        const startPosition = commands[0]\n            .substring(1)\n            .split(\",\")\n            .map((coord) => parseFloat(coord));\n        const points = [];\n        commands.forEach((command) => {\n            const currPoints = command\n                .substring(1)\n                .trim()\n                .split(\" \")\n                .map((pos) => {\n                const [x, y] = pos.split(\",\");\n                return [\n                    parseFloat(x) - startPosition[0],\n                    parseFloat(y) - startPosition[1],\n                ];\n            });\n            points.push(...currPoints);\n        });\n        const endPosition = points[points.length - 1];\n        arrow.startX = startPosition[0];\n        arrow.startY = startPosition[1];\n        arrow.endX = endPosition[0];\n        arrow.endY = endPosition[1];\n        arrow.points = points;\n    }\n    if (message) {\n        // In mermaid the text is positioned above arrow but in Excalidraw\n        // its postioned on the arrow hence the elements below it might look cluttered so shifting the arrow by an offset of 10px\n        const offset = 10;\n        arrow.startY = arrow.startY - offset;\n        arrow.endY = arrow.endY - offset;\n    }\n    const showSequenceNumber = !!arrowNode.nextElementSibling?.classList.contains(\"sequenceNumber\");\n    if (showSequenceNumber) {\n        const text = arrowNode.nextElementSibling?.textContent;\n        if (!text) {\n            throw new Error(\"sequence number not present\");\n        }\n        const height = 30;\n        const yOffset = height / 2;\n        const xOffset = 10;\n        const sequenceNumber = {\n            type: \"rectangle\",\n            x: arrow.startX - xOffset,\n            y: arrow.startY - yOffset,\n            label: { text, fontSize: 14 },\n            bgColor: \"#e9ecef\",\n            height,\n            subtype: \"sequence\",\n        };\n        arrow.sequenceNumber = sequenceNumber;\n    }\n    arrow.strokeColor = arrowNode.getAttribute(\"stroke\");\n    arrow.strokeWidth = Number(arrowNode.getAttribute(\"stroke-width\"));\n    arrow.type = \"arrow\";\n    arrow.strokeStyle = SEQUENCE_ARROW_TYPES[message.type];\n    return arrow;\n};\nconst createActorSymbol = (rootNode, text, opts) => {\n    if (!rootNode) {\n        throw \"root node not found\";\n    }\n    const groupId = nanoid();\n    const children = Array.from(rootNode.children);\n    const nodeElements = [];\n    children.forEach((child, index) => {\n        const id = `${opts?.id}-${index}`;\n        let ele;\n        switch (child.tagName) {\n            case \"line\":\n                const startX = Number(child.getAttribute(\"x1\"));\n                const startY = Number(child.getAttribute(\"y1\"));\n                const endX = Number(child.getAttribute(\"x2\"));\n                const endY = Number(child.getAttribute(\"y2\"));\n                ele = createLineElement(child, startX, startY, endX, endY, { groupId, id });\n                break;\n            case \"text\":\n                ele = createTextElement(child, text, { groupId, id });\n                break;\n            case \"circle\":\n                ele = createContainerElement(child, \"ellipse\", {\n                    text: child.textContent || undefined,\n                    groupId,\n                    id,\n                });\n            default:\n                ele = createContainerElement(child, SVG_TO_SHAPE_MAPPER[child.tagName], { text: child.textContent || undefined, groupId, id });\n        }\n        nodeElements.push(ele);\n    });\n    return nodeElements;\n};\nconst parseActor = (actors, containerEl) => {\n    const actorRootNodes = Array.from(containerEl.querySelectorAll(\".actor\"))\n        .filter((node) => node.tagName === \"text\")\n        .map((actor) => actor.tagName === \"text\" && actor.parentElement);\n    const nodes = [];\n    const lines = [];\n    const actorsLength = Object.keys(actors).length;\n    Object.values(actors).forEach((actor, index) => {\n        //@ts-ignore\n        // For each actor there are two nodes top and bottom which is connected by a line\n        const topRootNode = actorRootNodes[index];\n        //@ts-ignore\n        const bottomRootNode = actorRootNodes[actorsLength + index];\n        if (!topRootNode) {\n            throw \"root not found\";\n        }\n        const text = actor.description;\n        if (actor.type === \"participant\") {\n            // creating top actor node element\n            const topNodeElement = createContainerElement(topRootNode.firstChild, \"rectangle\", { id: `${actor.name}-top`, text, subtype: \"actor\" });\n            if (!topNodeElement) {\n                throw \"Top Node element not found!\";\n            }\n            nodes.push([topNodeElement]);\n            // creating bottom actor node element\n            const bottomNodeElement = createContainerElement(bottomRootNode.firstChild, \"rectangle\", { id: `${actor.name}-bottom`, text, subtype: \"actor\" });\n            nodes.push([bottomNodeElement]);\n            // Get the line connecting the top and bottom nodes. As per the DOM, the line is rendered as first child of parent element\n            const lineNode = topRootNode.previousElementSibling;\n            if (lineNode?.tagName !== \"line\") {\n                throw \"Line not found\";\n            }\n            const startX = Number(lineNode.getAttribute(\"x1\"));\n            if (!topNodeElement.height) {\n                throw \"Top node element height is null\";\n            }\n            const startY = topNodeElement.y + topNodeElement.height;\n            // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent\n            const endY = bottomNodeElement.y;\n            const endX = Number(lineNode.getAttribute(\"x2\"));\n            const line = createLineElement(lineNode, startX, startY, endX, endY);\n            lines.push(line);\n        }\n        else if (actor.type === \"actor\") {\n            const topNodeElement = createActorSymbol(topRootNode, text, {\n                id: `${actor.name}-top`,\n            });\n            nodes.push(topNodeElement);\n            const bottomNodeElement = createActorSymbol(bottomRootNode, text, {\n                id: `${actor.name}-bottom`,\n            });\n            nodes.push(bottomNodeElement);\n            // Get the line connecting the top and bottom nodes. As per the DOM, the line is rendered as first child of parent element\n            const lineNode = topRootNode.previousElementSibling;\n            if (lineNode?.tagName !== \"line\") {\n                throw \"Line not found\";\n            }\n            const startX = Number(lineNode.getAttribute(\"x1\"));\n            const startY = Number(lineNode.getAttribute(\"y1\"));\n            const endX = Number(lineNode.getAttribute(\"x2\"));\n            // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent\n            const bottomEllipseNode = bottomNodeElement.find((node) => node.type === \"ellipse\");\n            if (bottomEllipseNode) {\n                const endY = bottomEllipseNode.y;\n                const line = createLineElement(lineNode, startX, startY, endX, endY);\n                lines.push(line);\n            }\n        }\n    });\n    return { nodes, lines };\n};\nconst computeArrows = (messages, containerEl) => {\n    const arrows = [];\n    const arrowNodes = Array.from(containerEl.querySelectorAll('[class*=\"messageLine\"]'));\n    const supportedMessageTypes = Object.keys(SEQUENCE_ARROW_TYPES);\n    const arrowMessages = messages.filter((message) => supportedMessageTypes.includes(message.type.toString()));\n    arrowNodes.forEach((arrowNode, index) => {\n        const message = arrowMessages[index];\n        const arrow = createArrowElement(arrowNode, message);\n        arrows.push(arrow);\n    });\n    return arrows;\n};\nconst computeNotes = (messages, containerEl) => {\n    const noteNodes = Array.from(containerEl.querySelectorAll(\".note\")).map((node) => node.parentElement);\n    const noteText = messages.filter((message) => message.type === MESSAGE_TYPE.NOTE);\n    const notes = [];\n    noteNodes.forEach((node, index) => {\n        if (!node) {\n            return;\n        }\n        const rect = node.firstChild;\n        const text = noteText[index].message;\n        const note = createContainerElement(rect, \"rectangle\", {\n            text,\n            subtype: \"note\",\n        });\n        notes.push(note);\n    });\n    return notes;\n};\nconst parseActivations = (containerEl) => {\n    const activationNodes = Array.from(containerEl.querySelectorAll(`[class*=activation]`));\n    const activations = [];\n    activationNodes.forEach((node) => {\n        const rect = createContainerElement(node, \"rectangle\", {\n            text: \"\",\n            subtype: \"activation\",\n        });\n        activations.push(rect);\n    });\n    return activations;\n};\nconst parseLoops = (messages, containerEl) => {\n    const lineNodes = Array.from(containerEl.querySelectorAll(\".loopLine\"));\n    const lines = [];\n    const texts = [];\n    const nodes = [];\n    lineNodes.forEach((node) => {\n        const startX = Number(node.getAttribute(\"x1\"));\n        const startY = Number(node.getAttribute(\"y1\"));\n        const endX = Number(node.getAttribute(\"x2\"));\n        const endY = Number(node.getAttribute(\"y2\"));\n        const line = createLineElement(node, startX, startY, endX, endY);\n        line.strokeStyle = \"dotted\";\n        line.strokeColor = \"#adb5bd\";\n        line.strokeWidth = 2;\n        lines.push(line);\n    });\n    const loopTextNodes = Array.from(containerEl.querySelectorAll(\".loopText\"));\n    const criticalMessages = messages\n        .filter((message) => message.type === MESSAGE_TYPE.CRITICAL_START)\n        .map((message) => message.message);\n    loopTextNodes.forEach((node) => {\n        const text = node.textContent || \"\";\n        const textElement = createTextElement(node, text);\n        // The text is rendered between [ ] in DOM hence getting the text excluding the [ ]\n        const rawText = text.match(/\\[(.*?)\\]/)?.[1] || \"\";\n        const isCritical = criticalMessages.includes(rawText);\n        // For critical label the coordinates are not accurate in mermaid as there is\n        // no padding left hence shifting the text next to critical label by 16px (font size)\n        if (isCritical) {\n            textElement.x += 16;\n        }\n        texts.push(textElement);\n    });\n    const labelBoxes = Array.from(containerEl?.querySelectorAll(\".labelBox\"));\n    const labelTextNode = Array.from(containerEl?.querySelectorAll(\".labelText\"));\n    labelBoxes.forEach((labelBox, index) => {\n        const labelText = labelTextNode[index]?.textContent || \"\";\n        const container = createContainerElement(labelBox, \"rectangle\", {\n            text: labelText,\n        });\n        container.strokeColor = \"#adb5bd\";\n        container.bgColor = \"#e9ecef\";\n        // So width is calculated based on label\n        container.width = undefined;\n        nodes.push(container);\n    });\n    return { lines, texts, nodes };\n};\nconst computeHighlights = (containerEl) => {\n    const rects = Array.from(containerEl.querySelectorAll(\".rect\"))\n        // Only drawing specifically for highlights as the same selector is for grouping as well. For grouping we\n        // draw it ourselves\n        .filter((node) => node.parentElement?.tagName !== \"g\");\n    const nodes = [];\n    rects.forEach((rect) => {\n        const node = createContainerElement(rect, \"rectangle\", {\n            text: \"\",\n            subtype: \"highlight\",\n        });\n        nodes.push(node);\n    });\n    return nodes;\n};\nexport const parseMermaidSequenceDiagram = (diagram, containerEl) => {\n    diagram.parse();\n    // Get mermaid parsed data from parser shared variable `yy`\n    const mermaidParser = diagram.parser.yy;\n    const nodes = [];\n    const groups = mermaidParser.getBoxes();\n    const bgHightlights = computeHighlights(containerEl);\n    const actorData = mermaidParser.getActors();\n    const { nodes: actors, lines } = parseActor(actorData, containerEl);\n    const messages = mermaidParser.getMessages();\n    const arrows = computeArrows(messages, containerEl);\n    const notes = computeNotes(messages, containerEl);\n    const activations = parseActivations(containerEl);\n    const loops = parseLoops(messages, containerEl);\n    nodes.push(bgHightlights);\n    nodes.push(...actors);\n    nodes.push(notes);\n    nodes.push(activations);\n    return { type: \"sequence\", lines, arrows, nodes, loops, groups };\n};\n", "import mermaid from \"mermaid\";\nimport { DEFAULT_FONT_SIZE } from \"./constants.js\";\nimport { encodeEntities } from \"./utils.js\";\nimport { parseMermaidFlowChartDiagram } from \"./parser/flowchart.js\";\nimport { parseMermaidSequenceDiagram } from \"./parser/sequence.js\";\n// Fallback to Svg\nconst convertSvgToGraphImage = (svgContainer) => {\n    // Extract SVG width and height\n    // TODO: make width and height change dynamically based on user's screen dimension\n    const svgEl = svgContainer.querySelector(\"svg\");\n    if (!svgEl) {\n        throw new Error(\"SVG element not found\");\n    }\n    const rect = svgEl.getBoundingClientRect();\n    const width = rect.width;\n    const height = rect.height;\n    // Set width and height explictly since in firefox it gets set to 0\n    // if the width and height are not expilcitly set\n    // eg in some cases like er Diagram, gnatt, width and height is set as 100%\n    // which sets the dimensions as 0 in firefox and thus the diagram isn't rendered\n    svgEl.setAttribute(\"width\", `${width}`);\n    svgEl.setAttribute(\"height\", `${height}`);\n    // Convert SVG to image\n    const mimeType = \"image/svg+xml\";\n    const decoded = unescape(encodeURIComponent(svgEl.outerHTML));\n    const base64 = btoa(decoded);\n    const dataURL = `data:image/svg+xml;base64,${base64}`;\n    const graphImage = {\n        type: \"graphImage\",\n        mimeType,\n        dataURL,\n        width,\n        height,\n    };\n    return graphImage;\n};\nexport const parseMermaid = async (definition) => {\n    mermaid.initialize({\n        startOnLoad: false,\n        flowchart: { curve: \"linear\" },\n        themeVariables: {\n            fontSize: `${DEFAULT_FONT_SIZE * 1.25}px`,\n        },\n    });\n    // Parse the diagram\n    const diagram = await mermaid.mermaidAPI.getDiagramFromText(encodeEntities(definition));\n    // Render the SVG diagram\n    const { svg } = await mermaid.render(\"mermaid-to-excalidraw\", definition);\n    // Append Svg to DOM\n    const svgContainer = document.createElement(\"div\");\n    svgContainer.setAttribute(\"style\", `opacity: 0; position: relative; z-index: -1;`);\n    svgContainer.innerHTML = svg;\n    svgContainer.id = \"mermaid-diagram\";\n    document.body.appendChild(svgContainer);\n    let data;\n    switch (diagram.type) {\n        case \"flowchart-v2\": {\n            data = parseMermaidFlowChartDiagram(diagram, svgContainer);\n            break;\n        }\n        case \"sequence\": {\n            data = parseMermaidSequenceDiagram(diagram, svgContainer);\n            break;\n        }\n        // fallback to image if diagram type not-supported\n        default: {\n            data = convertSvgToGraphImage(svgContainer);\n        }\n    }\n    svgContainer.remove();\n    return data;\n};\n", "import { graphToExcalidraw } from \"./graphToExcalidraw.js\";\nimport { parseMermaid } from \"./parseMermaid.js\";\nconst parseMermaidToExcalidraw = async (definition, options = {}) => {\n    const parsedMermaidData = await parseMermaid(definition);\n    const excalidrawElements = graphToExcalidraw(parsedMermaidData, options);\n    return excalidrawElements;\n};\nexport { parseMermaidToExcalidraw };\n"],
  "mappings": "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",
  "names": ["require_dist", "removeMarkdown", "VERTEX_TYPE", "LABEL_STYLE_PROPERTY", "CONTAINER_STYLE_PROPERTY", "transformX", "transformY"]
}
